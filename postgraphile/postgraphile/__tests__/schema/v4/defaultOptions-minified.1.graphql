input Add1MutationInput {
  arg0: Int!
  arg1: Int!
  clientMutationId: String
}

type Add1MutationPayload {
  clientMutationId: String
  integer: Int!
  query: Query
}

input Add2MutationInput {
  a: Int!
  b: Int
  clientMutationId: String
}

type Add2MutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Add3MutationInput {
  a: Int
  arg1: Int
  clientMutationId: String
}

type Add3MutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Add4MutationErrorInput {
  arg0: Int
  b: Int
  clientMutationId: String
}

type Add4MutationErrorPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Add4MutationInput {
  arg0: Int
  b: Int
  clientMutationId: String
}

type Add4MutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

enum AnEnum {
  ASTERISK
  ASTERISK_ASTERISK
  ASTERISK_ASTERISK_ASTERISK
  ASTERISK_BAR
  ASTERISK_BAR_
  ASTERISK_BAZ_ASTERISK
  AWAITING
  DOLLAR
  FOO_ASTERISK
  FOO_ASTERISK_
  GREATER_THAN_OR_EQUAL
  LIKE
  PERCENT
  PUBLISHED
  REJECTED
  _ASTERISK_BAR_
  _ASTERISK_BAZ_ASTERISK_
  _FOO_ASTERISK
}

scalar AnInt

type AnIntRange {
  end: AnIntRangeBound
  start: AnIntRangeBound
}

type AnIntRangeBound {
  inclusive: Boolean!
  value: AnInt!
}

input AnIntRangeBoundInput {
  inclusive: Boolean!
  value: AnInt!
}

input AnIntRangeInput {
  end: AnIntRangeBoundInput
  start: AnIntRangeBoundInput
}

scalar AnotherInt

type AuthPayload {
  admin: Boolean
  id: Int
  jwt: JwtToken
  personById: Person
}

input AuthenticateFailInput {
  clientMutationId: String
}

type AuthenticateFailPayload {
  clientMutationId: String
  jwtToken: JwtToken
  query: Query
}

input AuthenticateInput {
  a: Int
  b: BigFloat
  c: BigInt
  clientMutationId: String
}

input AuthenticateManyInput {
  a: Int
  b: BigFloat
  c: BigInt
  clientMutationId: String
}

type AuthenticateManyPayload {
  clientMutationId: String
  jwtTokens: [JwtToken]
  query: Query
}

type AuthenticatePayload {
  clientMutationId: String
  jwtToken: JwtToken
  query: Query
}

input AuthenticatePayloadInput {
  a: Int
  b: BigFloat
  c: BigInt
  clientMutationId: String
}

type AuthenticatePayloadPayload {
  authPayload: AuthPayload
  clientMutationId: String
  personById: Person
  query: Query
}

scalar Base64EncodedBinary

scalar BigFloat

type BigFloatRange {
  end: BigFloatRangeBound
  start: BigFloatRangeBound
}

type BigFloatRangeBound {
  inclusive: Boolean!
  value: BigFloat!
}

input BigFloatRangeBoundInput {
  inclusive: Boolean!
  value: BigFloat!
}

input BigFloatRangeInput {
  end: BigFloatRangeBoundInput
  start: BigFloatRangeBoundInput
}

scalar BigInt

enum Color {
  BLUE
  GREEN
  RED
}

type CompoundKey implements Node {
  extra: Boolean
  foreignKeysByCompoundKey1AndCompoundKey2(after: Cursor, before: Cursor, condition: ForeignKeyCondition, first: Int, last: Int, offset: Int, orderBy: [ForeignKeysOrderBy!] = [NATURAL]): ForeignKeysConnection!
  nodeId: ID!
  personByPersonId1: Person
  personByPersonId2: Person
  personId1: Int!
  personId2: Int!
  uniqueForeignKeyByCompoundKey1AndCompoundKey2: UniqueForeignKey
}

input CompoundKeyCondition {
  extra: Boolean
  personId1: Int
  personId2: Int
}

input CompoundKeyInput {
  extra: Boolean
  personId1: Int!
  personId2: Int!
}

input CompoundKeyPatch {
  extra: Boolean
  personId1: Int
  personId2: Int
}

type CompoundKeysConnection {
  edges: [CompoundKeysEdge]!
  nodes: [CompoundKey]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CompoundKeysEdge {
  cursor: Cursor
  node: CompoundKey
}

enum CompoundKeysOrderBy {
  EXTRA_ASC
  EXTRA_DESC
  NATURAL
  PERSON_ID_1_ASC
  PERSON_ID_1_DESC
  PERSON_ID_2_ASC
  PERSON_ID_2_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type CompoundType {
  a: Int
  b: String
  c: Color
  computedField: Int
  d: UUID
  e: EnumCaps
  f: EnumWithEmptyString
  fooBar: Int
  g: Interval
}

input CompoundTypeArrayMutationInput {
  clientMutationId: String
  object: CompoundTypeInput
}

type CompoundTypeArrayMutationPayload {
  clientMutationId: String
  compoundTypes: [CompoundType]
  query: Query
}

input CompoundTypeInput {
  a: Int
  b: String
  c: Color
  d: UUID
  e: EnumCaps
  f: EnumWithEmptyString
  fooBar: Int
  g: IntervalInput
}

input CompoundTypeMutationInput {
  clientMutationId: String
  object: CompoundTypeInput
}

type CompoundTypeMutationPayload {
  clientMutationId: String
  compoundType: CompoundType
  query: Query
}

input CompoundTypeSetMutationInput {
  clientMutationId: String
  object: CompoundTypeInput
}

type CompoundTypeSetMutationPayload {
  clientMutationId: String
  compoundTypes: [CompoundType]
  query: Query
}

type CompoundTypesConnection {
  edges: [CompoundTypesEdge]!
  nodes: [CompoundType]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CompoundTypesEdge {
  cursor: Cursor
  node: CompoundType
}

type Comptype {
  isOptimised: Boolean
  schedule: Datetime
}

input ComptypeInput {
  isOptimised: Boolean
  schedule: Datetime
}

input CreateCompoundKeyInput {
  clientMutationId: String
  compoundKey: CompoundKeyInput!
}

type CreateCompoundKeyPayload {
  clientMutationId: String
  compoundKey: CompoundKey
  compoundKeyEdge(orderBy: [CompoundKeysOrderBy!]! = [PRIMARY_KEY_ASC]): CompoundKeysEdge
  personByPersonId1: Person
  personByPersonId2: Person
  query: Query
}

input CreateDefaultValueInput {
  clientMutationId: String
  defaultValue: DefaultValueInput!
}

type CreateDefaultValuePayload {
  clientMutationId: String
  defaultValue: DefaultValue
  defaultValueEdge(orderBy: [DefaultValuesOrderBy!]! = [PRIMARY_KEY_ASC]): DefaultValuesEdge
  query: Query
}

input CreateEdgeCaseInput {
  clientMutationId: String
  edgeCase: EdgeCaseInput!
}

type CreateEdgeCasePayload {
  clientMutationId: String
  edgeCase: EdgeCase
  query: Query
}

input CreateForeignKeyInput {
  clientMutationId: String
  foreignKey: ForeignKeyInput!
}

type CreateForeignKeyPayload {
  clientMutationId: String
  compoundKeyByCompoundKey1AndCompoundKey2: CompoundKey
  foreignKey: ForeignKey
  personByPersonId: Person
  query: Query
}

input CreateInputInput {
  clientMutationId: String
  input: InputInput!
}

type CreateInputPayload {
  clientMutationId: String
  input: Input
  inputEdge(orderBy: [InputsOrderBy!]! = [PRIMARY_KEY_ASC]): InputsEdge
  query: Query
}

input CreateIssue756Input {
  clientMutationId: String
  issue756: Issue756Input!
}

type CreateIssue756Payload {
  clientMutationId: String
  issue756: Issue756
  issue756Edge(orderBy: [Issue756SOrderBy!]! = [PRIMARY_KEY_ASC]): Issue756SEdge
  query: Query
}

input CreateLeftArmInput {
  clientMutationId: String
  leftArm: LeftArmInput!
}

type CreateLeftArmPayload {
  clientMutationId: String
  leftArm: LeftArm
  leftArmEdge(orderBy: [LeftArmsOrderBy!]! = [PRIMARY_KEY_ASC]): LeftArmsEdge
  personByPersonId: Person
  query: Query
}

input CreateListInput {
  clientMutationId: String
  list: ListInput!
}

type CreateListPayload {
  clientMutationId: String
  list: List
  listEdge(orderBy: [ListsOrderBy!]! = [PRIMARY_KEY_ASC]): ListsEdge
  query: Query
}

input CreateMyTableInput {
  clientMutationId: String
  myTable: MyTableInput!
}

type CreateMyTablePayload {
  clientMutationId: String
  myTable: MyTable
  myTableEdge(orderBy: [MyTablesOrderBy!]! = [PRIMARY_KEY_ASC]): MyTablesEdge
  query: Query
}

input CreateNoPrimaryKeyInput {
  clientMutationId: String
  noPrimaryKey: NoPrimaryKeyInput!
}

type CreateNoPrimaryKeyPayload {
  clientMutationId: String
  noPrimaryKey: NoPrimaryKey
  query: Query
}

input CreateNullTestRecordInput {
  clientMutationId: String
  nullTestRecord: NullTestRecordInput!
}

type CreateNullTestRecordPayload {
  clientMutationId: String
  nullTestRecord: NullTestRecord
  nullTestRecordEdge(orderBy: [NullTestRecordsOrderBy!]! = [PRIMARY_KEY_ASC]): NullTestRecordsEdge
  query: Query
}

input CreatePatchInput {
  clientMutationId: String
  patch: PatchInput!
}

type CreatePatchPayload {
  clientMutationId: String
  patch: Patch
  patchEdge(orderBy: [PatchesOrderBy!]! = [PRIMARY_KEY_ASC]): PatchesEdge
  query: Query
}

input CreatePersonInput {
  clientMutationId: String
  person: PersonInput!
}

type CreatePersonPayload {
  clientMutationId: String
  person: Person
  personEdge(orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]): PeopleEdge
  query: Query
}

input CreatePersonSecretInput {
  clientMutationId: String
  personSecret: PersonSecretInput!
}

type CreatePersonSecretPayload {
  clientMutationId: String
  personByPersonId: Person
  query: Query
}

input CreatePostInput {
  clientMutationId: String
  post: PostInput!
}

type CreatePostPayload {
  clientMutationId: String
  personByAuthorId: Person
  post: Post
  postEdge(orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]): PostsEdge
  query: Query
}

input CreateReservedInput {
  clientMutationId: String
  reserved: ReservedInput!
}

input CreateReservedInputRecordInput {
  clientMutationId: String
  reservedInputRecord: ReservedInputRecordInput!
}

type CreateReservedInputRecordPayload {
  clientMutationId: String
  query: Query
  reservedInputRecord: ReservedInputRecord
  reservedInputRecordEdge(orderBy: [ReservedInputRecordsOrderBy!]! = [PRIMARY_KEY_ASC]): ReservedInputRecordsEdge
}

input CreateReservedPatchRecordInput {
  clientMutationId: String
  reservedPatchRecord: ReservedPatchRecordInput!
}

type CreateReservedPatchRecordPayload {
  clientMutationId: String
  query: Query
  reservedPatchRecord: ReservedPatchRecord
  reservedPatchRecordEdge(orderBy: [ReservedPatchRecordsOrderBy!]! = [PRIMARY_KEY_ASC]): ReservedPatchRecordsEdge
}

type CreateReservedPayload {
  clientMutationId: String
  query: Query
  reserved: Reserved
  reservedEdge(orderBy: [ReservedsOrderBy!]! = [PRIMARY_KEY_ASC]): ReservedsEdge
}

input CreateSimilarTable1Input {
  clientMutationId: String
  similarTable1: SimilarTable1Input!
}

type CreateSimilarTable1Payload {
  clientMutationId: String
  query: Query
  similarTable1: SimilarTable1
  similarTable1Edge(orderBy: [SimilarTable1SOrderBy!]! = [PRIMARY_KEY_ASC]): SimilarTable1SEdge
}

input CreateSimilarTable2Input {
  clientMutationId: String
  similarTable2: SimilarTable2Input!
}

type CreateSimilarTable2Payload {
  clientMutationId: String
  query: Query
  similarTable2: SimilarTable2
  similarTable2Edge(orderBy: [SimilarTable2SOrderBy!]! = [PRIMARY_KEY_ASC]): SimilarTable2SEdge
}

input CreateTestviewInput {
  clientMutationId: String
  testview: TestviewInput!
}

type CreateTestviewPayload {
  clientMutationId: String
  query: Query
  testview: Testview
}

input CreateTypeInput {
  clientMutationId: String
  type: TypeInput!
}

type CreateTypePayload {
  clientMutationId: String
  postById: Post
  postBySmallint: Post
  query: Query
  type: Type
  typeEdge(orderBy: [TypesOrderBy!]! = [PRIMARY_KEY_ASC]): TypesEdge
}

input CreateUpdatableViewInput {
  clientMutationId: String
  updatableView: UpdatableViewInput!
}

type CreateUpdatableViewPayload {
  clientMutationId: String
  query: Query
  updatableView: UpdatableView
}

input CreateViewTableInput {
  clientMutationId: String
  viewTable: ViewTableInput!
}

type CreateViewTablePayload {
  clientMutationId: String
  query: Query
  viewTable: ViewTable
  viewTableEdge(orderBy: [ViewTablesOrderBy!]! = [PRIMARY_KEY_ASC]): ViewTablesEdge
}

scalar Cursor

scalar Date

type DateRange {
  end: DateRangeBound
  start: DateRangeBound
}

type DateRangeBound {
  inclusive: Boolean!
  value: Date!
}

input DateRangeBoundInput {
  inclusive: Boolean!
  value: Date!
}

input DateRangeInput {
  end: DateRangeBoundInput
  start: DateRangeBoundInput
}

scalar Datetime

type DefaultValue implements Node {
  id: Int!
  nodeId: ID!
  nullValue: String
}

input DefaultValueCondition {
  id: Int
  nullValue: String
}

input DefaultValueInput {
  id: Int
  nullValue: String
}

input DefaultValuePatch {
  id: Int
  nullValue: String
}

type DefaultValuesConnection {
  edges: [DefaultValuesEdge]!
  nodes: [DefaultValue]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DefaultValuesEdge {
  cursor: Cursor
  node: DefaultValue
}

enum DefaultValuesOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  NULL_VALUE_ASC
  NULL_VALUE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

input DeleteCompoundKeyByPersonId1AndPersonId2Input {
  clientMutationId: String
  personId1: Int!
  personId2: Int!
}

input DeleteCompoundKeyInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteCompoundKeyPayload {
  clientMutationId: String
  compoundKey: CompoundKey
  compoundKeyEdge(orderBy: [CompoundKeysOrderBy!]! = [PRIMARY_KEY_ASC]): CompoundKeysEdge
  deletedCompoundKeyId: ID
  personByPersonId1: Person
  personByPersonId2: Person
  query: Query
}

input DeleteDefaultValueByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteDefaultValueInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteDefaultValuePayload {
  clientMutationId: String
  defaultValue: DefaultValue
  defaultValueEdge(orderBy: [DefaultValuesOrderBy!]! = [PRIMARY_KEY_ASC]): DefaultValuesEdge
  deletedDefaultValueId: ID
  query: Query
}

input DeleteInputByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteInputInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteInputPayload {
  clientMutationId: String
  deletedInputId: ID
  input: Input
  inputEdge(orderBy: [InputsOrderBy!]! = [PRIMARY_KEY_ASC]): InputsEdge
  query: Query
}

input DeleteIssue756ByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteIssue756Input {
  clientMutationId: String
  nodeId: ID!
}

type DeleteIssue756Payload {
  clientMutationId: String
  deletedIssue756Id: ID
  issue756: Issue756
  issue756Edge(orderBy: [Issue756SOrderBy!]! = [PRIMARY_KEY_ASC]): Issue756SEdge
  query: Query
}

input DeleteLeftArmByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteLeftArmByPersonIdInput {
  clientMutationId: String
  personId: Int!
}

input DeleteLeftArmInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteLeftArmPayload {
  clientMutationId: String
  deletedLeftArmId: ID
  leftArm: LeftArm
  leftArmEdge(orderBy: [LeftArmsOrderBy!]! = [PRIMARY_KEY_ASC]): LeftArmsEdge
  personByPersonId: Person
  query: Query
}

input DeleteListByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteListInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteListPayload {
  clientMutationId: String
  deletedListId: ID
  list: List
  listEdge(orderBy: [ListsOrderBy!]! = [PRIMARY_KEY_ASC]): ListsEdge
  query: Query
}

input DeleteMyTableByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteMyTableInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteMyTablePayload {
  clientMutationId: String
  deletedMyTableId: ID
  myTable: MyTable
  myTableEdge(orderBy: [MyTablesOrderBy!]! = [PRIMARY_KEY_ASC]): MyTablesEdge
  query: Query
}

input DeleteNoPrimaryKeyByIdInput {
  clientMutationId: String
  id: Int!
}

type DeleteNoPrimaryKeyPayload {
  clientMutationId: String
  noPrimaryKey: NoPrimaryKey
  query: Query
}

input DeleteNullTestRecordByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteNullTestRecordInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteNullTestRecordPayload {
  clientMutationId: String
  deletedNullTestRecordId: ID
  nullTestRecord: NullTestRecord
  nullTestRecordEdge(orderBy: [NullTestRecordsOrderBy!]! = [PRIMARY_KEY_ASC]): NullTestRecordsEdge
  query: Query
}

input DeletePatchByIdInput {
  clientMutationId: String
  id: Int!
}

input DeletePatchInput {
  clientMutationId: String
  nodeId: ID!
}

type DeletePatchPayload {
  clientMutationId: String
  deletedPatchId: ID
  patch: Patch
  patchEdge(orderBy: [PatchesOrderBy!]! = [PRIMARY_KEY_ASC]): PatchesEdge
  query: Query
}

input DeletePersonByEmailInput {
  clientMutationId: String
  email: Email!
}

input DeletePersonByIdInput {
  clientMutationId: String
  id: Int!
}

input DeletePersonInput {
  clientMutationId: String
  nodeId: ID!
}

type DeletePersonPayload {
  clientMutationId: String
  deletedPersonId: ID
  person: Person
  personEdge(orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]): PeopleEdge
  query: Query
}

input DeletePersonSecretByPersonIdInput {
  clientMutationId: String
  personId: Int!
}

input DeletePersonSecretInput {
  clientMutationId: String
  nodeId: ID!
}

type DeletePersonSecretPayload {
  clientMutationId: String
  deletedPersonSecretId: ID
  personByPersonId: Person
  personSecret: PersonSecret
  query: Query
}

input DeletePostByIdInput {
  clientMutationId: String
  id: Int!
}

input DeletePostInput {
  clientMutationId: String
  nodeId: ID!
}

type DeletePostPayload {
  clientMutationId: String
  deletedPostId: ID
  personByAuthorId: Person
  post: Post
  postEdge(orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]): PostsEdge
  query: Query
}

input DeleteReservedByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteReservedInput {
  clientMutationId: String
  nodeId: ID!
}

input DeleteReservedInputRecordByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteReservedInputRecordInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteReservedInputRecordPayload {
  clientMutationId: String
  deletedReservedInputId: ID
  query: Query
  reservedInputRecord: ReservedInputRecord
  reservedInputRecordEdge(orderBy: [ReservedInputRecordsOrderBy!]! = [PRIMARY_KEY_ASC]): ReservedInputRecordsEdge
}

input DeleteReservedPatchRecordByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteReservedPatchRecordInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteReservedPatchRecordPayload {
  clientMutationId: String
  deletedReservedPatchId: ID
  query: Query
  reservedPatchRecord: ReservedPatchRecord
  reservedPatchRecordEdge(orderBy: [ReservedPatchRecordsOrderBy!]! = [PRIMARY_KEY_ASC]): ReservedPatchRecordsEdge
}

type DeleteReservedPayload {
  clientMutationId: String
  deletedReservedId: ID
  query: Query
  reserved: Reserved
  reservedEdge(orderBy: [ReservedsOrderBy!]! = [PRIMARY_KEY_ASC]): ReservedsEdge
}

input DeleteSimilarTable1ByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteSimilarTable1Input {
  clientMutationId: String
  nodeId: ID!
}

type DeleteSimilarTable1Payload {
  clientMutationId: String
  deletedSimilarTable1Id: ID
  query: Query
  similarTable1: SimilarTable1
  similarTable1Edge(orderBy: [SimilarTable1SOrderBy!]! = [PRIMARY_KEY_ASC]): SimilarTable1SEdge
}

input DeleteSimilarTable2ByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteSimilarTable2Input {
  clientMutationId: String
  nodeId: ID!
}

type DeleteSimilarTable2Payload {
  clientMutationId: String
  deletedSimilarTable2Id: ID
  query: Query
  similarTable2: SimilarTable2
  similarTable2Edge(orderBy: [SimilarTable2SOrderBy!]! = [PRIMARY_KEY_ASC]): SimilarTable2SEdge
}

input DeleteTypeByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteTypeInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteTypePayload {
  clientMutationId: String
  deletedTypeId: ID
  postById: Post
  postBySmallint: Post
  query: Query
  type: Type
  typeEdge(orderBy: [TypesOrderBy!]! = [PRIMARY_KEY_ASC]): TypesEdge
}

input DeleteViewTableByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteViewTableInput {
  clientMutationId: String
  nodeId: ID!
}

type DeleteViewTablePayload {
  clientMutationId: String
  deletedViewTableId: ID
  query: Query
  viewTable: ViewTable
  viewTableEdge(orderBy: [ViewTablesOrderBy!]! = [PRIMARY_KEY_ASC]): ViewTablesEdge
}

type EdgeCase {
  computed: String
  notNullHasDefault: Boolean!
  rowId: Int
  wontCastEasy: Int
}

input EdgeCaseCondition {
  notNullHasDefault: Boolean
  rowId: Int
  wontCastEasy: Int
}

input EdgeCaseInput {
  notNullHasDefault: Boolean
  rowId: Int
  wontCastEasy: Int
}

type EdgeCasesConnection {
  edges: [EdgeCasesEdge]!
  nodes: [EdgeCase]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EdgeCasesEdge {
  cursor: Cursor
  node: EdgeCase
}

enum EdgeCasesOrderBy {
  COMPUTED_ASC
  COMPUTED_DESC
  NATURAL
  NOT_NULL_HAS_DEFAULT_ASC
  NOT_NULL_HAS_DEFAULT_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  WONT_CAST_EASY_ASC
  WONT_CAST_EASY_DESC
}

scalar Email

enum EnumCaps {
  BAR_FOO
  BAZ_QUX
  FOO_BAR
  _0_BAR
}

enum EnumWithEmptyString {
  ONE
  TWO
  _EMPTY_
}

input FloatRangeBoundInput {
  inclusive: Boolean!
  value: Float!
}

input FloatRangeInput {
  end: FloatRangeBoundInput
  start: FloatRangeBoundInput
}

type ForeignKey {
  compoundKey1: Int
  compoundKey2: Int
  compoundKeyByCompoundKey1AndCompoundKey2: CompoundKey
  personByPersonId: Person
  personId: Int
}

input ForeignKeyCondition {
  compoundKey1: Int
  compoundKey2: Int
  personId: Int
}

input ForeignKeyInput {
  compoundKey1: Int
  compoundKey2: Int
  personId: Int
}

type ForeignKeysConnection {
  edges: [ForeignKeysEdge]!
  nodes: [ForeignKey]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ForeignKeysEdge {
  cursor: Cursor
  node: ForeignKey
}

enum ForeignKeysOrderBy {
  COMPOUND_KEY_1_ASC
  COMPOUND_KEY_1_DESC
  COMPOUND_KEY_2_ASC
  COMPOUND_KEY_2_DESC
  NATURAL
  PERSON_ID_ASC
  PERSON_ID_DESC
}

type FuncOutComplexRecord {
  x: Int
  y: CompoundType
  z: Person
}

type FuncOutComplexSetofConnection {
  edges: [FuncOutComplexSetofEdge]!
  nodes: [FuncOutComplexSetofRecord]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FuncOutComplexSetofEdge {
  cursor: Cursor
  node: FuncOutComplexSetofRecord
}

type FuncOutComplexSetofRecord {
  x: Int
  y: CompoundType
  z: Person
}

type FuncOutOutCompoundTypeRecord {
  o1: Int
  o2: CompoundType
}

type FuncOutOutRecord {
  firstOut: Int
  secondOut: String
}

type FuncOutOutSetofConnection {
  edges: [FuncOutOutSetofEdge]!
  nodes: [FuncOutOutSetofRecord]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FuncOutOutSetofEdge {
  cursor: Cursor
  node: FuncOutOutSetofRecord
}

type FuncOutOutSetofRecord {
  o1: Int
  o2: String
}

type FuncOutOutUnnamedRecord {
  arg1: Int
  arg2: String
}

type FuncOutSetofConnection {
  edges: [FuncOutSetofEdge]!
  nodes: [Int]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FuncOutSetofEdge {
  cursor: Cursor
  node: Int
}

type FuncOutUnnamedOutOutUnnamedRecord {
  arg1: Int
  arg3: Int
  o2: String
}

type FuncReturnsTableMultiColConnection {
  edges: [FuncReturnsTableMultiColEdge]!
  nodes: [FuncReturnsTableMultiColRecord]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FuncReturnsTableMultiColEdge {
  cursor: Cursor
  node: FuncReturnsTableMultiColRecord
}

type FuncReturnsTableMultiColRecord {
  col1: Int
  col2: String
}

type FuncReturnsTableOneColConnection {
  edges: [FuncReturnsTableOneColEdge]!
  nodes: [Int]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FuncReturnsTableOneColEdge {
  cursor: Cursor
  node: Int
}

scalar Guid

input GuidFnInput {
  clientMutationId: String
  g: Guid
}

type GuidFnPayload {
  clientMutationId: String
  guid: Guid
  query: Query
}

type Input implements Node {
  id: Int!
  nodeId: ID!
}

input InputCondition {
  id: Int
}

input InputInput {
  id: Int
}

input InputPatch {
  id: Int
}

type InputsConnection {
  edges: [InputsEdge]!
  nodes: [Input]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type InputsEdge {
  cursor: Cursor
  node: Input
}

enum InputsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

input IntSetMutationInput {
  clientMutationId: String
  x: Int
  y: Int
  z: Int
}

type IntSetMutationPayload {
  clientMutationId: String
  integers: [Int]
  query: Query
}

type IntSetQueryConnection {
  edges: [IntSetQueryEdge]!
  nodes: [Int]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type IntSetQueryEdge {
  cursor: Cursor
  node: Int
}

scalar InternetAddress

type Interval {
  days: Int
  hours: Int
  minutes: Int
  months: Int
  seconds: Float
  years: Int
}

input IntervalInput {
  days: Int
  hours: Int
  minutes: Int
  months: Int
  seconds: Float
  years: Int
}

type Issue756 implements Node {
  id: Int!
  nodeId: ID!
  ts: NotNullTimestamp!
}

input Issue756Condition {
  id: Int
  ts: NotNullTimestamp
}

input Issue756Input {
  id: Int
  ts: NotNullTimestamp
}

input Issue756MutationInput {
  clientMutationId: String
}

type Issue756MutationPayload {
  clientMutationId: String
  issue756: Issue756
  issue756Edge(orderBy: [Issue756SOrderBy!]! = [PRIMARY_KEY_ASC]): Issue756SEdge
  query: Query
}

input Issue756Patch {
  id: Int
  ts: NotNullTimestamp
}

type Issue756SConnection {
  edges: [Issue756SEdge]!
  nodes: [Issue756]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Issue756SEdge {
  cursor: Cursor
  node: Issue756
}

enum Issue756SOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TS_ASC
  TS_DESC
}

input Issue756SetMutationInput {
  clientMutationId: String
}

type Issue756SetMutationPayload {
  clientMutationId: String
  issue756S: [Issue756]
  query: Query
}

scalar JSON

scalar JSONPath

input JsonIdentityMutationInput {
  clientMutationId: String
  json: JSON
}

type JsonIdentityMutationPayload {
  clientMutationId: String
  json: JSON
  query: Query
}

input JsonbIdentityMutationInput {
  clientMutationId: String
  json: JSON
}

type JsonbIdentityMutationPayload {
  clientMutationId: String
  json: JSON
  query: Query
}

input JsonbIdentityMutationPlpgsqlInput {
  _theJson: JSON!
  clientMutationId: String
}

type JsonbIdentityMutationPlpgsqlPayload {
  clientMutationId: String
  json: JSON
  query: Query
}

input JsonbIdentityMutationPlpgsqlWithDefaultInput {
  _theJson: JSON
  clientMutationId: String
}

type JsonbIdentityMutationPlpgsqlWithDefaultPayload {
  clientMutationId: String
  json: JSON
  query: Query
}

type JwtToken {
  a: Int
  b: BigFloat
  c: BigInt
  exp: BigInt
  role: String
}

scalar KeyValueHash

scalar LTree

type LeftArm implements Node {
  id: Int!
  lengthInMetres: Float
  mood: String!
  nodeId: ID!
  personByPersonId: Person
  personId: Int
}

input LeftArmBaseInput {
  id: Int
  lengthInMetres: Float
  mood: String
  personId: Int
}

input LeftArmCondition {
  id: Int
  lengthInMetres: Float
  mood: String
  personId: Int
}

input LeftArmIdentityInput {
  clientMutationId: String
  leftArm: LeftArmBaseInput
}

type LeftArmIdentityPayload {
  clientMutationId: String
  leftArm: LeftArm
  leftArmEdge(orderBy: [LeftArmsOrderBy!]! = [PRIMARY_KEY_ASC]): LeftArmsEdge
  personByPersonId: Person
  query: Query
}

input LeftArmInput {
  id: Int
  lengthInMetres: Float
  mood: String
  personId: Int
}

input LeftArmPatch {
  id: Int
  lengthInMetres: Float
  mood: String
  personId: Int
}

type LeftArmsConnection {
  edges: [LeftArmsEdge]!
  nodes: [LeftArm]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LeftArmsEdge {
  cursor: Cursor
  node: LeftArm
}

enum LeftArmsOrderBy {
  ID_ASC
  ID_DESC
  LENGTH_IN_METRES_ASC
  LENGTH_IN_METRES_DESC
  MOOD_ASC
  MOOD_DESC
  NATURAL
  PERSON_ID_ASC
  PERSON_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type List implements Node {
  byteaArray: [Base64EncodedBinary]
  byteaArrayNn: [Base64EncodedBinary]!
  compoundTypeArray: [CompoundType]
  compoundTypeArrayNn: [CompoundType]!
  dateArray: [Date]
  dateArrayNn: [Date]!
  enumArray: [Color]
  enumArrayNn: [Color]!
  id: Int!
  intArray: [Int]
  intArrayNn: [Int]!
  nodeId: ID!
  timestamptzArray: [Datetime]
  timestamptzArrayNn: [Datetime]!
}

input ListBdeMutationInput {
  b: [String]
  clientMutationId: String
  d: String
  e: String
}

type ListBdeMutationPayload {
  clientMutationId: String
  query: Query
  uuids: [UUID]
}

input ListCondition {
  compoundTypeArray: [CompoundTypeInput]
  compoundTypeArrayNn: [CompoundTypeInput]
  dateArray: [Date]
  dateArrayNn: [Date]
  enumArray: [Color]
  enumArrayNn: [Color]
  id: Int
  intArray: [Int]
  intArrayNn: [Int]
  timestamptzArray: [Datetime]
  timestamptzArrayNn: [Datetime]
}

input ListInput {
  byteaArray: [Base64EncodedBinary]
  byteaArrayNn: [Base64EncodedBinary]!
  compoundTypeArray: [CompoundTypeInput]
  compoundTypeArrayNn: [CompoundTypeInput]!
  dateArray: [Date]
  dateArrayNn: [Date]!
  enumArray: [Color]
  enumArrayNn: [Color]!
  id: Int
  intArray: [Int]
  intArrayNn: [Int]!
  timestamptzArray: [Datetime]
  timestamptzArrayNn: [Datetime]!
}

input ListOfCompoundTypesMutationInput {
  clientMutationId: String
  records: [CompoundTypeInput]
}

type ListOfCompoundTypesMutationPayload {
  clientMutationId: String
  compoundTypes: [CompoundType]
  query: Query
}

input ListPatch {
  byteaArray: [Base64EncodedBinary]
  byteaArrayNn: [Base64EncodedBinary]
  compoundTypeArray: [CompoundTypeInput]
  compoundTypeArrayNn: [CompoundTypeInput]
  dateArray: [Date]
  dateArrayNn: [Date]
  enumArray: [Color]
  enumArrayNn: [Color]
  id: Int
  intArray: [Int]
  intArrayNn: [Int]
  timestamptzArray: [Datetime]
  timestamptzArrayNn: [Datetime]
}

type ListsConnection {
  edges: [ListsEdge]!
  nodes: [List]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ListsEdge {
  cursor: Cursor
  node: List
}

enum ListsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

input Mult1Input {
  arg0: Int
  arg1: Int
  clientMutationId: String
}

type Mult1Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Mult2Input {
  arg0: Int
  arg1: Int
  clientMutationId: String
}

type Mult2Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Mult3Input {
  arg0: Int!
  arg1: Int!
  clientMutationId: String
}

type Mult3Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Mult4Input {
  arg0: Int!
  arg1: Int!
  clientMutationId: String
}

type Mult4Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

type Mutation {
  add1Mutation(input: Add1MutationInput!): Add1MutationPayload
  add2Mutation(input: Add2MutationInput!): Add2MutationPayload
  add3Mutation(input: Add3MutationInput!): Add3MutationPayload
  add4Mutation(input: Add4MutationInput!): Add4MutationPayload
  add4MutationError(input: Add4MutationErrorInput!): Add4MutationErrorPayload
  authenticate(input: AuthenticateInput!): AuthenticatePayload
  authenticateFail(input: AuthenticateFailInput!): AuthenticateFailPayload
  authenticateMany(input: AuthenticateManyInput!): AuthenticateManyPayload
  authenticatePayload(input: AuthenticatePayloadInput!): AuthenticatePayloadPayload
  compoundTypeArrayMutation(input: CompoundTypeArrayMutationInput!): CompoundTypeArrayMutationPayload
  compoundTypeMutation(input: CompoundTypeMutationInput!): CompoundTypeMutationPayload
  compoundTypeSetMutation(input: CompoundTypeSetMutationInput!): CompoundTypeSetMutationPayload
  createCompoundKey(input: CreateCompoundKeyInput!): CreateCompoundKeyPayload
  createDefaultValue(input: CreateDefaultValueInput!): CreateDefaultValuePayload
  createEdgeCase(input: CreateEdgeCaseInput!): CreateEdgeCasePayload
  createForeignKey(input: CreateForeignKeyInput!): CreateForeignKeyPayload
  createInput(input: CreateInputInput!): CreateInputPayload
  createIssue756(input: CreateIssue756Input!): CreateIssue756Payload
  createLeftArm(input: CreateLeftArmInput!): CreateLeftArmPayload
  createList(input: CreateListInput!): CreateListPayload
  createMyTable(input: CreateMyTableInput!): CreateMyTablePayload
  createNoPrimaryKey(input: CreateNoPrimaryKeyInput!): CreateNoPrimaryKeyPayload
  createNullTestRecord(input: CreateNullTestRecordInput!): CreateNullTestRecordPayload
  createPatch(input: CreatePatchInput!): CreatePatchPayload
  createPerson(input: CreatePersonInput!): CreatePersonPayload
  createPost(input: CreatePostInput!): CreatePostPayload
  createReserved(input: CreateReservedInput!): CreateReservedPayload
  createReservedInputRecord(input: CreateReservedInputRecordInput!): CreateReservedInputRecordPayload
  createReservedPatchRecord(input: CreateReservedPatchRecordInput!): CreateReservedPatchRecordPayload
  createSimilarTable1(input: CreateSimilarTable1Input!): CreateSimilarTable1Payload
  createSimilarTable2(input: CreateSimilarTable2Input!): CreateSimilarTable2Payload
  createTestview(input: CreateTestviewInput!): CreateTestviewPayload
  createType(input: CreateTypeInput!): CreateTypePayload
  createUpdatableView(input: CreateUpdatableViewInput!): CreateUpdatableViewPayload
  createViewTable(input: CreateViewTableInput!): CreateViewTablePayload
  deleteCompoundKey(input: DeleteCompoundKeyInput!): DeleteCompoundKeyPayload
  deleteCompoundKeyByPersonId1AndPersonId2(input: DeleteCompoundKeyByPersonId1AndPersonId2Input!): DeleteCompoundKeyPayload
  deleteDefaultValue(input: DeleteDefaultValueInput!): DeleteDefaultValuePayload
  deleteDefaultValueById(input: DeleteDefaultValueByIdInput!): DeleteDefaultValuePayload
  deleteInput(input: DeleteInputInput!): DeleteInputPayload
  deleteInputById(input: DeleteInputByIdInput!): DeleteInputPayload
  deleteIssue756(input: DeleteIssue756Input!): DeleteIssue756Payload
  deleteIssue756ById(input: DeleteIssue756ByIdInput!): DeleteIssue756Payload
  deleteLeftArm(input: DeleteLeftArmInput!): DeleteLeftArmPayload
  deleteLeftArmById(input: DeleteLeftArmByIdInput!): DeleteLeftArmPayload
  deleteLeftArmByPersonId(input: DeleteLeftArmByPersonIdInput!): DeleteLeftArmPayload
  deleteList(input: DeleteListInput!): DeleteListPayload
  deleteListById(input: DeleteListByIdInput!): DeleteListPayload
  deleteMyTable(input: DeleteMyTableInput!): DeleteMyTablePayload
  deleteMyTableById(input: DeleteMyTableByIdInput!): DeleteMyTablePayload
  deleteNoPrimaryKeyById(input: DeleteNoPrimaryKeyByIdInput!): DeleteNoPrimaryKeyPayload
  deleteNullTestRecord(input: DeleteNullTestRecordInput!): DeleteNullTestRecordPayload
  deleteNullTestRecordById(input: DeleteNullTestRecordByIdInput!): DeleteNullTestRecordPayload
  deletePatch(input: DeletePatchInput!): DeletePatchPayload
  deletePatchById(input: DeletePatchByIdInput!): DeletePatchPayload
  deletePerson(input: DeletePersonInput!): DeletePersonPayload
  deletePersonByEmail(input: DeletePersonByEmailInput!): DeletePersonPayload
  deletePersonById(input: DeletePersonByIdInput!): DeletePersonPayload
  deletePost(input: DeletePostInput!): DeletePostPayload
  deletePostById(input: DeletePostByIdInput!): DeletePostPayload
  deleteReserved(input: DeleteReservedInput!): DeleteReservedPayload
  deleteReservedById(input: DeleteReservedByIdInput!): DeleteReservedPayload
  deleteReservedInputRecord(input: DeleteReservedInputRecordInput!): DeleteReservedInputRecordPayload
  deleteReservedInputRecordById(input: DeleteReservedInputRecordByIdInput!): DeleteReservedInputRecordPayload
  deleteReservedPatchRecord(input: DeleteReservedPatchRecordInput!): DeleteReservedPatchRecordPayload
  deleteReservedPatchRecordById(input: DeleteReservedPatchRecordByIdInput!): DeleteReservedPatchRecordPayload
  deleteSimilarTable1(input: DeleteSimilarTable1Input!): DeleteSimilarTable1Payload
  deleteSimilarTable1ById(input: DeleteSimilarTable1ByIdInput!): DeleteSimilarTable1Payload
  deleteSimilarTable2(input: DeleteSimilarTable2Input!): DeleteSimilarTable2Payload
  deleteSimilarTable2ById(input: DeleteSimilarTable2ByIdInput!): DeleteSimilarTable2Payload
  deleteType(input: DeleteTypeInput!): DeleteTypePayload
  deleteTypeById(input: DeleteTypeByIdInput!): DeleteTypePayload
  deleteViewTable(input: DeleteViewTableInput!): DeleteViewTablePayload
  deleteViewTableById(input: DeleteViewTableByIdInput!): DeleteViewTablePayload
  guidFn(input: GuidFnInput!): GuidFnPayload
  intSetMutation(input: IntSetMutationInput!): IntSetMutationPayload
  issue756Mutation(input: Issue756MutationInput!): Issue756MutationPayload
  issue756SetMutation(input: Issue756SetMutationInput!): Issue756SetMutationPayload
  jsonIdentityMutation(input: JsonIdentityMutationInput!): JsonIdentityMutationPayload
  jsonbIdentityMutation(input: JsonbIdentityMutationInput!): JsonbIdentityMutationPayload
  jsonbIdentityMutationPlpgsql(input: JsonbIdentityMutationPlpgsqlInput!): JsonbIdentityMutationPlpgsqlPayload
  jsonbIdentityMutationPlpgsqlWithDefault(input: JsonbIdentityMutationPlpgsqlWithDefaultInput!): JsonbIdentityMutationPlpgsqlWithDefaultPayload
  leftArmIdentity(input: LeftArmIdentityInput!): LeftArmIdentityPayload
  listBdeMutation(input: ListBdeMutationInput!): ListBdeMutationPayload
  listOfCompoundTypesMutation(input: ListOfCompoundTypesMutationInput!): ListOfCompoundTypesMutationPayload
  mult1(input: Mult1Input!): Mult1Payload
  mult2(input: Mult2Input!): Mult2Payload
  mult3(input: Mult3Input!): Mult3Payload
  mult4(input: Mult4Input!): Mult4Payload
  mutationCompoundTypeArray(input: MutationCompoundTypeArrayInput!): MutationCompoundTypeArrayPayload
  mutationInInout(input: MutationInInoutInput!): MutationInInoutPayload
  mutationInOut(input: MutationInOutInput!): MutationInOutPayload
  mutationIntervalArray(input: MutationIntervalArrayInput!): MutationIntervalArrayPayload
  mutationIntervalSet(input: MutationIntervalSetInput!): MutationIntervalSetPayload
  mutationOut(input: MutationOutInput!): MutationOutPayload
  mutationOutComplex(input: MutationOutComplexInput!): MutationOutComplexPayload
  mutationOutComplexSetof(input: MutationOutComplexSetofInput!): MutationOutComplexSetofPayload
  mutationOutOut(input: MutationOutOutInput!): MutationOutOutPayload
  mutationOutOutCompoundType(input: MutationOutOutCompoundTypeInput!): MutationOutOutCompoundTypePayload
  mutationOutOutSetof(input: MutationOutOutSetofInput!): MutationOutOutSetofPayload
  mutationOutOutUnnamed(input: MutationOutOutUnnamedInput!): MutationOutOutUnnamedPayload
  mutationOutSetof(input: MutationOutSetofInput!): MutationOutSetofPayload
  mutationOutTable(input: MutationOutTableInput!): MutationOutTablePayload
  mutationOutTableSetof(input: MutationOutTableSetofInput!): MutationOutTableSetofPayload
  mutationOutUnnamed(input: MutationOutUnnamedInput!): MutationOutUnnamedPayload
  mutationOutUnnamedOutOutUnnamed(input: MutationOutUnnamedOutOutUnnamedInput!): MutationOutUnnamedOutOutUnnamedPayload
  mutationReturnsTableMultiCol(input: MutationReturnsTableMultiColInput!): MutationReturnsTableMultiColPayload
  mutationReturnsTableOneCol(input: MutationReturnsTableOneColInput!): MutationReturnsTableOneColPayload
  mutationTextArray(input: MutationTextArrayInput!): MutationTextArrayPayload
  noArgsMutation(input: NoArgsMutationInput!): NoArgsMutationPayload
  postMany(input: PostManyInput!): PostManyPayload
  returnVoidMutation(input: ReturnVoidMutationInput!): ReturnVoidMutationPayload
  tableMutation(input: TableMutationInput!): TableMutationPayload
  tableSetMutation(input: TableSetMutationInput!): TableSetMutationPayload
  typeFunctionConnectionMutation(input: TypeFunctionConnectionMutationInput!): TypeFunctionConnectionMutationPayload
  typeFunctionListMutation(input: TypeFunctionListMutationInput!): TypeFunctionListMutationPayload
  typeFunctionMutation(input: TypeFunctionMutationInput!): TypeFunctionMutationPayload
  typesMutation(input: TypesMutationInput!): TypesMutationPayload
  updateCompoundKey(input: UpdateCompoundKeyInput!): UpdateCompoundKeyPayload
  updateCompoundKeyByPersonId1AndPersonId2(input: UpdateCompoundKeyByPersonId1AndPersonId2Input!): UpdateCompoundKeyPayload
  updateDefaultValue(input: UpdateDefaultValueInput!): UpdateDefaultValuePayload
  updateDefaultValueById(input: UpdateDefaultValueByIdInput!): UpdateDefaultValuePayload
  updateInput(input: UpdateInputInput!): UpdateInputPayload
  updateInputById(input: UpdateInputByIdInput!): UpdateInputPayload
  updateIssue756(input: UpdateIssue756Input!): UpdateIssue756Payload
  updateIssue756ById(input: UpdateIssue756ByIdInput!): UpdateIssue756Payload
  updateLeftArm(input: UpdateLeftArmInput!): UpdateLeftArmPayload
  updateLeftArmById(input: UpdateLeftArmByIdInput!): UpdateLeftArmPayload
  updateLeftArmByPersonId(input: UpdateLeftArmByPersonIdInput!): UpdateLeftArmPayload
  updateList(input: UpdateListInput!): UpdateListPayload
  updateListById(input: UpdateListByIdInput!): UpdateListPayload
  updateMyTable(input: UpdateMyTableInput!): UpdateMyTablePayload
  updateMyTableById(input: UpdateMyTableByIdInput!): UpdateMyTablePayload
  updateNoPrimaryKeyById(input: UpdateNoPrimaryKeyByIdInput!): UpdateNoPrimaryKeyPayload
  updateNullTestRecord(input: UpdateNullTestRecordInput!): UpdateNullTestRecordPayload
  updateNullTestRecordById(input: UpdateNullTestRecordByIdInput!): UpdateNullTestRecordPayload
  updatePatch(input: UpdatePatchInput!): UpdatePatchPayload
  updatePatchById(input: UpdatePatchByIdInput!): UpdatePatchPayload
  updatePerson(input: UpdatePersonInput!): UpdatePersonPayload
  updatePersonByEmail(input: UpdatePersonByEmailInput!): UpdatePersonPayload
  updatePersonById(input: UpdatePersonByIdInput!): UpdatePersonPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  updatePostById(input: UpdatePostByIdInput!): UpdatePostPayload
  updateReserved(input: UpdateReservedInput!): UpdateReservedPayload
  updateReservedById(input: UpdateReservedByIdInput!): UpdateReservedPayload
  updateReservedInputRecord(input: UpdateReservedInputRecordInput!): UpdateReservedInputRecordPayload
  updateReservedInputRecordById(input: UpdateReservedInputRecordByIdInput!): UpdateReservedInputRecordPayload
  updateReservedPatchRecord(input: UpdateReservedPatchRecordInput!): UpdateReservedPatchRecordPayload
  updateReservedPatchRecordById(input: UpdateReservedPatchRecordByIdInput!): UpdateReservedPatchRecordPayload
  updateSimilarTable1(input: UpdateSimilarTable1Input!): UpdateSimilarTable1Payload
  updateSimilarTable1ById(input: UpdateSimilarTable1ByIdInput!): UpdateSimilarTable1Payload
  updateSimilarTable2(input: UpdateSimilarTable2Input!): UpdateSimilarTable2Payload
  updateSimilarTable2ById(input: UpdateSimilarTable2ByIdInput!): UpdateSimilarTable2Payload
  updateType(input: UpdateTypeInput!): UpdateTypePayload
  updateTypeById(input: UpdateTypeByIdInput!): UpdateTypePayload
  updateViewTable(input: UpdateViewTableInput!): UpdateViewTablePayload
  updateViewTableById(input: UpdateViewTableByIdInput!): UpdateViewTablePayload
}

input MutationCompoundTypeArrayInput {
  clientMutationId: String
  object: CompoundTypeInput
}

type MutationCompoundTypeArrayPayload {
  clientMutationId: String
  compoundTypes: [CompoundType]
  query: Query
}

input MutationInInoutInput {
  clientMutationId: String
  i: Int
  ino: Int
}

type MutationInInoutPayload {
  clientMutationId: String
  ino: Int
  query: Query
}

input MutationInOutInput {
  clientMutationId: String
  i: Int
}

type MutationInOutPayload {
  clientMutationId: String
  o: Int
  query: Query
}

input MutationIntervalArrayInput {
  clientMutationId: String
}

type MutationIntervalArrayPayload {
  clientMutationId: String
  intervals: [Interval]
  query: Query
}

input MutationIntervalSetInput {
  clientMutationId: String
}

type MutationIntervalSetPayload {
  clientMutationId: String
  intervals: [Interval]
  query: Query
}

input MutationOutComplexInput {
  a: Int
  b: String
  clientMutationId: String
}

type MutationOutComplexPayload {
  clientMutationId: String
  query: Query
  result: MutationOutComplexRecord
}

type MutationOutComplexRecord {
  x: Int
  y: CompoundType
  z: Person
}

input MutationOutComplexSetofInput {
  a: Int
  b: String
  clientMutationId: String
}

type MutationOutComplexSetofPayload {
  clientMutationId: String
  query: Query
  results: [MutationOutComplexSetofRecord]
}

type MutationOutComplexSetofRecord {
  x: Int
  y: CompoundType
  z: Person
}

input MutationOutInput {
  clientMutationId: String
}

input MutationOutOutCompoundTypeInput {
  clientMutationId: String
  i1: Int
}

type MutationOutOutCompoundTypePayload {
  clientMutationId: String
  query: Query
  result: MutationOutOutCompoundTypeRecord
}

type MutationOutOutCompoundTypeRecord {
  o1: Int
  o2: CompoundType
}

input MutationOutOutInput {
  clientMutationId: String
}

type MutationOutOutPayload {
  clientMutationId: String
  query: Query
  result: MutationOutOutRecord
}

type MutationOutOutRecord {
  firstOut: Int
  secondOut: String
}

input MutationOutOutSetofInput {
  clientMutationId: String
}

type MutationOutOutSetofPayload {
  clientMutationId: String
  query: Query
  results: [MutationOutOutSetofRecord]
}

type MutationOutOutSetofRecord {
  o1: Int
  o2: String
}

input MutationOutOutUnnamedInput {
  clientMutationId: String
}

type MutationOutOutUnnamedPayload {
  clientMutationId: String
  query: Query
  result: MutationOutOutUnnamedRecord
}

type MutationOutOutUnnamedRecord {
  arg1: Int
  arg2: String
}

type MutationOutPayload {
  clientMutationId: String
  o: Int
  query: Query
}

input MutationOutSetofInput {
  clientMutationId: String
}

type MutationOutSetofPayload {
  clientMutationId: String
  os: [Int]
  query: Query
}

input MutationOutTableInput {
  clientMutationId: String
}

type MutationOutTablePayload {
  clientMutationId: String
  person: Person
  personEdge(orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]): PeopleEdge
  query: Query
}

input MutationOutTableSetofInput {
  clientMutationId: String
}

type MutationOutTableSetofPayload {
  clientMutationId: String
  people: [Person]
  query: Query
}

input MutationOutUnnamedInput {
  clientMutationId: String
}

input MutationOutUnnamedOutOutUnnamedInput {
  clientMutationId: String
}

type MutationOutUnnamedOutOutUnnamedPayload {
  clientMutationId: String
  query: Query
  result: MutationOutUnnamedOutOutUnnamedRecord
}

type MutationOutUnnamedOutOutUnnamedRecord {
  arg1: Int
  arg3: Int
  o2: String
}

type MutationOutUnnamedPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

input MutationReturnsTableMultiColInput {
  clientMutationId: String
  i: Int
}

type MutationReturnsTableMultiColPayload {
  clientMutationId: String
  query: Query
  results: [MutationReturnsTableMultiColRecord]
}

type MutationReturnsTableMultiColRecord {
  col1: Int
  col2: String
}

input MutationReturnsTableOneColInput {
  clientMutationId: String
  i: Int
}

type MutationReturnsTableOneColPayload {
  clientMutationId: String
  col1S: [Int]
  query: Query
}

input MutationTextArrayInput {
  clientMutationId: String
}

type MutationTextArrayPayload {
  clientMutationId: String
  query: Query
  strings: [String]
}

type MyTable implements Node {
  id: Int!
  jsonData: JSON
  nodeId: ID!
}

input MyTableCondition {
  id: Int
  jsonData: JSON
}

input MyTableInput {
  id: Int
  jsonData: JSON
}

input MyTablePatch {
  id: Int
  jsonData: JSON
}

type MyTablesConnection {
  edges: [MyTablesEdge]!
  nodes: [MyTable]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MyTablesEdge {
  cursor: Cursor
  node: MyTable
}

enum MyTablesOrderBy {
  ID_ASC
  ID_DESC
  JSON_DATA_ASC
  JSON_DATA_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type NestedCompoundType {
  a: CompoundType
  b: CompoundType
  bazBuz: Int
}

input NestedCompoundTypeInput {
  a: CompoundTypeInput
  b: CompoundTypeInput
  bazBuz: Int
}

input NoArgsMutationInput {
  clientMutationId: String
}

type NoArgsMutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

type NoPrimaryKey {
  id: Int!
  str: String!
}

input NoPrimaryKeyCondition {
  id: Int
  str: String
}

input NoPrimaryKeyInput {
  id: Int!
  str: String!
}

input NoPrimaryKeyPatch {
  id: Int
  str: String
}

type NoPrimaryKeysConnection {
  edges: [NoPrimaryKeysEdge]!
  nodes: [NoPrimaryKey]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NoPrimaryKeysEdge {
  cursor: Cursor
  node: NoPrimaryKey
}

enum NoPrimaryKeysOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  STR_ASC
  STR_DESC
}

interface Node {
  nodeId: ID!
}

type NonUpdatableView {
  column: Int
}

input NonUpdatableViewCondition {
  column: Int
}

type NonUpdatableViewsConnection {
  edges: [NonUpdatableViewsEdge]!
  nodes: [NonUpdatableView]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NonUpdatableViewsEdge {
  cursor: Cursor
  node: NonUpdatableView
}

enum NonUpdatableViewsOrderBy {
  COLUMN_ASC
  COLUMN_DESC
  NATURAL
}

scalar NotNullTimestamp

scalar NotNullUrl

type NullTestRecord implements Node {
  id: Int!
  nodeId: ID!
  nonNullText: String!
  nullableInt: Int
  nullableText: String
}

input NullTestRecordCondition {
  id: Int
  nonNullText: String
  nullableInt: Int
  nullableText: String
}

input NullTestRecordInput {
  id: Int
  nonNullText: String!
  nullableInt: Int
  nullableText: String
}

input NullTestRecordPatch {
  id: Int
  nonNullText: String
  nullableInt: Int
  nullableText: String
}

type NullTestRecordsConnection {
  edges: [NullTestRecordsEdge]!
  nodes: [NullTestRecord]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NullTestRecordsEdge {
  cursor: Cursor
  node: NullTestRecord
}

enum NullTestRecordsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  NON_NULL_TEXT_ASC
  NON_NULL_TEXT_DESC
  NULLABLE_INT_ASC
  NULLABLE_INT_DESC
  NULLABLE_TEXT_ASC
  NULLABLE_TEXT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type PageInfo {
  endCursor: Cursor
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: Cursor
}

type Patch implements Node {
  id: Int!
  nodeId: ID!
}

input PatchCondition {
  id: Int
}

input PatchInput {
  id: Int
}

input PatchPatch {
  id: Int
}

type PatchesConnection {
  edges: [PatchesEdge]!
  nodes: [Patch]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PatchesEdge {
  cursor: Cursor
  node: Patch
}

enum PatchesOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type PeopleConnection {
  edges: [PeopleEdge]!
  nodes: [Person]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PeopleEdge {
  cursor: Cursor
  node: Person
}

enum PeopleOrderBy {
  ABOUT_ASC
  ABOUT_DESC
  COMPUTED_OUT_ASC
  COMPUTED_OUT_DESC
  CONFIG_ASC
  CONFIG_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  EMAIL_ASC
  EMAIL_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  ID_ASC
  ID_DESC
  LAST_LOGIN_FROM_IP_ASC
  LAST_LOGIN_FROM_IP_DESC
  LAST_LOGIN_FROM_SUBNET_ASC
  LAST_LOGIN_FROM_SUBNET_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SITE_ASC
  SITE_DESC
  USER_MAC_ASC
  USER_MAC_DESC
}

type Person implements Node {
  about: String
  aliases: [String]!
  compoundKeysByPersonId1(after: Cursor, before: Cursor, condition: CompoundKeyCondition, first: Int, last: Int, offset: Int, orderBy: [CompoundKeysOrderBy!] = [PRIMARY_KEY_ASC]): CompoundKeysConnection!
  compoundKeysByPersonId2(after: Cursor, before: Cursor, condition: CompoundKeyCondition, first: Int, last: Int, offset: Int, orderBy: [CompoundKeysOrderBy!] = [PRIMARY_KEY_ASC]): CompoundKeysConnection!
  computedComplex(a: Int, b: String): PersonComputedComplexRecord
  computedFirstArgInout: Person
  computedFirstArgInoutOut: PersonComputedFirstArgInoutOutRecord
  computedInout(ino: String): String
  computedInoutOut(ino: String): PersonComputedInoutOutRecord
  computedOut: String!
  computedOutOut: PersonComputedOutOutRecord
  config: KeyValueHash
  createdAt: Datetime
  email: Email!
  firstName: String
  firstPost: Post
  foreignKeysByPersonId(after: Cursor, before: Cursor, condition: ForeignKeyCondition, first: Int, last: Int, offset: Int, orderBy: [ForeignKeysOrderBy!] = [NATURAL]): ForeignKeysConnection!
  friends(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int, orderBy: [PeopleOrderBy!]): PeopleConnection!
  id: Int!
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: String
  leftArmByPersonId: LeftArm
  name: String!
  nodeId: ID!
  optionalMissingMiddle1(arg0: Int!, b: Int, c: Int): Int
  optionalMissingMiddle2(a: Int!, b: Int, c: Int): Int
  optionalMissingMiddle3(a: Int!, arg1: Int, c: Int): Int
  optionalMissingMiddle4(arg0: Int!, arg2: Int, b: Int): Int
  optionalMissingMiddle5(a: Int!, arg1: Int, arg2: Int): Int
  postsByAuthorId(after: Cursor, before: Cursor, condition: PostCondition, first: Int, last: Int, offset: Int, orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]): PostsConnection!
  typeFunction(id: Int): Type
  typeFunctionConnection(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): TypesConnection!
  typeFunctionList: [Type]
  userMac: String
}

type PersonComputedComplexRecord {
  x: Int
  y: CompoundType
  z: Person
}

type PersonComputedFirstArgInoutOutRecord {
  o: Int
  person: Person
}

type PersonComputedInoutOutRecord {
  ino: String
  o: String
}

type PersonComputedOutOutRecord {
  o1: String
  o2: String
}

input PersonCondition {
  about: String
  aliases: [String]
  computedOut: String
  config: KeyValueHash
  createdAt: Datetime
  email: Email
  id: Int
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: String
  name: String
  site: WrappedUrlInput
  userMac: String
}

input PersonInput {
  about: String
  aliases: [String]
  config: KeyValueHash
  createdAt: Datetime
  email: Email!
  id: Int
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: String
  name: String!
  site: WrappedUrlInput
  userMac: String
}

input PersonPatch {
  about: String
  aliases: [String]
  config: KeyValueHash
  createdAt: Datetime
  email: Email
  id: Int
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: String
  name: String
  site: WrappedUrlInput
  userMac: String
}

type PersonSecret implements Node {
  nodeId: ID!
  personByPersonId: Person
  personId: Int!
  secret: String
}

input PersonSecretCondition {
  personId: Int
  secret: String
}

input PersonSecretInput {
  personId: Int!
  secret: String
}

input PersonSecretPatch {
  personId: Int
  secret: String
}

type PersonSecretsConnection {
  edges: [PersonSecretsEdge]!
  nodes: [PersonSecret]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PersonSecretsEdge {
  cursor: Cursor
  node: PersonSecret
}

enum PersonSecretsOrderBy {
  NATURAL
  PERSON_ID_ASC
  PERSON_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SECRET_ASC
  SECRET_DESC
}

type Point {
  x: Float!
  y: Float!
}

input PointInput {
  x: Float!
  y: Float!
}

type Post implements Node {
  authorId: Int
  body: String
  comptypes: [Comptype]
  computedCompoundTypeArray(object: CompoundTypeInput): [CompoundType]
  computedIntervalArray: [Interval]
  computedIntervalSet(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): PostComputedIntervalSetConnection!
  computedTextArray: [String]
  computedWithOptionalArg(i: Int): Int
  computedWithRequiredArg(i: Int!): Int
  enums: [AnEnum]
  headline: String!
  headlineTrimmed(length: Int, omission: String): String
  headlineTrimmedNoDefaults(length: Int, omission: String): String
  headlineTrimmedStrict(length: Int, omission: String): String
  id: Int!
  nodeId: ID!
  personByAuthorId: Person
  typeById: Type
  typesBySmallint(after: Cursor, before: Cursor, condition: TypeCondition, first: Int, last: Int, offset: Int, orderBy: [TypesOrderBy!] = [PRIMARY_KEY_ASC]): TypesConnection!
}

type PostComputedIntervalSetConnection {
  edges: [PostComputedIntervalSetEdge]!
  nodes: [Interval]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PostComputedIntervalSetEdge {
  cursor: Cursor
  node: Interval
}

input PostCondition {
  authorId: Int
  body: String
  comptypes: [ComptypeInput]
  computedWithOptionalArg: Int
  enums: [AnEnum]
  headline: String
  id: Int
}

input PostInput {
  authorId: Int
  body: String
  comptypes: [ComptypeInput]
  enums: [AnEnum]
  headline: String!
  id: Int
}

input PostManyInput {
  clientMutationId: String
  posts: [PostInput]
}

type PostManyPayload {
  clientMutationId: String
  posts: [Post]
  query: Query
}

input PostPatch {
  authorId: Int
  body: String
  comptypes: [ComptypeInput]
  enums: [AnEnum]
  headline: String
  id: Int
}

input PostWithSuffixInput {
  clientMutationId: String
  post: PostInput
  suffix: String
}

type PostWithSuffixPayload {
  clientMutationId: String
  personByAuthorId: Person
  post: Post
  postEdge(orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]): PostsEdge
  query: Query
}

type PostsConnection {
  edges: [PostsEdge]!
  nodes: [Post]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PostsEdge {
  cursor: Cursor
  node: Post
}

enum PostsOrderBy {
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  BODY_ASC
  BODY_DESC
  COMPUTED_WITH_OPTIONAL_ARG_ASC
  COMPUTED_WITH_OPTIONAL_ARG_DESC
  HEADLINE_ASC
  HEADLINE_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Query implements Node {
  add1Query(arg0: Int!, arg1: Int!): Int
  add2Query(a: Int!, b: Int): Int
  add3Query(a: Int, arg1: Int): Int
  add4Query(arg0: Int, b: Int): Int
  allCompoundKeys(after: Cursor, before: Cursor, condition: CompoundKeyCondition, first: Int, last: Int, offset: Int, orderBy: [CompoundKeysOrderBy!] = [PRIMARY_KEY_ASC]): CompoundKeysConnection
  allDefaultValues(after: Cursor, before: Cursor, condition: DefaultValueCondition, first: Int, last: Int, offset: Int, orderBy: [DefaultValuesOrderBy!] = [PRIMARY_KEY_ASC]): DefaultValuesConnection
  allEdgeCases(after: Cursor, before: Cursor, condition: EdgeCaseCondition, first: Int, last: Int, offset: Int, orderBy: [EdgeCasesOrderBy!] = [NATURAL]): EdgeCasesConnection
  allForeignKeys(after: Cursor, before: Cursor, condition: ForeignKeyCondition, first: Int, last: Int, offset: Int, orderBy: [ForeignKeysOrderBy!] = [NATURAL]): ForeignKeysConnection
  allInputs(after: Cursor, before: Cursor, condition: InputCondition, first: Int, last: Int, offset: Int, orderBy: [InputsOrderBy!] = [PRIMARY_KEY_ASC]): InputsConnection
  allIssue756S(after: Cursor, before: Cursor, condition: Issue756Condition, first: Int, last: Int, offset: Int, orderBy: [Issue756SOrderBy!] = [PRIMARY_KEY_ASC]): Issue756SConnection
  allLeftArms(after: Cursor, before: Cursor, condition: LeftArmCondition, first: Int, last: Int, offset: Int, orderBy: [LeftArmsOrderBy!] = [PRIMARY_KEY_ASC]): LeftArmsConnection
  allLists(after: Cursor, before: Cursor, condition: ListCondition, first: Int, last: Int, offset: Int, orderBy: [ListsOrderBy!] = [PRIMARY_KEY_ASC]): ListsConnection
  allMyTables(after: Cursor, before: Cursor, condition: MyTableCondition, first: Int, last: Int, offset: Int, orderBy: [MyTablesOrderBy!] = [PRIMARY_KEY_ASC]): MyTablesConnection
  allNoPrimaryKeys(after: Cursor, before: Cursor, condition: NoPrimaryKeyCondition, first: Int, last: Int, offset: Int, orderBy: [NoPrimaryKeysOrderBy!] = [NATURAL]): NoPrimaryKeysConnection
  allNonUpdatableViews(after: Cursor, before: Cursor, condition: NonUpdatableViewCondition, first: Int, last: Int, offset: Int, orderBy: [NonUpdatableViewsOrderBy!] = [NATURAL]): NonUpdatableViewsConnection
  allNullTestRecords(after: Cursor, before: Cursor, condition: NullTestRecordCondition, first: Int, last: Int, offset: Int, orderBy: [NullTestRecordsOrderBy!] = [PRIMARY_KEY_ASC]): NullTestRecordsConnection
  allPatches(after: Cursor, before: Cursor, condition: PatchCondition, first: Int, last: Int, offset: Int, orderBy: [PatchesOrderBy!] = [PRIMARY_KEY_ASC]): PatchesConnection
  allPeople(after: Cursor, before: Cursor, condition: PersonCondition, first: Int, last: Int, offset: Int, orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]): PeopleConnection
  allPosts(after: Cursor, before: Cursor, condition: PostCondition, first: Int, last: Int, offset: Int, orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]): PostsConnection
  allReservedInputRecords(after: Cursor, before: Cursor, condition: ReservedInputRecordCondition, first: Int, last: Int, offset: Int, orderBy: [ReservedInputRecordsOrderBy!] = [PRIMARY_KEY_ASC]): ReservedInputRecordsConnection
  allReservedPatchRecords(after: Cursor, before: Cursor, condition: ReservedPatchRecordCondition, first: Int, last: Int, offset: Int, orderBy: [ReservedPatchRecordsOrderBy!] = [PRIMARY_KEY_ASC]): ReservedPatchRecordsConnection
  allReserveds(after: Cursor, before: Cursor, condition: ReservedCondition, first: Int, last: Int, offset: Int, orderBy: [ReservedsOrderBy!] = [PRIMARY_KEY_ASC]): ReservedsConnection
  allSimilarTable1S(after: Cursor, before: Cursor, condition: SimilarTable1Condition, first: Int, last: Int, offset: Int, orderBy: [SimilarTable1SOrderBy!] = [PRIMARY_KEY_ASC]): SimilarTable1SConnection
  allSimilarTable2S(after: Cursor, before: Cursor, condition: SimilarTable2Condition, first: Int, last: Int, offset: Int, orderBy: [SimilarTable2SOrderBy!] = [PRIMARY_KEY_ASC]): SimilarTable2SConnection
  allTestviews(after: Cursor, before: Cursor, condition: TestviewCondition, first: Int, last: Int, offset: Int, orderBy: [TestviewsOrderBy!] = [NATURAL]): TestviewsConnection
  allTypes(after: Cursor, before: Cursor, condition: TypeCondition, first: Int, last: Int, offset: Int, orderBy: [TypesOrderBy!] = [PRIMARY_KEY_ASC]): TypesConnection
  allUpdatableViews(after: Cursor, before: Cursor, condition: UpdatableViewCondition, first: Int, last: Int, offset: Int, orderBy: [UpdatableViewsOrderBy!] = [NATURAL]): UpdatableViewsConnection
  allViewTables(after: Cursor, before: Cursor, condition: ViewTableCondition, first: Int, last: Int, offset: Int, orderBy: [ViewTablesOrderBy!] = [PRIMARY_KEY_ASC]): ViewTablesConnection
  compoundKey(nodeId: ID!): CompoundKey
  compoundKeyByPersonId1AndPersonId2(personId1: Int!, personId2: Int!): CompoundKey
  compoundTypeArrayQuery(object: CompoundTypeInput): [CompoundType]
  compoundTypeQuery(object: CompoundTypeInput): CompoundType
  compoundTypeSetQuery(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): CompoundTypesConnection
  currentUserId: Int
  defaultValue(nodeId: ID!): DefaultValue
  defaultValueById(id: Int!): DefaultValue
  funcInInout(i: Int, ino: Int): Int
  funcInOut(i: Int): Int
  funcOut: Int
  funcOutComplex(a: Int, b: String): FuncOutComplexRecord
  funcOutComplexSetof(a: Int, after: Cursor, b: String, before: Cursor, first: Int, last: Int, offset: Int): FuncOutComplexSetofConnection
  funcOutOut: FuncOutOutRecord
  funcOutOutCompoundType(i1: Int): FuncOutOutCompoundTypeRecord
  funcOutOutSetof(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): FuncOutOutSetofConnection
  funcOutOutUnnamed: FuncOutOutUnnamedRecord
  funcOutSetof(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): FuncOutSetofConnection
  funcOutTable: Person
  funcOutTableSetof(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): PeopleConnection
  funcOutUnnamed: Int
  funcOutUnnamedOutOutUnnamed: FuncOutUnnamedOutOutUnnamedRecord
  funcReturnsTableMultiCol(a: Int, after: Cursor, b: Int, before: Cursor, first: Int, i: Int, last: Int, offset: Int): FuncReturnsTableMultiColConnection
  funcReturnsTableOneCol(after: Cursor, before: Cursor, first: Int, i: Int, last: Int, offset: Int): FuncReturnsTableOneColConnection
  input(nodeId: ID!): Input
  inputById(id: Int!): Input
  intSetQuery(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int, x: Int, y: Int, z: Int): IntSetQueryConnection
  issue756(nodeId: ID!): Issue756
  issue756ById(id: Int!): Issue756
  jsonIdentity(json: JSON): JSON
  jsonbIdentity(json: JSON): JSON
  leftArm(nodeId: ID!): LeftArm
  leftArmById(id: Int!): LeftArm
  leftArmByPersonId(personId: Int!): LeftArm
  list(nodeId: ID!): List
  listById(id: Int!): List
  myTable(nodeId: ID!): MyTable
  myTableById(id: Int!): MyTable
  noArgsQuery: Int
  noPrimaryKeyById(id: Int!): NoPrimaryKey
  node(nodeId: ID!): Node
  nodeId: ID!
  nullTestRecord(nodeId: ID!): NullTestRecord
  nullTestRecordById(id: Int!): NullTestRecord
  optionalMissingMiddle1(arg0: Int!, b: Int, c: Int): Int
  optionalMissingMiddle2(a: Int!, b: Int, c: Int): Int
  optionalMissingMiddle3(a: Int!, arg1: Int, c: Int): Int
  optionalMissingMiddle4(arg0: Int!, arg2: Int, b: Int): Int
  optionalMissingMiddle5(a: Int!, arg1: Int, arg2: Int): Int
  patch(nodeId: ID!): Patch
  patchById(id: Int!): Patch
  person(nodeId: ID!): Person
  personByEmail(email: Email!): Person
  personById(id: Int!): Person
  post(nodeId: ID!): Post
  postById(id: Int!): Post
  query: Query!
  queryCompoundTypeArray(object: CompoundTypeInput): [CompoundType]
  queryIntervalArray: [Interval]
  queryIntervalSet(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): QueryIntervalSetConnection
  queryOutputTwoRows(leftArmId: Int, postId: Int, txt: String): QueryOutputTwoRowsRecord
  queryTextArray: [String]
  reserved(nodeId: ID!): Reserved
  reservedById(id: Int!): Reserved
  reservedInputRecord(nodeId: ID!): ReservedInputRecord
  reservedInputRecordById(id: Int!): ReservedInputRecord
  reservedPatchRecord(nodeId: ID!): ReservedPatchRecord
  reservedPatchRecordById(id: Int!): ReservedPatchRecord
  returnTableWithoutGrants: CompoundKey
  searchTestSummariesList(first: Int, offset: Int): [SearchTestSummariesRecord]
  similarTable1(nodeId: ID!): SimilarTable1
  similarTable1ById(id: Int!): SimilarTable1
  similarTable2(nodeId: ID!): SimilarTable2
  similarTable2ById(id: Int!): SimilarTable2
  staticBigInteger(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): StaticBigIntegerConnection
  tableQuery(id: Int): Post
  tableSetQuery(after: Cursor, before: Cursor, condition: PersonCondition, first: Int, last: Int, offset: Int, orderBy: [PeopleOrderBy!]): PeopleConnection
  tableSetQueryPlpgsql(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): PeopleConnection
  type(nodeId: ID!): Type
  typeById(id: Int!): Type
  typeFunction(id: Int): Type
  typeFunctionConnection(after: Cursor, before: Cursor, first: Int, last: Int, offset: Int): TypesConnection
  typeFunctionList: [Type]
  typesQuery(a: BigInt!, b: Boolean!, c: String!, d: [Int]!, e: JSON!, f: FloatRangeInput!): Boolean
  uniqueForeignKeyByCompoundKey1AndCompoundKey2(compoundKey1: Int!, compoundKey2: Int!): UniqueForeignKey
  viewTable(nodeId: ID!): ViewTable
  viewTableById(id: Int!): ViewTable
}

type QueryIntervalSetConnection {
  edges: [QueryIntervalSetEdge]!
  nodes: [Interval]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type QueryIntervalSetEdge {
  cursor: Cursor
  node: Interval
}

type QueryOutputTwoRowsRecord {
  leftArm: LeftArm
  post: Post
  txt: String
}

scalar RegClass

scalar RegConfig

scalar RegDictionary

scalar RegOper

scalar RegOperator

scalar RegProc

scalar RegProcedure

scalar RegType

type Reserved implements Node {
  id: Int!
  nodeId: ID!
}

input ReservedCondition {
  id: Int
}

input ReservedInput {
  id: Int
}

type ReservedInputRecord implements Node {
  id: Int!
  nodeId: ID!
}

input ReservedInputRecordCondition {
  id: Int
}

input ReservedInputRecordInput {
  id: Int
}

input ReservedInputRecordPatch {
  id: Int
}

type ReservedInputRecordsConnection {
  edges: [ReservedInputRecordsEdge]!
  nodes: [ReservedInputRecord]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReservedInputRecordsEdge {
  cursor: Cursor
  node: ReservedInputRecord
}

enum ReservedInputRecordsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

input ReservedPatch {
  id: Int
}

type ReservedPatchRecord implements Node {
  id: Int!
  nodeId: ID!
}

input ReservedPatchRecordCondition {
  id: Int
}

input ReservedPatchRecordInput {
  id: Int
}

input ReservedPatchRecordPatch {
  id: Int
}

type ReservedPatchRecordsConnection {
  edges: [ReservedPatchRecordsEdge]!
  nodes: [ReservedPatchRecord]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReservedPatchRecordsEdge {
  cursor: Cursor
  node: ReservedPatchRecord
}

enum ReservedPatchRecordsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type ReservedsConnection {
  edges: [ReservedsEdge]!
  nodes: [Reserved]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReservedsEdge {
  cursor: Cursor
  node: Reserved
}

enum ReservedsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

input ReturnVoidMutationInput {
  clientMutationId: String
}

type ReturnVoidMutationPayload {
  clientMutationId: String
  query: Query
}

type SearchTestSummariesRecord {
  id: Int
  totalDuration: Interval
}

type SimilarTable1 implements Node {
  col1: Int
  col2: Int
  col3: Int!
  id: Int!
  nodeId: ID!
}

input SimilarTable1Condition {
  col1: Int
  col2: Int
  col3: Int
  id: Int
}

input SimilarTable1Input {
  col1: Int
  col2: Int
  col3: Int!
  id: Int
}

input SimilarTable1Patch {
  col1: Int
  col2: Int
  col3: Int
  id: Int
}

type SimilarTable1SConnection {
  edges: [SimilarTable1SEdge]!
  nodes: [SimilarTable1]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SimilarTable1SEdge {
  cursor: Cursor
  node: SimilarTable1
}

enum SimilarTable1SOrderBy {
  COL1_ASC
  COL1_DESC
  COL2_ASC
  COL2_DESC
  COL3_ASC
  COL3_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type SimilarTable2 implements Node {
  col3: Int!
  col4: Int
  col5: Int
  id: Int!
  nodeId: ID!
}

input SimilarTable2Condition {
  col3: Int
  col4: Int
  col5: Int
  id: Int
}

input SimilarTable2Input {
  col3: Int!
  col4: Int
  col5: Int
  id: Int
}

input SimilarTable2Patch {
  col3: Int
  col4: Int
  col5: Int
  id: Int
}

type SimilarTable2SConnection {
  edges: [SimilarTable2SEdge]!
  nodes: [SimilarTable2]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SimilarTable2SEdge {
  cursor: Cursor
  node: SimilarTable2
}

enum SimilarTable2SOrderBy {
  COL3_ASC
  COL3_DESC
  COL4_ASC
  COL4_DESC
  COL5_ASC
  COL5_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type StaticBigIntegerConnection {
  edges: [StaticBigIntegerEdge]!
  nodes: [BigInt]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type StaticBigIntegerEdge {
  cursor: Cursor
  node: BigInt
}

input TableMutationInput {
  clientMutationId: String
  id: Int
}

type TableMutationPayload {
  clientMutationId: String
  personByAuthorId: Person
  post: Post
  postEdge(orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]): PostsEdge
  query: Query
}

input TableSetMutationInput {
  clientMutationId: String
}

type TableSetMutationPayload {
  clientMutationId: String
  people: [Person]
  query: Query
}

type Testview {
  col1: Int
  col2: Int
  testviewid: Int
}

input TestviewCondition {
  col1: Int
  col2: Int
  testviewid: Int
}

input TestviewInput {
  col1: Int
  col2: Int
  testviewid: Int
}

type TestviewsConnection {
  edges: [TestviewsEdge]!
  nodes: [Testview]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TestviewsEdge {
  cursor: Cursor
  node: Testview
}

enum TestviewsOrderBy {
  COL1_ASC
  COL1_DESC
  COL2_ASC
  COL2_DESC
  NATURAL
  TESTVIEWID_ASC
  TESTVIEWID_DESC
}

scalar Time

type Type implements Node {
  anIntRange: AnIntRange!
  bigint: BigInt!
  boolean: Boolean!
  bytea: Base64EncodedBinary
  byteaArray: [Base64EncodedBinary]
  cidr: String
  compoundType: CompoundType!
  date: Date!
  daterange: DateRange!
  decimal: BigFloat!
  domain: AnInt!
  domain2: AnotherInt!
  enum: Color!
  enumArray: [Color]!
  id: Int!
  inet: InternetAddress
  int8ArrayDomain: [BigInt]
  interval: Interval!
  intervalArray: [Interval]!
  json: JSON!
  jsonb: JSON!
  jsonpath: JSONPath
  ltree: LTree
  ltreeArray: [LTree]
  macaddr: String
  money: Float!
  nestedCompoundType: NestedCompoundType!
  nodeId: ID!
  nullableCompoundType: CompoundType
  nullableNestedCompoundType: NestedCompoundType
  nullablePoint: Point
  nullableRange: BigFloatRange
  numeric: BigFloat!
  numrange: BigFloatRange!
  point: Point!
  postById: Post
  postBySmallint: Post
  regclass: RegClass
  regconfig: RegConfig
  regdictionary: RegDictionary
  regoper: RegOper
  regoperator: RegOperator
  regproc: RegProc
  regprocedure: RegProcedure
  regtype: RegType
  smallint: Int!
  textArray: [String]!
  textArrayDomain: [String]
  time: Time!
  timestamp: Datetime!
  timestamptz: Datetime!
  timetz: Time!
  varchar: String!
}

input TypeCondition {
  anIntRange: AnIntRangeInput
  bigint: BigInt
  boolean: Boolean
  cidr: String
  compoundType: CompoundTypeInput
  date: Date
  daterange: DateRangeInput
  decimal: BigFloat
  domain: AnInt
  domain2: AnotherInt
  enum: Color
  enumArray: [Color]
  id: Int
  inet: InternetAddress
  int8ArrayDomain: [BigInt]
  interval: IntervalInput
  intervalArray: [IntervalInput]
  json: JSON
  jsonb: JSON
  jsonpath: JSONPath
  ltree: LTree
  ltreeArray: [LTree]
  macaddr: String
  money: Float
  nestedCompoundType: NestedCompoundTypeInput
  nullableCompoundType: CompoundTypeInput
  nullableNestedCompoundType: NestedCompoundTypeInput
  nullablePoint: PointInput
  nullableRange: BigFloatRangeInput
  numeric: BigFloat
  numrange: BigFloatRangeInput
  point: PointInput
  regclass: RegClass
  regconfig: RegConfig
  regdictionary: RegDictionary
  regoper: RegOper
  regoperator: RegOperator
  regproc: RegProc
  regprocedure: RegProcedure
  regtype: RegType
  smallint: Int
  textArray: [String]
  textArrayDomain: [String]
  time: Time
  timestamp: Datetime
  timestamptz: Datetime
  timetz: Time
  varchar: String
}

input TypeFunctionConnectionMutationInput {
  clientMutationId: String
}

type TypeFunctionConnectionMutationPayload {
  clientMutationId: String
  query: Query
  types: [Type]
}

input TypeFunctionListMutationInput {
  clientMutationId: String
}

type TypeFunctionListMutationPayload {
  clientMutationId: String
  query: Query
  types: [Type]
}

input TypeFunctionMutationInput {
  clientMutationId: String
  id: Int
}

type TypeFunctionMutationPayload {
  clientMutationId: String
  postById: Post
  postBySmallint: Post
  query: Query
  type: Type
  typeEdge(orderBy: [TypesOrderBy!]! = [PRIMARY_KEY_ASC]): TypesEdge
}

input TypeInput {
  anIntRange: AnIntRangeInput!
  bigint: BigInt!
  boolean: Boolean!
  bytea: Base64EncodedBinary
  byteaArray: [Base64EncodedBinary]
  cidr: String
  compoundType: CompoundTypeInput!
  date: Date!
  daterange: DateRangeInput!
  decimal: BigFloat!
  domain: AnInt!
  domain2: AnotherInt!
  enum: Color!
  enumArray: [Color]!
  id: Int
  inet: InternetAddress
  int8ArrayDomain: [BigInt]
  interval: IntervalInput!
  intervalArray: [IntervalInput]!
  json: JSON!
  jsonb: JSON!
  jsonpath: JSONPath
  ltree: LTree
  ltreeArray: [LTree]
  macaddr: String
  money: Float!
  nestedCompoundType: NestedCompoundTypeInput!
  nullableCompoundType: CompoundTypeInput
  nullableNestedCompoundType: NestedCompoundTypeInput
  nullablePoint: PointInput
  nullableRange: BigFloatRangeInput
  numeric: BigFloat!
  numrange: BigFloatRangeInput!
  point: PointInput!
  regclass: RegClass
  regconfig: RegConfig
  regdictionary: RegDictionary
  regoper: RegOper
  regoperator: RegOperator
  regproc: RegProc
  regprocedure: RegProcedure
  regtype: RegType
  smallint: Int!
  textArray: [String]!
  textArrayDomain: [String]
  time: Time!
  timestamp: Datetime!
  timestamptz: Datetime!
  timetz: Time!
  varchar: String!
}

input TypePatch {
  anIntRange: AnIntRangeInput
  bigint: BigInt
  boolean: Boolean
  bytea: Base64EncodedBinary
  byteaArray: [Base64EncodedBinary]
  cidr: String
  compoundType: CompoundTypeInput
  date: Date
  daterange: DateRangeInput
  decimal: BigFloat
  domain: AnInt
  domain2: AnotherInt
  enum: Color
  enumArray: [Color]
  id: Int
  inet: InternetAddress
  int8ArrayDomain: [BigInt]
  interval: IntervalInput
  intervalArray: [IntervalInput]
  json: JSON
  jsonb: JSON
  jsonpath: JSONPath
  ltree: LTree
  ltreeArray: [LTree]
  macaddr: String
  money: Float
  nestedCompoundType: NestedCompoundTypeInput
  nullableCompoundType: CompoundTypeInput
  nullableNestedCompoundType: NestedCompoundTypeInput
  nullablePoint: PointInput
  nullableRange: BigFloatRangeInput
  numeric: BigFloat
  numrange: BigFloatRangeInput
  point: PointInput
  regclass: RegClass
  regconfig: RegConfig
  regdictionary: RegDictionary
  regoper: RegOper
  regoperator: RegOperator
  regproc: RegProc
  regprocedure: RegProcedure
  regtype: RegType
  smallint: Int
  textArray: [String]
  textArrayDomain: [String]
  time: Time
  timestamp: Datetime
  timestamptz: Datetime
  timetz: Time
  varchar: String
}

type TypesConnection {
  edges: [TypesEdge]!
  nodes: [Type]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TypesEdge {
  cursor: Cursor
  node: Type
}

input TypesMutationInput {
  a: BigInt!
  b: Boolean!
  c: String!
  clientMutationId: String
  d: [Int]!
  e: JSON!
  f: FloatRangeInput!
}

type TypesMutationPayload {
  boolean: Boolean
  clientMutationId: String
  query: Query
}

enum TypesOrderBy {
  BIGINT_ASC
  BIGINT_DESC
  BOOLEAN_ASC
  BOOLEAN_DESC
  CIDR_ASC
  CIDR_DESC
  COMPOUND_TYPE_ASC
  COMPOUND_TYPE_DESC
  DATE_ASC
  DATE_DESC
  DECIMAL_ASC
  DECIMAL_DESC
  DOMAIN2_ASC
  DOMAIN2_DESC
  DOMAIN_ASC
  DOMAIN_DESC
  ENUM_ASC
  ENUM_DESC
  ID_ASC
  ID_DESC
  INET_ASC
  INET_DESC
  INTERVAL_ASC
  INTERVAL_DESC
  JSONB_ASC
  JSONB_DESC
  JSONPATH_ASC
  JSONPATH_DESC
  JSON_ASC
  JSON_DESC
  LTREE_ASC
  LTREE_DESC
  MACADDR_ASC
  MACADDR_DESC
  MONEY_ASC
  MONEY_DESC
  NATURAL
  NESTED_COMPOUND_TYPE_ASC
  NESTED_COMPOUND_TYPE_DESC
  NULLABLE_COMPOUND_TYPE_ASC
  NULLABLE_COMPOUND_TYPE_DESC
  NULLABLE_NESTED_COMPOUND_TYPE_ASC
  NULLABLE_NESTED_COMPOUND_TYPE_DESC
  NULLABLE_POINT_ASC
  NULLABLE_POINT_DESC
  NUMERIC_ASC
  NUMERIC_DESC
  POINT_ASC
  POINT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  REGCLASS_ASC
  REGCLASS_DESC
  REGCONFIG_ASC
  REGCONFIG_DESC
  REGDICTIONARY_ASC
  REGDICTIONARY_DESC
  REGOPERATOR_ASC
  REGOPERATOR_DESC
  REGOPER_ASC
  REGOPER_DESC
  REGPROCEDURE_ASC
  REGPROCEDURE_DESC
  REGPROC_ASC
  REGPROC_DESC
  REGTYPE_ASC
  REGTYPE_DESC
  SMALLINT_ASC
  SMALLINT_DESC
  TIMESTAMPTZ_ASC
  TIMESTAMPTZ_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  TIMETZ_ASC
  TIMETZ_DESC
  TIME_ASC
  TIME_DESC
  VARCHAR_ASC
  VARCHAR_DESC
}

scalar UUID

type UniqueForeignKey {
  compoundKey1: Int
  compoundKey2: Int
  compoundKeyByCompoundKey1AndCompoundKey2: CompoundKey
}

type UpdatableView {
  constant: Int
  description: String
  name: String
  x: Int
}

input UpdatableViewCondition {
  constant: Int
  description: String
  name: String
  x: Int
}

input UpdatableViewInput {
  constant: Int
  description: String
  name: String
  x: Int
}

type UpdatableViewsConnection {
  edges: [UpdatableViewsEdge]!
  nodes: [UpdatableView]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UpdatableViewsEdge {
  cursor: Cursor
  node: UpdatableView
}

enum UpdatableViewsOrderBy {
  CONSTANT_ASC
  CONSTANT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  X_ASC
  X_DESC
}

input UpdateCompoundKeyByPersonId1AndPersonId2Input {
  clientMutationId: String
  compoundKeyPatch: CompoundKeyPatch!
  personId1: Int!
  personId2: Int!
}

input UpdateCompoundKeyInput {
  clientMutationId: String
  compoundKeyPatch: CompoundKeyPatch!
  nodeId: ID!
}

type UpdateCompoundKeyPayload {
  clientMutationId: String
  compoundKey: CompoundKey
  compoundKeyEdge(orderBy: [CompoundKeysOrderBy!]! = [PRIMARY_KEY_ASC]): CompoundKeysEdge
  personByPersonId1: Person
  personByPersonId2: Person
  query: Query
}

input UpdateDefaultValueByIdInput {
  clientMutationId: String
  defaultValuePatch: DefaultValuePatch!
  id: Int!
}

input UpdateDefaultValueInput {
  clientMutationId: String
  defaultValuePatch: DefaultValuePatch!
  nodeId: ID!
}

type UpdateDefaultValuePayload {
  clientMutationId: String
  defaultValue: DefaultValue
  defaultValueEdge(orderBy: [DefaultValuesOrderBy!]! = [PRIMARY_KEY_ASC]): DefaultValuesEdge
  query: Query
}

input UpdateInputByIdInput {
  clientMutationId: String
  id: Int!
  inputPatch: InputPatch!
}

input UpdateInputInput {
  clientMutationId: String
  inputPatch: InputPatch!
  nodeId: ID!
}

type UpdateInputPayload {
  clientMutationId: String
  input: Input
  inputEdge(orderBy: [InputsOrderBy!]! = [PRIMARY_KEY_ASC]): InputsEdge
  query: Query
}

input UpdateIssue756ByIdInput {
  clientMutationId: String
  id: Int!
  issue756Patch: Issue756Patch!
}

input UpdateIssue756Input {
  clientMutationId: String
  issue756Patch: Issue756Patch!
  nodeId: ID!
}

type UpdateIssue756Payload {
  clientMutationId: String
  issue756: Issue756
  issue756Edge(orderBy: [Issue756SOrderBy!]! = [PRIMARY_KEY_ASC]): Issue756SEdge
  query: Query
}

input UpdateLeftArmByIdInput {
  clientMutationId: String
  id: Int!
  leftArmPatch: LeftArmPatch!
}

input UpdateLeftArmByPersonIdInput {
  clientMutationId: String
  leftArmPatch: LeftArmPatch!
  personId: Int!
}

input UpdateLeftArmInput {
  clientMutationId: String
  leftArmPatch: LeftArmPatch!
  nodeId: ID!
}

type UpdateLeftArmPayload {
  clientMutationId: String
  leftArm: LeftArm
  leftArmEdge(orderBy: [LeftArmsOrderBy!]! = [PRIMARY_KEY_ASC]): LeftArmsEdge
  personByPersonId: Person
  query: Query
}

input UpdateListByIdInput {
  clientMutationId: String
  id: Int!
  listPatch: ListPatch!
}

input UpdateListInput {
  clientMutationId: String
  listPatch: ListPatch!
  nodeId: ID!
}

type UpdateListPayload {
  clientMutationId: String
  list: List
  listEdge(orderBy: [ListsOrderBy!]! = [PRIMARY_KEY_ASC]): ListsEdge
  query: Query
}

input UpdateMyTableByIdInput {
  clientMutationId: String
  id: Int!
  myTablePatch: MyTablePatch!
}

input UpdateMyTableInput {
  clientMutationId: String
  myTablePatch: MyTablePatch!
  nodeId: ID!
}

type UpdateMyTablePayload {
  clientMutationId: String
  myTable: MyTable
  myTableEdge(orderBy: [MyTablesOrderBy!]! = [PRIMARY_KEY_ASC]): MyTablesEdge
  query: Query
}

input UpdateNoPrimaryKeyByIdInput {
  clientMutationId: String
  id: Int!
  noPrimaryKeyPatch: NoPrimaryKeyPatch!
}

type UpdateNoPrimaryKeyPayload {
  clientMutationId: String
  noPrimaryKey: NoPrimaryKey
  query: Query
}

input UpdateNullTestRecordByIdInput {
  clientMutationId: String
  id: Int!
  nullTestRecordPatch: NullTestRecordPatch!
}

input UpdateNullTestRecordInput {
  clientMutationId: String
  nodeId: ID!
  nullTestRecordPatch: NullTestRecordPatch!
}

type UpdateNullTestRecordPayload {
  clientMutationId: String
  nullTestRecord: NullTestRecord
  nullTestRecordEdge(orderBy: [NullTestRecordsOrderBy!]! = [PRIMARY_KEY_ASC]): NullTestRecordsEdge
  query: Query
}

input UpdatePatchByIdInput {
  clientMutationId: String
  id: Int!
  patchPatch: PatchPatch!
}

input UpdatePatchInput {
  clientMutationId: String
  nodeId: ID!
  patchPatch: PatchPatch!
}

type UpdatePatchPayload {
  clientMutationId: String
  patch: Patch
  patchEdge(orderBy: [PatchesOrderBy!]! = [PRIMARY_KEY_ASC]): PatchesEdge
  query: Query
}

input UpdatePersonByEmailInput {
  clientMutationId: String
  email: Email!
  personPatch: PersonPatch!
}

input UpdatePersonByIdInput {
  clientMutationId: String
  id: Int!
  personPatch: PersonPatch!
}

input UpdatePersonInput {
  clientMutationId: String
  nodeId: ID!
  personPatch: PersonPatch!
}

type UpdatePersonPayload {
  clientMutationId: String
  person: Person
  personEdge(orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]): PeopleEdge
  query: Query
}

input UpdatePersonSecretByPersonIdInput {
  clientMutationId: String
  personId: Int!
  personSecretPatch: PersonSecretPatch!
}

input UpdatePersonSecretInput {
  clientMutationId: String
  nodeId: ID!
  personSecretPatch: PersonSecretPatch!
}

type UpdatePersonSecretPayload {
  clientMutationId: String
  personByPersonId: Person
  personSecret: PersonSecret
  query: Query
}

input UpdatePostByIdInput {
  clientMutationId: String
  id: Int!
  postPatch: PostPatch!
}

input UpdatePostInput {
  clientMutationId: String
  nodeId: ID!
  postPatch: PostPatch!
}

type UpdatePostPayload {
  clientMutationId: String
  personByAuthorId: Person
  post: Post
  postEdge(orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]): PostsEdge
  query: Query
}

input UpdateReservedByIdInput {
  clientMutationId: String
  id: Int!
  reservedPatch: ReservedPatch!
}

input UpdateReservedInput {
  clientMutationId: String
  nodeId: ID!
  reservedPatch: ReservedPatch!
}

input UpdateReservedInputRecordByIdInput {
  clientMutationId: String
  id: Int!
  reservedInputRecordPatch: ReservedInputRecordPatch!
}

input UpdateReservedInputRecordInput {
  clientMutationId: String
  nodeId: ID!
  reservedInputRecordPatch: ReservedInputRecordPatch!
}

type UpdateReservedInputRecordPayload {
  clientMutationId: String
  query: Query
  reservedInputRecord: ReservedInputRecord
  reservedInputRecordEdge(orderBy: [ReservedInputRecordsOrderBy!]! = [PRIMARY_KEY_ASC]): ReservedInputRecordsEdge
}

input UpdateReservedPatchRecordByIdInput {
  clientMutationId: String
  id: Int!
  reservedPatchRecordPatch: ReservedPatchRecordPatch!
}

input UpdateReservedPatchRecordInput {
  clientMutationId: String
  nodeId: ID!
  reservedPatchRecordPatch: ReservedPatchRecordPatch!
}

type UpdateReservedPatchRecordPayload {
  clientMutationId: String
  query: Query
  reservedPatchRecord: ReservedPatchRecord
  reservedPatchRecordEdge(orderBy: [ReservedPatchRecordsOrderBy!]! = [PRIMARY_KEY_ASC]): ReservedPatchRecordsEdge
}

type UpdateReservedPayload {
  clientMutationId: String
  query: Query
  reserved: Reserved
  reservedEdge(orderBy: [ReservedsOrderBy!]! = [PRIMARY_KEY_ASC]): ReservedsEdge
}

input UpdateSimilarTable1ByIdInput {
  clientMutationId: String
  id: Int!
  similarTable1Patch: SimilarTable1Patch!
}

input UpdateSimilarTable1Input {
  clientMutationId: String
  nodeId: ID!
  similarTable1Patch: SimilarTable1Patch!
}

type UpdateSimilarTable1Payload {
  clientMutationId: String
  query: Query
  similarTable1: SimilarTable1
  similarTable1Edge(orderBy: [SimilarTable1SOrderBy!]! = [PRIMARY_KEY_ASC]): SimilarTable1SEdge
}

input UpdateSimilarTable2ByIdInput {
  clientMutationId: String
  id: Int!
  similarTable2Patch: SimilarTable2Patch!
}

input UpdateSimilarTable2Input {
  clientMutationId: String
  nodeId: ID!
  similarTable2Patch: SimilarTable2Patch!
}

type UpdateSimilarTable2Payload {
  clientMutationId: String
  query: Query
  similarTable2: SimilarTable2
  similarTable2Edge(orderBy: [SimilarTable2SOrderBy!]! = [PRIMARY_KEY_ASC]): SimilarTable2SEdge
}

input UpdateTypeByIdInput {
  clientMutationId: String
  id: Int!
  typePatch: TypePatch!
}

input UpdateTypeInput {
  clientMutationId: String
  nodeId: ID!
  typePatch: TypePatch!
}

type UpdateTypePayload {
  clientMutationId: String
  postById: Post
  postBySmallint: Post
  query: Query
  type: Type
  typeEdge(orderBy: [TypesOrderBy!]! = [PRIMARY_KEY_ASC]): TypesEdge
}

input UpdateViewTableByIdInput {
  clientMutationId: String
  id: Int!
  viewTablePatch: ViewTablePatch!
}

input UpdateViewTableInput {
  clientMutationId: String
  nodeId: ID!
  viewTablePatch: ViewTablePatch!
}

type UpdateViewTablePayload {
  clientMutationId: String
  query: Query
  viewTable: ViewTable
  viewTableEdge(orderBy: [ViewTablesOrderBy!]! = [PRIMARY_KEY_ASC]): ViewTablesEdge
}

type ViewTable implements Node {
  col1: Int
  col2: Int
  id: Int!
  nodeId: ID!
}

input ViewTableCondition {
  col1: Int
  col2: Int
  id: Int
}

input ViewTableInput {
  col1: Int
  col2: Int
  id: Int
}

input ViewTablePatch {
  col1: Int
  col2: Int
  id: Int
}

type ViewTablesConnection {
  edges: [ViewTablesEdge]!
  nodes: [ViewTable]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ViewTablesEdge {
  cursor: Cursor
  node: ViewTable
}

enum ViewTablesOrderBy {
  COL1_ASC
  COL1_DESC
  COL2_ASC
  COL2_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type WrappedUrl {
  url: NotNullUrl!
}

input WrappedUrlInput {
  url: NotNullUrl!
}
