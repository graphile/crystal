import { PgDeleteSingleStep, PgExecutor, PgResource, PgSelectStep, PgUnionAllStep, TYPES, assertPgClassSingleStep, enumCodec, makeRegistry, pgDeleteSingle, pgInsertSingle, pgSelectFromRecord, pgUnionAll, pgUpdateSingle, recordCodec, sqlFromArgDigests } from "@dataplan/pg";
import { ConnectionStep, EdgeStep, ObjectStep, SafeError, __ValueStep, access, assertEdgeCapableStep, assertExecutableStep, assertPageInfoCapableStep, connection, constant, context, first, getEnumValueConfig, lambda, list, makeDecodeNodeId, makeGrafastSchema, node, object, rootValue, specFromNodeId } from "grafast";
import { sql } from "pg-sql2";
import { inspect } from "util";
const executor_mainPgExecutor = new PgExecutor({
  name: "main",
  context() {
    const ctx = context();
    return object({
      pgSettings: "pgSettings" != null ? ctx.get("pgSettings") : constant(null),
      withPgClient: ctx.get("withPgClient")
    });
  }
});
const extensions = {
  oid: "1377058",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "aws_application_first_party_vulnerabilities"
  },
  tags: Object.assign(Object.create(null), {
    omit: true,
    behavior: ["-*"]
  })
};
const spec_awsApplicationFirstPartyVulnerabilities = {
  name: "awsApplicationFirstPartyVulnerabilities",
  identifier: sql.identifier(...["polymorphic", "aws_application_first_party_vulnerabilities"]),
  attributes: Object.assign(Object.create(null), {
    aws_application_id: {
      description: undefined,
      codec: TYPES.int,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {}
      }
    },
    first_party_vulnerability_id: {
      description: undefined,
      codec: TYPES.int,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {}
      }
    }
  }),
  description: undefined,
  extensions,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_awsApplicationFirstPartyVulnerabilities_awsApplicationFirstPartyVulnerabilities = recordCodec(spec_awsApplicationFirstPartyVulnerabilities);
const attributes2 = Object.assign(Object.create(null), {
  aws_application_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  third_party_vulnerability_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions2 = {
  oid: "1377073",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "aws_application_third_party_vulnerabilities"
  },
  tags: Object.assign(Object.create(null), {
    omit: true,
    behavior: ["-*"]
  })
};
const parts2 = ["polymorphic", "aws_application_third_party_vulnerabilities"];
const sqlIdent2 = sql.identifier(...parts2);
const spec_awsApplicationThirdPartyVulnerabilities = {
  name: "awsApplicationThirdPartyVulnerabilities",
  identifier: sqlIdent2,
  attributes: attributes2,
  description: undefined,
  extensions: extensions2,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_awsApplicationThirdPartyVulnerabilities_awsApplicationThirdPartyVulnerabilities = recordCodec(spec_awsApplicationThirdPartyVulnerabilities);
const attributes3 = Object.assign(Object.create(null), {
  gcp_application_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  first_party_vulnerability_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions3 = {
  oid: "1377088",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "gcp_application_first_party_vulnerabilities"
  },
  tags: Object.assign(Object.create(null), {
    omit: true,
    behavior: ["-*"]
  })
};
const parts3 = ["polymorphic", "gcp_application_first_party_vulnerabilities"];
const sqlIdent3 = sql.identifier(...parts3);
const spec_gcpApplicationFirstPartyVulnerabilities = {
  name: "gcpApplicationFirstPartyVulnerabilities",
  identifier: sqlIdent3,
  attributes: attributes3,
  description: undefined,
  extensions: extensions3,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_gcpApplicationFirstPartyVulnerabilities_gcpApplicationFirstPartyVulnerabilities = recordCodec(spec_gcpApplicationFirstPartyVulnerabilities);
const attributes4 = Object.assign(Object.create(null), {
  gcp_application_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  third_party_vulnerability_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions4 = {
  oid: "1377103",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "gcp_application_third_party_vulnerabilities"
  },
  tags: Object.assign(Object.create(null), {
    omit: true,
    behavior: ["-*"]
  })
};
const parts4 = ["polymorphic", "gcp_application_third_party_vulnerabilities"];
const sqlIdent4 = sql.identifier(...parts4);
const spec_gcpApplicationThirdPartyVulnerabilities = {
  name: "gcpApplicationThirdPartyVulnerabilities",
  identifier: sqlIdent4,
  attributes: attributes4,
  description: undefined,
  extensions: extensions4,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_gcpApplicationThirdPartyVulnerabilities_gcpApplicationThirdPartyVulnerabilities = recordCodec(spec_gcpApplicationThirdPartyVulnerabilities);
const attributes_object_Object_ = Object.assign(Object.create(null), {
  organization_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  name: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions5 = {
  oid: "1376792",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "organizations"
  },
  tags: Object.assign(Object.create(null), {
    unionMember: "PersonOrOrganization"
  })
};
const parts5 = ["polymorphic", "organizations"];
const sqlIdent5 = sql.identifier(...parts5);
const spec_organizations = {
  name: "organizations",
  identifier: sqlIdent5,
  attributes: attributes_object_Object_,
  description: undefined,
  extensions: extensions5,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_organizations_organizations = recordCodec(spec_organizations);
const attributes5 = Object.assign(Object.create(null), {
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  username: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions6 = {
  oid: "1376781",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "people"
  },
  tags: Object.assign(Object.create(null), {
    unionMember: "PersonOrOrganization",
    ref: "applications to:Application",
    refVia: ["applications via:aws_applications", "applications via:gcp_applications"]
  }),
  refDefinitions: Object.assign(Object.create(null), {
    applications: {
      singular: false,
      graphqlType: "Application",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    }
  })
};
const parts6 = ["polymorphic", "people"];
const sqlIdent6 = sql.identifier(...parts6);
const spec_people = {
  name: "people",
  identifier: sqlIdent6,
  attributes: attributes5,
  description: undefined,
  extensions: extensions6,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_people_people = recordCodec(spec_people);
const attributes6 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  title: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions7 = {
  oid: "1376834",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "priorities"
  },
  tags: Object.assign(Object.create(null), {
    omit: "create,update,delete,filter,order",
    behavior: ["-insert -update -delete -filter -filterBy -order -orderBy"]
  })
};
const parts7 = ["polymorphic", "priorities"];
const sqlIdent7 = sql.identifier(...parts7);
const spec_priorities = {
  name: "priorities",
  identifier: sqlIdent7,
  attributes: attributes6,
  description: undefined,
  extensions: extensions7,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_priorities_priorities = recordCodec(spec_priorities);
const extensions8 = {
  oid: "1376821",
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "item_type"
  },
  tags: Object.create(null)
};
const parts8 = ["polymorphic", "item_type"];
const sqlIdent8 = sql.identifier(...parts8);
const attributes_type_codec_itemType = enumCodec({
  name: "itemType",
  identifier: sqlIdent8,
  values: ["TOPIC", "POST", "DIVIDER", "CHECKLIST", "CHECKLIST_ITEM"],
  description: undefined,
  extensions: extensions8
});
const attributes7 = Object.assign(Object.create(null), {
  checklist_item_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  title: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  },
  type: {
    codec: attributes_type_codec_itemType,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  },
  parent_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  },
  root_topic_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  },
  author_id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  },
  position: {
    codec: TYPES.bigint,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  },
  created_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  },
  updated_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  },
  is_explicitly_archived: {
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  },
  archived_at: {
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyChecklistItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: {}
    }
  }
});
const extensions9 = {
  oid: "1376979",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_checklists"
  },
  tags: Object.create(null),
  relationalInterfaceCodecName: "relationalItems"
};
const parts9 = ["polymorphic", "relational_checklists"];
const sqlIdent9 = sql.identifier(...parts9);
const spec_relationalChecklists = {
  name: "relationalChecklists",
  identifier: sqlIdent9,
  attributes: attributes7,
  description: undefined,
  extensions: extensions9,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_relationalChecklists_relationalChecklists = recordCodec(spec_relationalChecklists);
const attributes8 = Object.assign(Object.create(null), {
  parent_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  child_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions10 = {
  oid: "1377146",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_item_relation_composite_pks"
  },
  tags: Object.create(null)
};
const parts10 = ["polymorphic", "relational_item_relation_composite_pks"];
const sqlIdent10 = sql.identifier(...parts10);
const spec_relationalItemRelationCompositePks = {
  name: "relationalItemRelationCompositePks",
  identifier: sqlIdent10,
  attributes: attributes8,
  description: undefined,
  extensions: extensions10,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_relationalItemRelationCompositePks_relationalItemRelationCompositePks = recordCodec(spec_relationalItemRelationCompositePks);
const attributes9 = Object.assign(Object.create(null), {
  topic_item_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  title: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.id.extensions.tags
    }
  },
  type: {
    codec: attributes_type_codec_itemType,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.type.extensions.tags
    }
  },
  parent_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.parent_id.extensions.tags
    }
  },
  root_topic_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.root_topic_id.extensions.tags
    }
  },
  author_id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.author_id.extensions.tags
    }
  },
  position: {
    codec: TYPES.bigint,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.position.extensions.tags
    }
  },
  created_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.created_at.extensions.tags
    }
  },
  updated_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.updated_at.extensions.tags
    }
  },
  is_explicitly_archived: {
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.is_explicitly_archived.extensions.tags
    }
  },
  archived_at: {
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyTopicItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.archived_at.extensions.tags
    }
  }
});
const extensions11 = {
  oid: "1376937",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_topics"
  },
  tags: Object.create(null),
  relationalInterfaceCodecName: "relationalItems"
};
const parts11 = ["polymorphic", "relational_topics"];
const sqlIdent11 = sql.identifier(...parts11);
const spec_relationalTopics = {
  name: "relationalTopics",
  identifier: sqlIdent11,
  attributes: attributes9,
  description: undefined,
  extensions: extensions11,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_relationalTopics_relationalTopics = recordCodec(spec_relationalTopics);
const attributes10 = Object.assign(Object.create(null), {
  parent_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  child_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions12 = {
  oid: "1376898",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "single_table_item_relation_composite_pks"
  },
  tags: Object.create(null)
};
const parts12 = ["polymorphic", "single_table_item_relation_composite_pks"];
const sqlIdent12 = sql.identifier(...parts12);
const spec_singleTableItemRelationCompositePks = {
  name: "singleTableItemRelationCompositePks",
  identifier: sqlIdent12,
  attributes: attributes10,
  description: undefined,
  extensions: extensions12,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_singleTableItemRelationCompositePks_singleTableItemRelationCompositePks = recordCodec(spec_singleTableItemRelationCompositePks);
const attributes11 = Object.assign(Object.create(null), {
  checklist_item_item_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  description: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  note: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.id.extensions.tags
    }
  },
  type: {
    codec: attributes_type_codec_itemType,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.type.extensions.tags
    }
  },
  parent_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.parent_id.extensions.tags
    }
  },
  root_topic_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.root_topic_id.extensions.tags
    }
  },
  author_id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.author_id.extensions.tags
    }
  },
  position: {
    codec: TYPES.bigint,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.position.extensions.tags
    }
  },
  created_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.created_at.extensions.tags
    }
  },
  updated_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.updated_at.extensions.tags
    }
  },
  is_explicitly_archived: {
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.is_explicitly_archived.extensions.tags
    }
  },
  archived_at: {
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyChecklistItemItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.archived_at.extensions.tags
    }
  }
});
const extensions13 = {
  oid: "1376991",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_checklist_items"
  },
  tags: Object.create(null),
  relationalInterfaceCodecName: "relationalItems"
};
const parts13 = ["polymorphic", "relational_checklist_items"];
const sqlIdent13 = sql.identifier(...parts13);
const spec_relationalChecklistItems = {
  name: "relationalChecklistItems",
  identifier: sqlIdent13,
  attributes: attributes11,
  description: undefined,
  extensions: extensions13,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_relationalChecklistItems_relationalChecklistItems = recordCodec(spec_relationalChecklistItems);
const attributes12 = Object.assign(Object.create(null), {
  divider_item_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  title: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  color: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.id.extensions.tags
    }
  },
  type: {
    codec: attributes_type_codec_itemType,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.type.extensions.tags
    }
  },
  parent_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.parent_id.extensions.tags
    }
  },
  root_topic_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.root_topic_id.extensions.tags
    }
  },
  author_id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.author_id.extensions.tags
    }
  },
  position: {
    codec: TYPES.bigint,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.position.extensions.tags
    }
  },
  created_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.created_at.extensions.tags
    }
  },
  updated_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.updated_at.extensions.tags
    }
  },
  is_explicitly_archived: {
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.is_explicitly_archived.extensions.tags
    }
  },
  archived_at: {
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyDividerItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.archived_at.extensions.tags
    }
  }
});
const extensions14 = {
  oid: "1376967",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_dividers"
  },
  tags: Object.create(null),
  relationalInterfaceCodecName: "relationalItems"
};
const parts14 = ["polymorphic", "relational_dividers"];
const sqlIdent14 = sql.identifier(...parts14);
const spec_relationalDividers = {
  name: "relationalDividers",
  identifier: sqlIdent14,
  attributes: attributes12,
  description: undefined,
  extensions: extensions14,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_relationalDividers_relationalDividers = recordCodec(spec_relationalDividers);
const attributes13 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  parent_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  child_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions15 = {
  oid: "1377126",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_item_relations"
  },
  tags: Object.create(null)
};
const parts15 = ["polymorphic", "relational_item_relations"];
const sqlIdent15 = sql.identifier(...parts15);
const spec_relationalItemRelations = {
  name: "relationalItemRelations",
  identifier: sqlIdent15,
  attributes: attributes13,
  description: undefined,
  extensions: extensions15,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_relationalItemRelations_relationalItemRelations = recordCodec(spec_relationalItemRelations);
const attributes14 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  parent_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  child_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions16 = {
  oid: "1376878",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "single_table_item_relations"
  },
  tags: Object.create(null)
};
const parts16 = ["polymorphic", "single_table_item_relations"];
const sqlIdent16 = sql.identifier(...parts16);
const spec_singleTableItemRelations = {
  name: "singleTableItemRelations",
  identifier: sqlIdent16,
  attributes: attributes14,
  description: undefined,
  extensions: extensions16,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_singleTableItemRelations_singleTableItemRelations = recordCodec(spec_singleTableItemRelations);
const attributes15 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  organization_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  text: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions17 = {
  oid: "1376803",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "log_entries"
  },
  tags: Object.assign(Object.create(null), {
    ref: "author to:PersonOrOrganization singular",
    refVia: ["author via:people", "author via:organizations"]
  }),
  refDefinitions: Object.assign(Object.create(null), {
    author: {
      singular: true,
      graphqlType: "PersonOrOrganization",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    }
  })
};
const parts17 = ["polymorphic", "log_entries"];
const sqlIdent17 = sql.identifier(...parts17);
const spec_logEntries = {
  name: "logEntries",
  identifier: sqlIdent17,
  attributes: attributes15,
  description: undefined,
  extensions: extensions17,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_logEntries_logEntries = recordCodec(spec_logEntries);
const attributes16 = Object.assign(Object.create(null), {
  post_item_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  title: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  description: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  note: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.id.extensions.tags
    }
  },
  type: {
    codec: attributes_type_codec_itemType,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.type.extensions.tags
    }
  },
  parent_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.parent_id.extensions.tags
    }
  },
  root_topic_id: {
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.root_topic_id.extensions.tags
    }
  },
  author_id: {
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.author_id.extensions.tags
    }
  },
  position: {
    codec: TYPES.bigint,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.position.extensions.tags
    }
  },
  created_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.created_at.extensions.tags
    }
  },
  updated_at: {
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.updated_at.extensions.tags
    }
  },
  is_explicitly_archived: {
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: true,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.is_explicitly_archived.extensions.tags
    }
  },
  archived_at: {
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    via: "relationalItemsByMyPostItemId",
    restrictedAccess: undefined,
    description: undefined,
    extensions: {
      tags: attributes7.archived_at.extensions.tags
    }
  }
});
const extensions18 = {
  oid: "1376954",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_posts"
  },
  tags: Object.create(null),
  relationalInterfaceCodecName: "relationalItems"
};
const parts18 = ["polymorphic", "relational_posts"];
const sqlIdent18 = sql.identifier(...parts18);
const spec_relationalPosts = {
  name: "relationalPosts",
  identifier: sqlIdent18,
  attributes: attributes16,
  description: undefined,
  extensions: extensions18,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_relationalPosts_relationalPosts = recordCodec(spec_relationalPosts);
const attributes_object_Object_2 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  name: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  cvss_score: {
    description: undefined,
    codec: TYPES.float,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  team_name: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions19 = {
  oid: "1377044",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "first_party_vulnerabilities"
  },
  tags: Object.assign(Object.create(null), {
    implements: "Vulnerability",
    ref: ["applications to:Application plural", "owners to:PersonOrOrganization plural"],
    refVia: ["applications via:aws_application_first_party_vulnerabilities;aws_applications", "applications via:gcp_application_first_party_vulnerabilities;gcp_applications", "owners via:aws_application_first_party_vulnerabilities;aws_applications;people", "owners via:aws_application_first_party_vulnerabilities;aws_applications;organizations", "owners via:gcp_application_first_party_vulnerabilities;gcp_applications;people", "owners via:gcp_application_first_party_vulnerabilities;gcp_applications;organizations"]
  }),
  refDefinitions: Object.assign(Object.create(null), {
    applications: {
      singular: false,
      graphqlType: "Application",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    },
    owners: {
      singular: false,
      graphqlType: "PersonOrOrganization",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    }
  })
};
const parts19 = ["polymorphic", "first_party_vulnerabilities"];
const sqlIdent19 = sql.identifier(...parts19);
const spec_firstPartyVulnerabilities = {
  name: "firstPartyVulnerabilities",
  identifier: sqlIdent19,
  attributes: attributes_object_Object_2,
  description: undefined,
  extensions: extensions19,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_firstPartyVulnerabilities_firstPartyVulnerabilities = recordCodec(spec_firstPartyVulnerabilities);
const attributes_object_Object_3 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  name: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  cvss_score: {
    description: undefined,
    codec: TYPES.float,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  vendor_name: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions20 = {
  oid: "1377051",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "third_party_vulnerabilities"
  },
  tags: Object.assign(Object.create(null), {
    implements: "Vulnerability",
    ref: ["applications to:Application plural", "owners to:PersonOrOrganization plural"],
    refVia: ["applications via:aws_application_third_party_vulnerabilities;aws_applications", "applications via:gcp_application_third_party_vulnerabilities;gcp_applications", "owners via:aws_application_third_party_vulnerabilities;aws_applications;people", "owners via:aws_application_third_party_vulnerabilities;aws_applications;organizations", "owners via:gcp_application_third_party_vulnerabilities;gcp_applications;people", "owners via:gcp_application_third_party_vulnerabilities;gcp_applications;organizations"]
  }),
  refDefinitions: Object.assign(Object.create(null), {
    applications: {
      singular: false,
      graphqlType: "Application",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    },
    owners: {
      singular: false,
      graphqlType: "PersonOrOrganization",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    }
  })
};
const parts20 = ["polymorphic", "third_party_vulnerabilities"];
const sqlIdent20 = sql.identifier(...parts20);
const spec_thirdPartyVulnerabilities = {
  name: "thirdPartyVulnerabilities",
  identifier: sqlIdent20,
  attributes: attributes_object_Object_3,
  description: undefined,
  extensions: extensions20,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_thirdPartyVulnerabilities_thirdPartyVulnerabilities = recordCodec(spec_thirdPartyVulnerabilities);
const attributes_object_Object_4 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  name: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  last_deployed: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  organization_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  aws_id: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions21 = {
  oid: "1377007",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "aws_applications"
  },
  tags: Object.assign(Object.create(null), {
    implements: "Application",
    ref: ["vulnerabilities to:Vulnerability plural", "owner to:PersonOrOrganization singular"],
    refVia: ["vulnerabilities via:(id)->aws_application_first_party_vulnerabilities(aws_application_id);(first_party_vulnerability_id)->first_party_vulnerabilities(id)", "vulnerabilities via:(id)->aws_application_third_party_vulnerabilities(aws_application_id);(third_party_vulnerability_id)->third_party_vulnerabilities(id)", "owner via:people", "owner via:organizations"]
  }),
  refDefinitions: Object.assign(Object.create(null), {
    vulnerabilities: {
      singular: false,
      graphqlType: "Vulnerability",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    },
    owner: {
      singular: true,
      graphqlType: "PersonOrOrganization",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    }
  })
};
const parts21 = ["polymorphic", "aws_applications"];
const sqlIdent21 = sql.identifier(...parts21);
const spec_awsApplications = {
  name: "awsApplications",
  identifier: sqlIdent21,
  attributes: attributes_object_Object_4,
  description: undefined,
  extensions: extensions21,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_awsApplications_awsApplications = recordCodec(spec_awsApplications);
const attributes_object_Object_5 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  name: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  last_deployed: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  organization_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  gcp_id: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions22 = {
  oid: "1377024",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "gcp_applications"
  },
  tags: Object.assign(Object.create(null), {
    implements: "Application",
    ref: ["vulnerabilities to:Vulnerability plural", "owner to:PersonOrOrganization singular"],
    refVia: ["vulnerabilities via:(id)->gcp_application_first_party_vulnerabilities(gcp_application_id);(first_party_vulnerability_id)->first_party_vulnerabilities(id)", "vulnerabilities via:(id)->gcp_application_third_party_vulnerabilities(gcp_application_id);(third_party_vulnerability_id)->third_party_vulnerabilities(id)", "owner via:people", "owner via:organizations"]
  }),
  refDefinitions: Object.assign(Object.create(null), {
    vulnerabilities: {
      singular: false,
      graphqlType: "Vulnerability",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    },
    owner: {
      singular: true,
      graphqlType: "PersonOrOrganization",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    }
  })
};
const parts22 = ["polymorphic", "gcp_applications"];
const sqlIdent22 = sql.identifier(...parts22);
const spec_gcpApplications = {
  name: "gcpApplications",
  identifier: sqlIdent22,
  attributes: attributes_object_Object_5,
  description: undefined,
  extensions: extensions22,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_gcpApplications_gcpApplications = recordCodec(spec_gcpApplications);
const attributes17 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  type: {
    description: undefined,
    codec: attributes_type_codec_itemType,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  parent_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  root_topic_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  author_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  position: {
    description: undefined,
    codec: TYPES.bigint,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  created_at: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  updated_at: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  is_explicitly_archived: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  archived_at: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  title: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  description: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  note: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  color: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  priority_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions23 = {
  oid: "1376843",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "single_table_items"
  },
  tags: Object.assign(Object.create(null), {
    interface: "mode:single type:type",
    type: ["TOPIC name:SingleTableTopic attributes:title!", "POST name:SingleTablePost attributes:title>subject,description,note,priority_id", "DIVIDER name:SingleTableDivider attributes:title,color", "CHECKLIST name:SingleTableChecklist attributes:title", "CHECKLIST_ITEM name:SingleTableChecklistItem attributes:description,note,priority_id"],
    ref: ["rootTopic to:SingleTableTopic singular via:(root_topic_id)->polymorphic.single_table_items(id)", "rootChecklistTopic from:SingleTableChecklist to:SingleTableTopic singular via:(root_topic_id)->polymorphic.single_table_items(id)"]
  }),
  refDefinitions: Object.assign(Object.create(null), {
    rootTopic: {
      singular: true,
      graphqlType: "SingleTableTopic",
      sourceGraphqlType: undefined,
      extensions: {
        via: "(root_topic_id)->polymorphic.single_table_items(id)",
        tags: {
          behavior: undefined
        }
      }
    },
    rootChecklistTopic: {
      singular: true,
      graphqlType: "SingleTableTopic",
      sourceGraphqlType: "SingleTableChecklist",
      extensions: {
        via: "(root_topic_id)->polymorphic.single_table_items(id)",
        tags: {
          behavior: undefined
        }
      }
    }
  })
};
const parts23 = ["polymorphic", "single_table_items"];
const sqlIdent23 = sql.identifier(...parts23);
const spec_singleTableItems = {
  name: "singleTableItems",
  identifier: sqlIdent23,
  attributes: attributes17,
  description: undefined,
  extensions: extensions23,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_singleTableItems_singleTableItems = recordCodec(spec_singleTableItems);
const attributes18 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: attributes7.id.extensions.tags
    }
  },
  type: {
    description: undefined,
    codec: attributes_type_codec_itemType,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: attributes7.type.extensions.tags
    }
  },
  parent_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: attributes7.parent_id.extensions.tags
    }
  },
  root_topic_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: attributes7.root_topic_id.extensions.tags
    }
  },
  author_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: attributes7.author_id.extensions.tags
    }
  },
  position: {
    description: undefined,
    codec: TYPES.bigint,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: attributes7.position.extensions.tags
    }
  },
  created_at: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: attributes7.created_at.extensions.tags
    }
  },
  updated_at: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: attributes7.updated_at.extensions.tags
    }
  },
  is_explicitly_archived: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: attributes7.is_explicitly_archived.extensions.tags
    }
  },
  archived_at: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: attributes7.archived_at.extensions.tags
    }
  }
});
const extensions24 = {
  oid: "1376916",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_items"
  },
  tags: Object.assign(Object.create(null), {
    interface: "mode:relational",
    type: ["TOPIC references:relational_topics", "POST references:relational_posts", "DIVIDER references:relational_dividers", "CHECKLIST references:relational_checklists", "CHECKLIST_ITEM references:relational_checklist_items"]
  })
};
const parts24 = ["polymorphic", "relational_items"];
const sqlIdent24 = sql.identifier(...parts24);
const spec_relationalItems = {
  name: "relationalItems",
  identifier: sqlIdent24,
  attributes: attributes18,
  description: undefined,
  extensions: extensions24,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_relationalItems_relationalItems = recordCodec(spec_relationalItems);
const attributes_object_Object_6 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {
        notNull: true
      }
    }
  },
  name: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {
        notNull: true
      }
    }
  },
  last_deployed: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions25 = {
  oid: "1377004",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "applications"
  },
  tags: Object.assign(Object.create(null), {
    interface: "mode:union",
    name: "Application",
    behavior: "node",
    ref: ["vulnerabilities to:Vulnerability plural", "owner to:PersonOrOrganization singular"]
  }),
  refDefinitions: Object.assign(Object.create(null), {
    vulnerabilities: {
      singular: false,
      graphqlType: "Vulnerability",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    },
    owner: {
      singular: true,
      graphqlType: "PersonOrOrganization",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    }
  })
};
const parts25 = ["polymorphic", "applications"];
const sqlIdent25 = sql.identifier(...parts25);
const spec_Application = {
  name: "Application",
  identifier: sqlIdent25,
  attributes: attributes_object_Object_6,
  description: undefined,
  extensions: extensions25,
  executor: executor_mainPgExecutor
};
const attributes_object_Object_7 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {
        notNull: true
      }
    }
  },
  name: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {
        notNull: true
      }
    }
  },
  cvss_score: {
    description: undefined,
    codec: TYPES.float,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {
        notNull: true
      }
    }
  }
});
const extensions26 = {
  oid: "1377041",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "vulnerabilities"
  },
  tags: Object.assign(Object.create(null), {
    interface: "mode:union",
    name: "Vulnerability",
    behavior: "node",
    ref: ["applications to:Application plural", "owners to:PersonOrOrganization plural"]
  }),
  refDefinitions: Object.assign(Object.create(null), {
    applications: {
      singular: false,
      graphqlType: "Application",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    },
    owners: {
      singular: false,
      graphqlType: "PersonOrOrganization",
      sourceGraphqlType: undefined,
      extensions: {
        via: undefined,
        tags: {
          behavior: undefined
        }
      }
    }
  })
};
const parts26 = ["polymorphic", "vulnerabilities"];
const sqlIdent26 = sql.identifier(...parts26);
const spec_Vulnerability = {
  name: "Vulnerability",
  identifier: sqlIdent26,
  attributes: attributes_object_Object_7,
  description: undefined,
  extensions: extensions26,
  executor: executor_mainPgExecutor
};
const attributes_object_Object_8 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  name: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions27 = {
  oid: "1377122",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "zero_implementation"
  },
  tags: Object.assign(Object.create(null), {
    interface: "mode:union",
    name: "ZeroImplementation",
    behavior: "node"
  })
};
const parts27 = ["polymorphic", "zero_implementation"];
const sqlIdent27 = sql.identifier(...parts27);
const spec_ZeroImplementation = {
  name: "ZeroImplementation",
  identifier: sqlIdent27,
  attributes: attributes_object_Object_8,
  description: undefined,
  extensions: extensions27,
  executor: executor_mainPgExecutor
};
const extensions28 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "aws_application_first_party_vulnerabilities"
  },
  tags: {
    omit: true,
    behavior: extensions.tags.behavior
  }
};
const registryConfig_pgResources_aws_application_first_party_vulnerabilities_aws_application_first_party_vulnerabilities = {
  executor: executor_mainPgExecutor,
  name: "aws_application_first_party_vulnerabilities",
  identifier: "main.polymorphic.aws_application_first_party_vulnerabilities",
  from: registryConfig_pgCodecs_awsApplicationFirstPartyVulnerabilities_awsApplicationFirstPartyVulnerabilities.sqlType,
  codec: registryConfig_pgCodecs_awsApplicationFirstPartyVulnerabilities_awsApplicationFirstPartyVulnerabilities,
  uniques: [{
    isPrimary: true,
    attributes: ["aws_application_id", "first_party_vulnerability_id"],
    description: undefined,
    extensions: {
      tags: Object.create(null)
    }
  }],
  isVirtual: false,
  description: undefined,
  extensions: extensions28
};
const extensions29 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "aws_application_third_party_vulnerabilities"
  },
  tags: {
    omit: true,
    behavior: extensions2.tags.behavior
  }
};
const uniques2 = [{
  isPrimary: true,
  attributes: ["aws_application_id", "third_party_vulnerability_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_aws_application_third_party_vulnerabilities_aws_application_third_party_vulnerabilities = {
  executor: executor_mainPgExecutor,
  name: "aws_application_third_party_vulnerabilities",
  identifier: "main.polymorphic.aws_application_third_party_vulnerabilities",
  from: registryConfig_pgCodecs_awsApplicationThirdPartyVulnerabilities_awsApplicationThirdPartyVulnerabilities.sqlType,
  codec: registryConfig_pgCodecs_awsApplicationThirdPartyVulnerabilities_awsApplicationThirdPartyVulnerabilities,
  uniques: uniques2,
  isVirtual: false,
  description: undefined,
  extensions: extensions29
};
const extensions30 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "gcp_application_first_party_vulnerabilities"
  },
  tags: {
    omit: true,
    behavior: extensions3.tags.behavior
  }
};
const uniques3 = [{
  isPrimary: true,
  attributes: ["gcp_application_id", "first_party_vulnerability_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_gcp_application_first_party_vulnerabilities_gcp_application_first_party_vulnerabilities = {
  executor: executor_mainPgExecutor,
  name: "gcp_application_first_party_vulnerabilities",
  identifier: "main.polymorphic.gcp_application_first_party_vulnerabilities",
  from: registryConfig_pgCodecs_gcpApplicationFirstPartyVulnerabilities_gcpApplicationFirstPartyVulnerabilities.sqlType,
  codec: registryConfig_pgCodecs_gcpApplicationFirstPartyVulnerabilities_gcpApplicationFirstPartyVulnerabilities,
  uniques: uniques3,
  isVirtual: false,
  description: undefined,
  extensions: extensions30
};
const extensions31 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "gcp_application_third_party_vulnerabilities"
  },
  tags: {
    omit: true,
    behavior: extensions4.tags.behavior
  }
};
const uniques4 = [{
  isPrimary: true,
  attributes: ["gcp_application_id", "third_party_vulnerability_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_gcp_application_third_party_vulnerabilities_gcp_application_third_party_vulnerabilities = {
  executor: executor_mainPgExecutor,
  name: "gcp_application_third_party_vulnerabilities",
  identifier: "main.polymorphic.gcp_application_third_party_vulnerabilities",
  from: registryConfig_pgCodecs_gcpApplicationThirdPartyVulnerabilities_gcpApplicationThirdPartyVulnerabilities.sqlType,
  codec: registryConfig_pgCodecs_gcpApplicationThirdPartyVulnerabilities_gcpApplicationThirdPartyVulnerabilities,
  uniques: uniques4,
  isVirtual: false,
  description: undefined,
  extensions: extensions31
};
const extensions32 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "organizations"
  },
  tags: {
    unionMember: "PersonOrOrganization"
  }
};
const uniques5 = [{
  isPrimary: true,
  attributes: ["organization_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["name"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_organizations_organizations = {
  executor: executor_mainPgExecutor,
  name: "organizations",
  identifier: "main.polymorphic.organizations",
  from: registryConfig_pgCodecs_organizations_organizations.sqlType,
  codec: registryConfig_pgCodecs_organizations_organizations,
  uniques: uniques5,
  isVirtual: false,
  description: undefined,
  extensions: extensions32
};
const extensions33 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "people"
  },
  tags: {
    unionMember: "PersonOrOrganization",
    ref: "applications to:Application",
    refVia: extensions6.tags.refVia
  }
};
const uniques6 = [{
  isPrimary: true,
  attributes: ["person_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["username"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_people_people = {
  executor: executor_mainPgExecutor,
  name: "people",
  identifier: "main.polymorphic.people",
  from: registryConfig_pgCodecs_people_people.sqlType,
  codec: registryConfig_pgCodecs_people_people,
  uniques: uniques6,
  isVirtual: false,
  description: undefined,
  extensions: extensions33
};
const extensions34 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "priorities"
  },
  tags: {
    omit: "create,update,delete,filter,order",
    behavior: extensions7.tags.behavior
  }
};
const uniques7 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_priorities_priorities = {
  executor: executor_mainPgExecutor,
  name: "priorities",
  identifier: "main.polymorphic.priorities",
  from: registryConfig_pgCodecs_priorities_priorities.sqlType,
  codec: registryConfig_pgCodecs_priorities_priorities,
  uniques: uniques7,
  isVirtual: false,
  description: undefined,
  extensions: extensions34
};
const extensions35 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_checklists"
  },
  tags: {}
};
const uniques8 = [{
  isPrimary: true,
  attributes: ["checklist_item_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_relational_checklists_relational_checklists = {
  executor: executor_mainPgExecutor,
  name: "relational_checklists",
  identifier: "main.polymorphic.relational_checklists",
  from: registryConfig_pgCodecs_relationalChecklists_relationalChecklists.sqlType,
  codec: registryConfig_pgCodecs_relationalChecklists_relationalChecklists,
  uniques: uniques8,
  isVirtual: false,
  description: undefined,
  extensions: extensions35
};
const extensions36 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_item_relation_composite_pks"
  },
  tags: {}
};
const uniques9 = [{
  isPrimary: true,
  attributes: ["parent_id", "child_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_relational_item_relation_composite_pks_relational_item_relation_composite_pks = {
  executor: executor_mainPgExecutor,
  name: "relational_item_relation_composite_pks",
  identifier: "main.polymorphic.relational_item_relation_composite_pks",
  from: registryConfig_pgCodecs_relationalItemRelationCompositePks_relationalItemRelationCompositePks.sqlType,
  codec: registryConfig_pgCodecs_relationalItemRelationCompositePks_relationalItemRelationCompositePks,
  uniques: uniques9,
  isVirtual: false,
  description: undefined,
  extensions: extensions36
};
const extensions37 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_topics"
  },
  tags: {}
};
const uniques10 = [{
  isPrimary: true,
  attributes: ["topic_item_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_relational_topics_relational_topics = {
  executor: executor_mainPgExecutor,
  name: "relational_topics",
  identifier: "main.polymorphic.relational_topics",
  from: registryConfig_pgCodecs_relationalTopics_relationalTopics.sqlType,
  codec: registryConfig_pgCodecs_relationalTopics_relationalTopics,
  uniques: uniques10,
  isVirtual: false,
  description: undefined,
  extensions: extensions37
};
const extensions38 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "single_table_item_relation_composite_pks"
  },
  tags: {}
};
const uniques11 = [{
  isPrimary: true,
  attributes: ["parent_id", "child_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_single_table_item_relation_composite_pks_single_table_item_relation_composite_pks = {
  executor: executor_mainPgExecutor,
  name: "single_table_item_relation_composite_pks",
  identifier: "main.polymorphic.single_table_item_relation_composite_pks",
  from: registryConfig_pgCodecs_singleTableItemRelationCompositePks_singleTableItemRelationCompositePks.sqlType,
  codec: registryConfig_pgCodecs_singleTableItemRelationCompositePks_singleTableItemRelationCompositePks,
  uniques: uniques11,
  isVirtual: false,
  description: undefined,
  extensions: extensions38
};
const extensions39 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_checklist_items"
  },
  tags: {}
};
const uniques12 = [{
  isPrimary: true,
  attributes: ["checklist_item_item_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_relational_checklist_items_relational_checklist_items = {
  executor: executor_mainPgExecutor,
  name: "relational_checklist_items",
  identifier: "main.polymorphic.relational_checklist_items",
  from: registryConfig_pgCodecs_relationalChecklistItems_relationalChecklistItems.sqlType,
  codec: registryConfig_pgCodecs_relationalChecklistItems_relationalChecklistItems,
  uniques: uniques12,
  isVirtual: false,
  description: undefined,
  extensions: extensions39
};
const extensions40 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_dividers"
  },
  tags: {}
};
const uniques13 = [{
  isPrimary: true,
  attributes: ["divider_item_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_relational_dividers_relational_dividers = {
  executor: executor_mainPgExecutor,
  name: "relational_dividers",
  identifier: "main.polymorphic.relational_dividers",
  from: registryConfig_pgCodecs_relationalDividers_relationalDividers.sqlType,
  codec: registryConfig_pgCodecs_relationalDividers_relationalDividers,
  uniques: uniques13,
  isVirtual: false,
  description: undefined,
  extensions: extensions40
};
const extensions41 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_item_relations"
  },
  tags: {}
};
const uniques14 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["parent_id", "child_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_relational_item_relations_relational_item_relations = {
  executor: executor_mainPgExecutor,
  name: "relational_item_relations",
  identifier: "main.polymorphic.relational_item_relations",
  from: registryConfig_pgCodecs_relationalItemRelations_relationalItemRelations.sqlType,
  codec: registryConfig_pgCodecs_relationalItemRelations_relationalItemRelations,
  uniques: uniques14,
  isVirtual: false,
  description: undefined,
  extensions: extensions41
};
const extensions42 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "single_table_item_relations"
  },
  tags: {}
};
const uniques15 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["parent_id", "child_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_single_table_item_relations_single_table_item_relations = {
  executor: executor_mainPgExecutor,
  name: "single_table_item_relations",
  identifier: "main.polymorphic.single_table_item_relations",
  from: registryConfig_pgCodecs_singleTableItemRelations_singleTableItemRelations.sqlType,
  codec: registryConfig_pgCodecs_singleTableItemRelations_singleTableItemRelations,
  uniques: uniques15,
  isVirtual: false,
  description: undefined,
  extensions: extensions42
};
const extensions43 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "log_entries"
  },
  tags: {
    ref: "author to:PersonOrOrganization singular",
    refVia: extensions17.tags.refVia
  }
};
const uniques16 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_log_entries_log_entries = {
  executor: executor_mainPgExecutor,
  name: "log_entries",
  identifier: "main.polymorphic.log_entries",
  from: registryConfig_pgCodecs_logEntries_logEntries.sqlType,
  codec: registryConfig_pgCodecs_logEntries_logEntries,
  uniques: uniques16,
  isVirtual: false,
  description: undefined,
  extensions: extensions43
};
const extensions44 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_posts"
  },
  tags: {}
};
const uniques17 = [{
  isPrimary: true,
  attributes: ["post_item_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_relational_posts_relational_posts = {
  executor: executor_mainPgExecutor,
  name: "relational_posts",
  identifier: "main.polymorphic.relational_posts",
  from: registryConfig_pgCodecs_relationalPosts_relationalPosts.sqlType,
  codec: registryConfig_pgCodecs_relationalPosts_relationalPosts,
  uniques: uniques17,
  isVirtual: false,
  description: undefined,
  extensions: extensions44
};
const extensions45 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "first_party_vulnerabilities"
  },
  tags: {
    implements: "Vulnerability",
    ref: extensions19.tags.ref,
    refVia: extensions19.tags.refVia
  }
};
const uniques18 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_first_party_vulnerabilities_first_party_vulnerabilities = {
  executor: executor_mainPgExecutor,
  name: "first_party_vulnerabilities",
  identifier: "main.polymorphic.first_party_vulnerabilities",
  from: registryConfig_pgCodecs_firstPartyVulnerabilities_firstPartyVulnerabilities.sqlType,
  codec: registryConfig_pgCodecs_firstPartyVulnerabilities_firstPartyVulnerabilities,
  uniques: uniques18,
  isVirtual: false,
  description: undefined,
  extensions: extensions45
};
const extensions46 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "third_party_vulnerabilities"
  },
  tags: {
    implements: "Vulnerability",
    ref: extensions20.tags.ref,
    refVia: extensions20.tags.refVia
  }
};
const uniques19 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_third_party_vulnerabilities_third_party_vulnerabilities = {
  executor: executor_mainPgExecutor,
  name: "third_party_vulnerabilities",
  identifier: "main.polymorphic.third_party_vulnerabilities",
  from: registryConfig_pgCodecs_thirdPartyVulnerabilities_thirdPartyVulnerabilities.sqlType,
  codec: registryConfig_pgCodecs_thirdPartyVulnerabilities_thirdPartyVulnerabilities,
  uniques: uniques19,
  isVirtual: false,
  description: undefined,
  extensions: extensions46
};
const extensions47 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "aws_applications"
  },
  tags: {
    implements: "Application",
    ref: extensions21.tags.ref,
    refVia: extensions21.tags.refVia
  }
};
const uniques20 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_aws_applications_aws_applications = {
  executor: executor_mainPgExecutor,
  name: "aws_applications",
  identifier: "main.polymorphic.aws_applications",
  from: registryConfig_pgCodecs_awsApplications_awsApplications.sqlType,
  codec: registryConfig_pgCodecs_awsApplications_awsApplications,
  uniques: uniques20,
  isVirtual: false,
  description: undefined,
  extensions: extensions47
};
const extensions48 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "gcp_applications"
  },
  tags: {
    implements: "Application",
    ref: extensions22.tags.ref,
    refVia: extensions22.tags.refVia
  }
};
const uniques21 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_gcp_applications_gcp_applications = {
  executor: executor_mainPgExecutor,
  name: "gcp_applications",
  identifier: "main.polymorphic.gcp_applications",
  from: registryConfig_pgCodecs_gcpApplications_gcpApplications.sqlType,
  codec: registryConfig_pgCodecs_gcpApplications_gcpApplications,
  uniques: uniques21,
  isVirtual: false,
  description: undefined,
  extensions: extensions48
};
const extensions49 = {
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "custom_delete_relational_item"
  },
  tags: {
    arg0variant: "nodeId",
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts28 = ["polymorphic", "custom_delete_relational_item"];
const sqlIdent28 = sql.identifier(...parts28);
const extensions50 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "single_table_items"
  },
  tags: {
    interface: "mode:single type:type",
    type: extensions23.tags.type,
    ref: extensions23.tags.ref
  }
};
const uniques22 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_single_table_items_single_table_items = {
  executor: executor_mainPgExecutor,
  name: "single_table_items",
  identifier: "main.polymorphic.single_table_items",
  from: registryConfig_pgCodecs_singleTableItems_singleTableItems.sqlType,
  codec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
  uniques: uniques22,
  isVirtual: false,
  description: undefined,
  extensions: extensions50
};
const parts29 = ["polymorphic", "all_single_tables"];
const sqlIdent29 = sql.identifier(...parts29);
const options_all_single_tables = {
  name: "all_single_tables",
  identifier: "main.polymorphic.all_single_tables()",
  from(...args) {
    return sql`${sqlIdent29}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "polymorphic",
      name: "all_single_tables"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts30 = ["polymorphic", "get_single_table_topic_by_id"];
const sqlIdent30 = sql.identifier(...parts30);
const options_get_single_table_topic_by_id = {
  name: "get_single_table_topic_by_id",
  identifier: "main.polymorphic.get_single_table_topic_by_id(int4)",
  from(...args) {
    return sql`${sqlIdent30}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "polymorphic",
      name: "get_single_table_topic_by_id"
    },
    tags: {
      returnType: "SingleTableTopic",
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const extensions51 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "polymorphic",
    name: "relational_items"
  },
  tags: {
    interface: "mode:relational",
    type: extensions24.tags.type
  }
};
const uniques23 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_relational_items_relational_items = {
  executor: executor_mainPgExecutor,
  name: "relational_items",
  identifier: "main.polymorphic.relational_items",
  from: registryConfig_pgCodecs_relationalItems_relationalItems.sqlType,
  codec: registryConfig_pgCodecs_relationalItems_relationalItems,
  uniques: uniques23,
  isVirtual: false,
  description: undefined,
  extensions: extensions51
};
const registryConfig = {
  pgCodecs: Object.assign(Object.create(null), {
    awsApplicationFirstPartyVulnerabilities: registryConfig_pgCodecs_awsApplicationFirstPartyVulnerabilities_awsApplicationFirstPartyVulnerabilities,
    int4: TYPES.int,
    awsApplicationThirdPartyVulnerabilities: registryConfig_pgCodecs_awsApplicationThirdPartyVulnerabilities_awsApplicationThirdPartyVulnerabilities,
    gcpApplicationFirstPartyVulnerabilities: registryConfig_pgCodecs_gcpApplicationFirstPartyVulnerabilities_gcpApplicationFirstPartyVulnerabilities,
    gcpApplicationThirdPartyVulnerabilities: registryConfig_pgCodecs_gcpApplicationThirdPartyVulnerabilities_gcpApplicationThirdPartyVulnerabilities,
    organizations: registryConfig_pgCodecs_organizations_organizations,
    text: TYPES.text,
    people: registryConfig_pgCodecs_people_people,
    priorities: registryConfig_pgCodecs_priorities_priorities,
    relationalChecklists: registryConfig_pgCodecs_relationalChecklists_relationalChecklists,
    relationalItemRelationCompositePks: registryConfig_pgCodecs_relationalItemRelationCompositePks_relationalItemRelationCompositePks,
    relationalTopics: registryConfig_pgCodecs_relationalTopics_relationalTopics,
    singleTableItemRelationCompositePks: registryConfig_pgCodecs_singleTableItemRelationCompositePks_singleTableItemRelationCompositePks,
    relationalChecklistItems: registryConfig_pgCodecs_relationalChecklistItems_relationalChecklistItems,
    relationalDividers: registryConfig_pgCodecs_relationalDividers_relationalDividers,
    relationalItemRelations: registryConfig_pgCodecs_relationalItemRelations_relationalItemRelations,
    singleTableItemRelations: registryConfig_pgCodecs_singleTableItemRelations_singleTableItemRelations,
    logEntries: registryConfig_pgCodecs_logEntries_logEntries,
    relationalPosts: registryConfig_pgCodecs_relationalPosts_relationalPosts,
    firstPartyVulnerabilities: registryConfig_pgCodecs_firstPartyVulnerabilities_firstPartyVulnerabilities,
    float8: TYPES.float,
    thirdPartyVulnerabilities: registryConfig_pgCodecs_thirdPartyVulnerabilities_thirdPartyVulnerabilities,
    awsApplications: registryConfig_pgCodecs_awsApplications_awsApplications,
    timestamptz: TYPES.timestamptz,
    gcpApplications: registryConfig_pgCodecs_gcpApplications_gcpApplications,
    bool: TYPES.boolean,
    singleTableItems: registryConfig_pgCodecs_singleTableItems_singleTableItems,
    itemType: attributes_type_codec_itemType,
    int8: TYPES.bigint,
    relationalItems: registryConfig_pgCodecs_relationalItems_relationalItems,
    varchar: TYPES.varchar,
    bpchar: TYPES.bpchar,
    Application: recordCodec(spec_Application),
    Vulnerability: recordCodec(spec_Vulnerability),
    ZeroImplementation: recordCodec(spec_ZeroImplementation)
  }),
  pgResources: Object.assign(Object.create(null), {
    aws_application_first_party_vulnerabilities: registryConfig_pgResources_aws_application_first_party_vulnerabilities_aws_application_first_party_vulnerabilities,
    aws_application_third_party_vulnerabilities: registryConfig_pgResources_aws_application_third_party_vulnerabilities_aws_application_third_party_vulnerabilities,
    gcp_application_first_party_vulnerabilities: registryConfig_pgResources_gcp_application_first_party_vulnerabilities_gcp_application_first_party_vulnerabilities,
    gcp_application_third_party_vulnerabilities: registryConfig_pgResources_gcp_application_third_party_vulnerabilities_gcp_application_third_party_vulnerabilities,
    organizations: registryConfig_pgResources_organizations_organizations,
    people: registryConfig_pgResources_people_people,
    priorities: registryConfig_pgResources_priorities_priorities,
    relational_checklists: registryConfig_pgResources_relational_checklists_relational_checklists,
    relational_item_relation_composite_pks: registryConfig_pgResources_relational_item_relation_composite_pks_relational_item_relation_composite_pks,
    relational_topics: registryConfig_pgResources_relational_topics_relational_topics,
    single_table_item_relation_composite_pks: registryConfig_pgResources_single_table_item_relation_composite_pks_single_table_item_relation_composite_pks,
    relational_checklist_items: registryConfig_pgResources_relational_checklist_items_relational_checklist_items,
    relational_dividers: registryConfig_pgResources_relational_dividers_relational_dividers,
    relational_item_relations: registryConfig_pgResources_relational_item_relations_relational_item_relations,
    single_table_item_relations: registryConfig_pgResources_single_table_item_relations_single_table_item_relations,
    log_entries: registryConfig_pgResources_log_entries_log_entries,
    relational_posts: registryConfig_pgResources_relational_posts_relational_posts,
    first_party_vulnerabilities: registryConfig_pgResources_first_party_vulnerabilities_first_party_vulnerabilities,
    third_party_vulnerabilities: registryConfig_pgResources_third_party_vulnerabilities_third_party_vulnerabilities,
    aws_applications: registryConfig_pgResources_aws_applications_aws_applications,
    gcp_applications: registryConfig_pgResources_gcp_applications_gcp_applications,
    custom_delete_relational_item: {
      executor: executor_mainPgExecutor,
      name: "custom_delete_relational_item",
      identifier: "main.polymorphic.custom_delete_relational_item(polymorphic.relational_items)",
      from(...args) {
        return sql`${sqlIdent28}(${sqlFromArgDigests(args)})`;
      },
      parameters: [{
        name: "nodeId",
        required: true,
        notNull: false,
        codec: registryConfig_pgCodecs_relationalItems_relationalItems,
        extensions: {
          variant: "nodeId"
        }
      }],
      isUnique: !false,
      codec: TYPES.boolean,
      uniques: [],
      isMutation: true,
      extensions: extensions49,
      description: undefined
    },
    single_table_items: registryConfig_pgResources_single_table_items_single_table_items,
    all_single_tables: PgResource.functionResourceOptions(registryConfig_pgResources_single_table_items_single_table_items, options_all_single_tables),
    get_single_table_topic_by_id: PgResource.functionResourceOptions(registryConfig_pgResources_single_table_items_single_table_items, options_get_single_table_topic_by_id),
    relational_items: registryConfig_pgResources_relational_items_relational_items
  }),
  pgRelations: Object.assign(Object.create(null), {
    awsApplicationFirstPartyVulnerabilities: Object.assign(Object.create(null), {
      firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId: {
        localCodec: registryConfig_pgCodecs_awsApplicationFirstPartyVulnerabilities_awsApplicationFirstPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_first_party_vulnerabilities_first_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["first_party_vulnerability_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      awsApplicationsByMyAwsApplicationId: {
        localCodec: registryConfig_pgCodecs_awsApplicationFirstPartyVulnerabilities_awsApplicationFirstPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_aws_applications_aws_applications,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["aws_application_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    awsApplicationThirdPartyVulnerabilities: Object.assign(Object.create(null), {
      thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId: {
        localCodec: registryConfig_pgCodecs_awsApplicationThirdPartyVulnerabilities_awsApplicationThirdPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_third_party_vulnerabilities_third_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["third_party_vulnerability_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      awsApplicationsByMyAwsApplicationId: {
        localCodec: registryConfig_pgCodecs_awsApplicationThirdPartyVulnerabilities_awsApplicationThirdPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_aws_applications_aws_applications,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["aws_application_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    awsApplications: Object.assign(Object.create(null), {
      organizationsByMyOrganizationId: {
        localCodec: registryConfig_pgCodecs_awsApplications_awsApplications,
        remoteResourceOptions: registryConfig_pgResources_organizations_organizations,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["organization_id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      peopleByMyPersonId: {
        localCodec: registryConfig_pgCodecs_awsApplications_awsApplications,
        remoteResourceOptions: registryConfig_pgResources_people_people,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["person_id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      awsApplicationFirstPartyVulnerabilitiesByTheirAwsApplicationId: {
        localCodec: registryConfig_pgCodecs_awsApplications_awsApplications,
        remoteResourceOptions: registryConfig_pgResources_aws_application_first_party_vulnerabilities_aws_application_first_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["aws_application_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      awsApplicationThirdPartyVulnerabilitiesByTheirAwsApplicationId: {
        localCodec: registryConfig_pgCodecs_awsApplications_awsApplications,
        remoteResourceOptions: registryConfig_pgResources_aws_application_third_party_vulnerabilities_aws_application_third_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["aws_application_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    firstPartyVulnerabilities: Object.assign(Object.create(null), {
      awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId: {
        localCodec: registryConfig_pgCodecs_firstPartyVulnerabilities_firstPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_aws_application_first_party_vulnerabilities_aws_application_first_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["first_party_vulnerability_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId: {
        localCodec: registryConfig_pgCodecs_firstPartyVulnerabilities_firstPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_gcp_application_first_party_vulnerabilities_gcp_application_first_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["first_party_vulnerability_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    gcpApplicationFirstPartyVulnerabilities: Object.assign(Object.create(null), {
      firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId: {
        localCodec: registryConfig_pgCodecs_gcpApplicationFirstPartyVulnerabilities_gcpApplicationFirstPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_first_party_vulnerabilities_first_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["first_party_vulnerability_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      gcpApplicationsByMyGcpApplicationId: {
        localCodec: registryConfig_pgCodecs_gcpApplicationFirstPartyVulnerabilities_gcpApplicationFirstPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_gcp_applications_gcp_applications,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["gcp_application_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    gcpApplicationThirdPartyVulnerabilities: Object.assign(Object.create(null), {
      thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId: {
        localCodec: registryConfig_pgCodecs_gcpApplicationThirdPartyVulnerabilities_gcpApplicationThirdPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_third_party_vulnerabilities_third_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["third_party_vulnerability_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      gcpApplicationsByMyGcpApplicationId: {
        localCodec: registryConfig_pgCodecs_gcpApplicationThirdPartyVulnerabilities_gcpApplicationThirdPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_gcp_applications_gcp_applications,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["gcp_application_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    gcpApplications: Object.assign(Object.create(null), {
      organizationsByMyOrganizationId: {
        localCodec: registryConfig_pgCodecs_gcpApplications_gcpApplications,
        remoteResourceOptions: registryConfig_pgResources_organizations_organizations,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["organization_id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      peopleByMyPersonId: {
        localCodec: registryConfig_pgCodecs_gcpApplications_gcpApplications,
        remoteResourceOptions: registryConfig_pgResources_people_people,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["person_id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      gcpApplicationFirstPartyVulnerabilitiesByTheirGcpApplicationId: {
        localCodec: registryConfig_pgCodecs_gcpApplications_gcpApplications,
        remoteResourceOptions: registryConfig_pgResources_gcp_application_first_party_vulnerabilities_gcp_application_first_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["gcp_application_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      gcpApplicationThirdPartyVulnerabilitiesByTheirGcpApplicationId: {
        localCodec: registryConfig_pgCodecs_gcpApplications_gcpApplications,
        remoteResourceOptions: registryConfig_pgResources_gcp_application_third_party_vulnerabilities_gcp_application_third_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["gcp_application_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    logEntries: Object.assign(Object.create(null), {
      organizationsByMyOrganizationId: {
        localCodec: registryConfig_pgCodecs_logEntries_logEntries,
        remoteResourceOptions: registryConfig_pgResources_organizations_organizations,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["organization_id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      peopleByMyPersonId: {
        localCodec: registryConfig_pgCodecs_logEntries_logEntries,
        remoteResourceOptions: registryConfig_pgResources_people_people,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["person_id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    organizations: Object.assign(Object.create(null), {
      logEntriesByTheirOrganizationId: {
        localCodec: registryConfig_pgCodecs_organizations_organizations,
        remoteResourceOptions: registryConfig_pgResources_log_entries_log_entries,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      awsApplicationsByTheirOrganizationId: {
        localCodec: registryConfig_pgCodecs_organizations_organizations,
        remoteResourceOptions: registryConfig_pgResources_aws_applications_aws_applications,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      gcpApplicationsByTheirOrganizationId: {
        localCodec: registryConfig_pgCodecs_organizations_organizations,
        remoteResourceOptions: registryConfig_pgResources_gcp_applications_gcp_applications,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    people: Object.assign(Object.create(null), {
      logEntriesByTheirPersonId: {
        localCodec: registryConfig_pgCodecs_people_people,
        remoteResourceOptions: registryConfig_pgResources_log_entries_log_entries,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["person_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      singleTableItemsByTheirAuthorId: {
        localCodec: registryConfig_pgCodecs_people_people,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["author_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemsByTheirAuthorId: {
        localCodec: registryConfig_pgCodecs_people_people,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["author_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      awsApplicationsByTheirPersonId: {
        localCodec: registryConfig_pgCodecs_people_people,
        remoteResourceOptions: registryConfig_pgResources_aws_applications_aws_applications,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["person_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      gcpApplicationsByTheirPersonId: {
        localCodec: registryConfig_pgCodecs_people_people,
        remoteResourceOptions: registryConfig_pgResources_gcp_applications_gcp_applications,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["person_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    priorities: Object.assign(Object.create(null), {
      singleTableItemsByTheirPriorityId: {
        localCodec: registryConfig_pgCodecs_priorities_priorities,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["priority_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    relationalChecklistItems: Object.assign(Object.create(null), {
      relationalItemsByMyChecklistItemItemId: {
        localCodec: registryConfig_pgCodecs_relationalChecklistItems_relationalChecklistItems,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["checklist_item_item_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    relationalChecklists: Object.assign(Object.create(null), {
      relationalItemsByMyChecklistItemId: {
        localCodec: registryConfig_pgCodecs_relationalChecklists_relationalChecklists,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["checklist_item_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    relationalDividers: Object.assign(Object.create(null), {
      relationalItemsByMyDividerItemId: {
        localCodec: registryConfig_pgCodecs_relationalDividers_relationalDividers,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["divider_item_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    relationalItemRelationCompositePks: Object.assign(Object.create(null), {
      relationalItemsByMyChildId: {
        localCodec: registryConfig_pgCodecs_relationalItemRelationCompositePks_relationalItemRelationCompositePks,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["child_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemsByMyParentId: {
        localCodec: registryConfig_pgCodecs_relationalItemRelationCompositePks_relationalItemRelationCompositePks,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["parent_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    relationalItemRelations: Object.assign(Object.create(null), {
      relationalItemsByMyChildId: {
        localCodec: registryConfig_pgCodecs_relationalItemRelations_relationalItemRelations,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["child_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemsByMyParentId: {
        localCodec: registryConfig_pgCodecs_relationalItemRelations_relationalItemRelations,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["parent_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    relationalItems: Object.assign(Object.create(null), {
      peopleByMyAuthorId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_people_people,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["author_id"],
        remoteAttributes: ["person_id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemsByMyParentId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["parent_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalTopicsByMyRootTopicId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_topics_relational_topics,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["root_topic_id"],
        remoteAttributes: ["topic_item_id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemsByTheirParentId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["parent_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalTopicsByTheirTopicItemId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_topics_relational_topics,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["topic_item_id"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalPostsByTheirPostItemId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_posts_relational_posts,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["post_item_id"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalDividersByTheirDividerItemId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_dividers_relational_dividers,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["divider_item_id"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalChecklistsByTheirChecklistItemId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_checklists_relational_checklists,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["checklist_item_id"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalChecklistItemsByTheirChecklistItemItemId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_checklist_items_relational_checklist_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["checklist_item_item_id"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemRelationsByTheirChildId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_item_relations_relational_item_relations,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["child_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemRelationsByTheirParentId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_item_relations_relational_item_relations,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["parent_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemRelationCompositePksByTheirChildId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_item_relation_composite_pks_relational_item_relation_composite_pks,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["child_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemRelationCompositePksByTheirParentId: {
        localCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
        remoteResourceOptions: registryConfig_pgResources_relational_item_relation_composite_pks_relational_item_relation_composite_pks,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["parent_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    relationalPosts: Object.assign(Object.create(null), {
      relationalItemsByMyPostItemId: {
        localCodec: registryConfig_pgCodecs_relationalPosts_relationalPosts,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["post_item_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    relationalTopics: Object.assign(Object.create(null), {
      relationalItemsByMyTopicItemId: {
        localCodec: registryConfig_pgCodecs_relationalTopics_relationalTopics,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["topic_item_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      relationalItemsByTheirRootTopicId: {
        localCodec: registryConfig_pgCodecs_relationalTopics_relationalTopics,
        remoteResourceOptions: registryConfig_pgResources_relational_items_relational_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["topic_item_id"],
        remoteAttributes: ["root_topic_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    singleTableItemRelationCompositePks: Object.assign(Object.create(null), {
      singleTableItemsByMyChildId: {
        localCodec: registryConfig_pgCodecs_singleTableItemRelationCompositePks_singleTableItemRelationCompositePks,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["child_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      singleTableItemsByMyParentId: {
        localCodec: registryConfig_pgCodecs_singleTableItemRelationCompositePks_singleTableItemRelationCompositePks,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["parent_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    singleTableItemRelations: Object.assign(Object.create(null), {
      singleTableItemsByMyChildId: {
        localCodec: registryConfig_pgCodecs_singleTableItemRelations_singleTableItemRelations,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["child_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      singleTableItemsByMyParentId: {
        localCodec: registryConfig_pgCodecs_singleTableItemRelations_singleTableItemRelations,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["parent_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    singleTableItems: Object.assign(Object.create(null), {
      peopleByMyAuthorId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_people_people,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["author_id"],
        remoteAttributes: ["person_id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      singleTableItemsByMyParentId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["parent_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      prioritiesByMyPriorityId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_priorities_priorities,
        localCodecPolymorphicTypes: ["POST", "CHECKLIST_ITEM"],
        localAttributes: ["priority_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      singleTableItemsByMyRootTopicId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["root_topic_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: ["-*"]
          }
        }
      },
      singleTableItemsByTheirParentId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["parent_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      singleTableItemsByTheirRootTopicId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_single_table_items_single_table_items,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["root_topic_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: ["-*"]
          }
        }
      },
      singleTableItemRelationsByTheirChildId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_single_table_item_relations_single_table_item_relations,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["child_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      singleTableItemRelationsByTheirParentId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_single_table_item_relations_single_table_item_relations,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["parent_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      singleTableItemRelationCompositePksByTheirChildId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_single_table_item_relation_composite_pks_single_table_item_relation_composite_pks,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["child_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      singleTableItemRelationCompositePksByTheirParentId: {
        localCodec: registryConfig_pgCodecs_singleTableItems_singleTableItems,
        remoteResourceOptions: registryConfig_pgResources_single_table_item_relation_composite_pks_single_table_item_relation_composite_pks,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["parent_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    thirdPartyVulnerabilities: Object.assign(Object.create(null), {
      awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId: {
        localCodec: registryConfig_pgCodecs_thirdPartyVulnerabilities_thirdPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_aws_application_third_party_vulnerabilities_aws_application_third_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["third_party_vulnerability_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId: {
        localCodec: registryConfig_pgCodecs_thirdPartyVulnerabilities_thirdPartyVulnerabilities,
        remoteResourceOptions: registryConfig_pgResources_gcp_application_third_party_vulnerabilities_gcp_application_third_party_vulnerabilities,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["third_party_vulnerability_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    })
  })
};
const registry = makeRegistry(registryConfig);
const resource_single_table_itemsPgResource = registry.pgResources["single_table_items"];
const handler4 = {
  typeName: "SingleTableTopic",
  codec: {
    name: "base64JSON",
    encode(value) {
      return Buffer.from(JSON.stringify(value), "utf8").toString("base64");
    },
    decode(value) {
      return JSON.parse(Buffer.from(value, "base64").toString("utf8"));
    }
  },
  deprecationReason: undefined,
  plan($record) {
    return list([constant("SingleTableTopic", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return resource_single_table_itemsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "SingleTableTopic";
  }
};
const nodeIdCodecs = Object.assign(Object.create(null), {
  raw: {
    name: "raw",
    encode(value) {
      return typeof value === "string" ? value : null;
    },
    decode(value) {
      return typeof value === "string" ? value : null;
    }
  },
  base64JSON: handler4.codec,
  pipeString: {
    name: "pipeString",
    encode(value) {
      return Array.isArray(value) ? value.join("|") : null;
    },
    decode(value) {
      return typeof value === "string" ? value.split("|") : null;
    }
  }
});
const otherSource_peoplePgResource = registry.pgResources["people"];
function SingleTableTopic_singleTableItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableTopic_singleTableItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableTopic_singleTableItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableTopic_singleTableItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableTopic_singleTableItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const applyOrderToPlan = ($select, $value, TableOrderByType) => {
  const val = $value.eval();
  if (val == null) {
    return;
  }
  if (!Array.isArray(val)) {
    throw new Error("Invalid!");
  }
  val.forEach(order => {
    const config = getEnumValueConfig(TableOrderByType, order);
    const plan = config?.extensions?.grafast?.applyPlan;
    if (typeof plan !== "function") {
      console.error(`Internal server error: invalid orderBy configuration: expected function, but received ${inspect(plan)}`);
      throw new SafeError("Internal server error: invalid orderBy configuration");
    }
    plan($select);
  });
};
const otherSource_single_table_item_relationsPgResource = registry.pgResources["single_table_item_relations"];
function SingleTableTopic_singleTableItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableTopic_singleTableItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableTopic_singleTableItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const otherSource_single_table_item_relation_composite_pksPgResource = registry.pgResources["single_table_item_relation_composite_pks"];
function SingleTableTopic_singleTableItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableTopic_singleTableItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableTopic_singleTableItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableTopic_singleTableItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const handler2 = {
  typeName: "Person",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("people", false), $record.get("person_id")]);
  },
  getSpec($list) {
    return {
      person_id: access($list, [1])
    };
  },
  get(spec) {
    return otherSource_peoplePgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "people";
  }
};
const otherSource_log_entriesPgResource = registry.pgResources["log_entries"];
function Person_logEntriesByPersonId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_logEntriesByPersonId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_logEntriesByPersonId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_logEntriesByPersonId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_logEntriesByPersonId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Person_singleTableItemsByAuthorId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_singleTableItemsByAuthorId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_singleTableItemsByAuthorId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_singleTableItemsByAuthorId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_singleTableItemsByAuthorId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const otherSource_relational_itemsPgResource = registry.pgResources["relational_items"];
function Person_relationalItemsByAuthorId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_relationalItemsByAuthorId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_relationalItemsByAuthorId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_relationalItemsByAuthorId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_relationalItemsByAuthorId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const otherSource_aws_applicationsPgResource = registry.pgResources["aws_applications"];
function Person_awsApplicationsByPersonId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_awsApplicationsByPersonId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_awsApplicationsByPersonId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_awsApplicationsByPersonId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_awsApplicationsByPersonId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const otherSource_gcp_applicationsPgResource = registry.pgResources["gcp_applications"];
function Person_gcpApplicationsByPersonId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_gcpApplicationsByPersonId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_gcpApplicationsByPersonId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_gcpApplicationsByPersonId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_gcpApplicationsByPersonId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const members = [{
  resource: otherSource_aws_applicationsPgResource,
  typeName: "AwsApplication",
  path: []
}, {
  resource: otherSource_gcp_applicationsPgResource,
  typeName: "GcpApplication",
  path: []
}];
const paths = [{
  resource: otherSource_aws_applicationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "awsApplicationsByTheirPersonId",
    localAttributes: registryConfig.pgRelations.people.awsApplicationsByTheirPersonId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.people.awsApplicationsByTheirPersonId.remoteAttributes,
    resource: otherSource_aws_applicationsPgResource,
    isUnique: false
  }]
}, {
  resource: otherSource_gcp_applicationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "gcpApplicationsByTheirPersonId",
    localAttributes: registryConfig.pgRelations.people.gcpApplicationsByTheirPersonId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.people.gcpApplicationsByTheirPersonId.remoteAttributes,
    resource: otherSource_gcp_applicationsPgResource,
    isUnique: false
  }]
}];
const resourceByTypeName = Object.assign(Object.create(null), {
  AwsApplication: otherSource_aws_applicationsPgResource,
  GcpApplication: otherSource_gcp_applicationsPgResource
});
function Person_applications_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_applications_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_applications_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_applications_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_applications_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function LogEntriesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function LogEntriesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function LogEntriesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const handler3 = {
  typeName: "LogEntry",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("log_entries", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return otherSource_log_entriesPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "log_entries";
  }
};
const otherSource_organizationsPgResource = registry.pgResources["organizations"];
const attributes19 = {};
const members2 = [{
  resource: otherSource_peoplePgResource,
  typeName: "Person",
  path: []
}, {
  resource: otherSource_organizationsPgResource,
  typeName: "Organization",
  path: []
}];
const paths2 = [{
  resource: otherSource_peoplePgResource,
  hasReferencee: false,
  isUnique: true,
  layers: [{
    relationName: "peopleByMyPersonId",
    localAttributes: registryConfig.pgRelations.logEntries.peopleByMyPersonId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.logEntries.peopleByMyPersonId.remoteAttributes,
    resource: otherSource_peoplePgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_organizationsPgResource,
  hasReferencee: false,
  isUnique: true,
  layers: [{
    relationName: "organizationsByMyOrganizationId",
    localAttributes: registryConfig.pgRelations.logEntries.organizationsByMyOrganizationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.logEntries.organizationsByMyOrganizationId.remoteAttributes,
    resource: otherSource_organizationsPgResource,
    isUnique: true
  }]
}];
const resourceByTypeName2 = Object.assign(Object.create(null), {
  Person: otherSource_peoplePgResource,
  Organization: otherSource_organizationsPgResource
});
const handler4 = {
  typeName: "Organization",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("organizations", false), $record.get("organization_id")]);
  },
  getSpec($list) {
    return {
      organization_id: access($list, [1])
    };
  },
  get(spec) {
    return otherSource_organizationsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "organizations";
  }
};
function Organization_logEntriesByOrganizationId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Organization_logEntriesByOrganizationId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Organization_logEntriesByOrganizationId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Organization_logEntriesByOrganizationId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Organization_logEntriesByOrganizationId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Organization_awsApplicationsByOrganizationId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Organization_awsApplicationsByOrganizationId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Organization_awsApplicationsByOrganizationId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Organization_awsApplicationsByOrganizationId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Organization_awsApplicationsByOrganizationId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Organization_gcpApplicationsByOrganizationId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Organization_gcpApplicationsByOrganizationId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Organization_gcpApplicationsByOrganizationId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Organization_gcpApplicationsByOrganizationId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Organization_gcpApplicationsByOrganizationId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function AwsApplicationsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function AwsApplicationsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function AwsApplicationsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const handler5 = {
  typeName: "AwsApplication",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("aws_applications", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return otherSource_aws_applicationsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "aws_applications";
  }
};
const members_0_resource_aws_application_first_party_vulnerabilitiesPgResource = registry.pgResources["aws_application_first_party_vulnerabilities"];
const members_1_resource_aws_application_third_party_vulnerabilitiesPgResource = registry.pgResources["aws_application_third_party_vulnerabilities"];
const members3 = [{
  resource: members_0_resource_aws_application_first_party_vulnerabilitiesPgResource,
  typeName: "FirstPartyVulnerability",
  path: [{
    relationName: "firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId"
  }]
}, {
  resource: members_1_resource_aws_application_third_party_vulnerabilitiesPgResource,
  typeName: "ThirdPartyVulnerability",
  path: [{
    relationName: "thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId"
  }]
}];
const paths_0_resource_first_party_vulnerabilitiesPgResource = registry.pgResources["first_party_vulnerabilities"];
const paths_1_resource_third_party_vulnerabilitiesPgResource = registry.pgResources["third_party_vulnerabilities"];
const paths3 = [{
  resource: paths_0_resource_first_party_vulnerabilitiesPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "awsApplicationFirstPartyVulnerabilitiesByTheirAwsApplicationId",
    localAttributes: registryConfig.pgRelations.awsApplications.awsApplicationFirstPartyVulnerabilitiesByTheirAwsApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplications.awsApplicationFirstPartyVulnerabilitiesByTheirAwsApplicationId.remoteAttributes,
    resource: members_0_resource_aws_application_first_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.awsApplicationFirstPartyVulnerabilities.firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplicationFirstPartyVulnerabilities.firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId.remoteAttributes,
    resource: paths_0_resource_first_party_vulnerabilitiesPgResource,
    isUnique: true
  }]
}, {
  resource: paths_1_resource_third_party_vulnerabilitiesPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "awsApplicationThirdPartyVulnerabilitiesByTheirAwsApplicationId",
    localAttributes: registryConfig.pgRelations.awsApplications.awsApplicationThirdPartyVulnerabilitiesByTheirAwsApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplications.awsApplicationThirdPartyVulnerabilitiesByTheirAwsApplicationId.remoteAttributes,
    resource: members_1_resource_aws_application_third_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.awsApplicationThirdPartyVulnerabilities.thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplicationThirdPartyVulnerabilities.thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId.remoteAttributes,
    resource: paths_1_resource_third_party_vulnerabilitiesPgResource,
    isUnique: true
  }]
}];
const resourceByTypeName3 = Object.assign(Object.create(null), {
  FirstPartyVulnerability: paths_0_resource_first_party_vulnerabilitiesPgResource,
  ThirdPartyVulnerability: paths_1_resource_third_party_vulnerabilitiesPgResource
});
function AwsApplication_vulnerabilities_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function AwsApplication_vulnerabilities_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function AwsApplication_vulnerabilities_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function AwsApplication_vulnerabilities_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function AwsApplication_vulnerabilities_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const attributes20 = {};
const members4 = [{
  resource: otherSource_peoplePgResource,
  typeName: "Person",
  path: []
}, {
  resource: otherSource_organizationsPgResource,
  typeName: "Organization",
  path: []
}];
const paths4 = [{
  resource: otherSource_peoplePgResource,
  hasReferencee: false,
  isUnique: true,
  layers: [{
    relationName: "peopleByMyPersonId",
    localAttributes: registryConfig.pgRelations.awsApplications.peopleByMyPersonId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplications.peopleByMyPersonId.remoteAttributes,
    resource: otherSource_peoplePgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_organizationsPgResource,
  hasReferencee: false,
  isUnique: true,
  layers: [{
    relationName: "organizationsByMyOrganizationId",
    localAttributes: registryConfig.pgRelations.awsApplications.organizationsByMyOrganizationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplications.organizationsByMyOrganizationId.remoteAttributes,
    resource: otherSource_organizationsPgResource,
    isUnique: true
  }]
}];
const resourceByTypeName4 = Object.assign(Object.create(null), {
  Person: otherSource_peoplePgResource,
  Organization: otherSource_organizationsPgResource
});
function VulnerabilitiesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function VulnerabilitiesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function VulnerabilitiesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ApplicationsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ApplicationsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ApplicationsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PageInfo_hasNextPagePlan($pageInfo) {
  return $pageInfo.hasNextPage();
}
function PageInfo_hasPreviousPagePlan($pageInfo) {
  return $pageInfo.hasPreviousPage();
}
function PersonOrOrganizationConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PersonOrOrganizationConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PersonOrOrganizationConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function GcpApplicationsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function GcpApplicationsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function GcpApplicationsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const handler6 = {
  typeName: "GcpApplication",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("gcp_applications", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return otherSource_gcp_applicationsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "gcp_applications";
  }
};
const members_0_resource_gcp_application_first_party_vulnerabilitiesPgResource = registry.pgResources["gcp_application_first_party_vulnerabilities"];
const members_1_resource_gcp_application_third_party_vulnerabilitiesPgResource = registry.pgResources["gcp_application_third_party_vulnerabilities"];
const members5 = [{
  resource: members_0_resource_gcp_application_first_party_vulnerabilitiesPgResource,
  typeName: "FirstPartyVulnerability",
  path: [{
    relationName: "firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId"
  }]
}, {
  resource: members_1_resource_gcp_application_third_party_vulnerabilitiesPgResource,
  typeName: "ThirdPartyVulnerability",
  path: [{
    relationName: "thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId"
  }]
}];
const paths5 = [{
  resource: paths_0_resource_first_party_vulnerabilitiesPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "gcpApplicationFirstPartyVulnerabilitiesByTheirGcpApplicationId",
    localAttributes: registryConfig.pgRelations.gcpApplications.gcpApplicationFirstPartyVulnerabilitiesByTheirGcpApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplications.gcpApplicationFirstPartyVulnerabilitiesByTheirGcpApplicationId.remoteAttributes,
    resource: members_0_resource_gcp_application_first_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.gcpApplicationFirstPartyVulnerabilities.firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplicationFirstPartyVulnerabilities.firstPartyVulnerabilitiesByMyFirstPartyVulnerabilityId.remoteAttributes,
    resource: paths_0_resource_first_party_vulnerabilitiesPgResource,
    isUnique: true
  }]
}, {
  resource: paths_1_resource_third_party_vulnerabilitiesPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "gcpApplicationThirdPartyVulnerabilitiesByTheirGcpApplicationId",
    localAttributes: registryConfig.pgRelations.gcpApplications.gcpApplicationThirdPartyVulnerabilitiesByTheirGcpApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplications.gcpApplicationThirdPartyVulnerabilitiesByTheirGcpApplicationId.remoteAttributes,
    resource: members_1_resource_gcp_application_third_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.gcpApplicationThirdPartyVulnerabilities.thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplicationThirdPartyVulnerabilities.thirdPartyVulnerabilitiesByMyThirdPartyVulnerabilityId.remoteAttributes,
    resource: paths_1_resource_third_party_vulnerabilitiesPgResource,
    isUnique: true
  }]
}];
const resourceByTypeName5 = Object.assign(Object.create(null), {
  FirstPartyVulnerability: paths_0_resource_first_party_vulnerabilitiesPgResource,
  ThirdPartyVulnerability: paths_1_resource_third_party_vulnerabilitiesPgResource
});
function GcpApplication_vulnerabilities_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function GcpApplication_vulnerabilities_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function GcpApplication_vulnerabilities_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function GcpApplication_vulnerabilities_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function GcpApplication_vulnerabilities_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const attributes21 = {};
const members6 = [{
  resource: otherSource_peoplePgResource,
  typeName: "Person",
  path: []
}, {
  resource: otherSource_organizationsPgResource,
  typeName: "Organization",
  path: []
}];
const paths6 = [{
  resource: otherSource_peoplePgResource,
  hasReferencee: false,
  isUnique: true,
  layers: [{
    relationName: "peopleByMyPersonId",
    localAttributes: registryConfig.pgRelations.gcpApplications.peopleByMyPersonId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplications.peopleByMyPersonId.remoteAttributes,
    resource: otherSource_peoplePgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_organizationsPgResource,
  hasReferencee: false,
  isUnique: true,
  layers: [{
    relationName: "organizationsByMyOrganizationId",
    localAttributes: registryConfig.pgRelations.gcpApplications.organizationsByMyOrganizationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplications.organizationsByMyOrganizationId.remoteAttributes,
    resource: otherSource_organizationsPgResource,
    isUnique: true
  }]
}];
const resourceByTypeName6 = Object.assign(Object.create(null), {
  Person: otherSource_peoplePgResource,
  Organization: otherSource_organizationsPgResource
});
function SingleTableItemsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function SingleTableItemsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function SingleTableItemsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function RelationalItemsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function RelationalItemsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function RelationalItemsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function RelationalItemRelationsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function RelationalItemRelationsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function RelationalItemRelationsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const pgResource_relational_item_relationsPgResource = registry.pgResources["relational_item_relations"];
const handler7 = {
  typeName: "RelationalItemRelation",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("relational_item_relations", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return pgResource_relational_item_relationsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "relational_item_relations";
  }
};
function RelationalItemRelationCompositePksConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function RelationalItemRelationCompositePksConnection_edgesPlan($connection) {
  return $connection.edges();
}
function RelationalItemRelationCompositePksConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const pgResource_relational_item_relation_composite_pksPgResource = registry.pgResources["relational_item_relation_composite_pks"];
const handler8 = {
  typeName: "RelationalItemRelationCompositePk",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("relational_item_relation_composite_pks", false), $record.get("parent_id"), $record.get("child_id")]);
  },
  getSpec($list) {
    return {
      parent_id: access($list, [1]),
      child_id: access($list, [2])
    };
  },
  get(spec) {
    return pgResource_relational_item_relation_composite_pksPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "relational_item_relation_composite_pks";
  }
};
function SingleTableItemRelationsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function SingleTableItemRelationsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function SingleTableItemRelationsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const handler9 = {
  typeName: "SingleTableItemRelation",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("single_table_item_relations", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return otherSource_single_table_item_relationsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "single_table_item_relations";
  }
};
function SingleTableItemRelationCompositePksConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function SingleTableItemRelationCompositePksConnection_edgesPlan($connection) {
  return $connection.edges();
}
function SingleTableItemRelationCompositePksConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const handler10 = {
  typeName: "SingleTableItemRelationCompositePk",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("single_table_item_relation_composite_pks", false), $record.get("parent_id"), $record.get("child_id")]);
  },
  getSpec($list) {
    return {
      parent_id: access($list, [1]),
      child_id: access($list, [2])
    };
  },
  get(spec) {
    return otherSource_single_table_item_relation_composite_pksPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "single_table_item_relation_composite_pks";
  }
};
const handler11 = {
  typeName: "SingleTablePost",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("SingleTablePost", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return resource_single_table_itemsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "SingleTablePost";
  }
};
const otherSource_prioritiesPgResource = registry.pgResources["priorities"];
function SingleTablePost_singleTableItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTablePost_singleTableItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTablePost_singleTableItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTablePost_singleTableItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTablePost_singleTableItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTablePost_singleTableItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTablePost_singleTableItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTablePost_singleTableItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTablePost_singleTableItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTablePost_singleTableItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTablePost_singleTableItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTablePost_singleTableItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTablePost_singleTableItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTablePost_singleTableItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTablePost_singleTableItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTablePost_singleTableItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const handler12 = {
  typeName: "Priority",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("priorities", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return otherSource_prioritiesPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "priorities";
  }
};
function Priority_singleTableItemsByPriorityId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Priority_singleTableItemsByPriorityId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Priority_singleTableItemsByPriorityId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Priority_singleTableItemsByPriorityId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Priority_singleTableItemsByPriorityId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const handler13 = {
  typeName: "SingleTableDivider",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("SingleTableDivider", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return resource_single_table_itemsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "SingleTableDivider";
  }
};
function SingleTableDivider_singleTableItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableDivider_singleTableItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableDivider_singleTableItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableDivider_singleTableItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableDivider_singleTableItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableDivider_singleTableItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const handler14 = {
  typeName: "SingleTableChecklist",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("SingleTableChecklist", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return resource_single_table_itemsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "SingleTableChecklist";
  }
};
function SingleTableChecklist_singleTableItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklist_singleTableItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklist_singleTableItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklist_singleTableItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklist_singleTableItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklist_singleTableItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const handler15 = {
  typeName: "SingleTableChecklistItem",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("SingleTableChecklistItem", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: access($list, [1])
    };
  },
  get(spec) {
    return resource_single_table_itemsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "SingleTableChecklistItem";
  }
};
function SingleTableChecklistItem_singleTableItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklistItem_singleTableItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const pgResource_relational_topicsPgResource = registry.pgResources["relational_topics"];
const handler16 = {
  typeName: "RelationalTopic",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("relational_topics", false), $record.get("topic_item_id")]);
  },
  getSpec($list) {
    return {
      topic_item_id: access($list, [1])
    };
  },
  get(spec) {
    return pgResource_relational_topicsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "relational_topics";
  }
};
function RelationalTopic_relationalItemsByRootTopicId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalTopic_relationalItemsByRootTopicId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalTopic_relationalItemsByRootTopicId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalTopic_relationalItemsByRootTopicId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalTopic_relationalItemsByRootTopicId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalTopic_relationalItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalTopic_relationalItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalTopic_relationalItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalTopic_relationalItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalTopic_relationalItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const relational_posts_relational_postsPgResource = registry.pgResources["relational_posts"];
const relational_dividers_relational_dividersPgResource = registry.pgResources["relational_dividers"];
const relational_checklists_relational_checklistsPgResource = registry.pgResources["relational_checklists"];
const relational_checklist_items_relational_checklist_itemsPgResource = registry.pgResources["relational_checklist_items"];
function RelationalTopic_relationalItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalTopic_relationalItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalTopic_relationalItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalTopic_relationalItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalTopic_relationalItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalTopic_relationalItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalTopic_relationalItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalTopic_relationalItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalTopic_relationalItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalTopic_relationalItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalTopic_relationalItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const handler17 = {
  typeName: "RelationalPost",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("relational_posts", false), $record.get("post_item_id")]);
  },
  getSpec($list) {
    return {
      post_item_id: access($list, [1])
    };
  },
  get(spec) {
    return relational_posts_relational_postsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "relational_posts";
  }
};
function RelationalPost_relationalItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalPost_relationalItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalPost_relationalItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalPost_relationalItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalPost_relationalItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalPost_relationalItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalPost_relationalItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalPost_relationalItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalPost_relationalItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalPost_relationalItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalPost_relationalItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalPost_relationalItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalPost_relationalItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalPost_relationalItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalPost_relationalItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalPost_relationalItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const handler18 = {
  typeName: "RelationalDivider",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("relational_dividers", false), $record.get("divider_item_id")]);
  },
  getSpec($list) {
    return {
      divider_item_id: access($list, [1])
    };
  },
  get(spec) {
    return relational_dividers_relational_dividersPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "relational_dividers";
  }
};
function RelationalDivider_relationalItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalDivider_relationalItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalDivider_relationalItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalDivider_relationalItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalDivider_relationalItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalDivider_relationalItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalDivider_relationalItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalDivider_relationalItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalDivider_relationalItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalDivider_relationalItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalDivider_relationalItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalDivider_relationalItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalDivider_relationalItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalDivider_relationalItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalDivider_relationalItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalDivider_relationalItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const handler19 = {
  typeName: "RelationalChecklist",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("relational_checklists", false), $record.get("checklist_item_id")]);
  },
  getSpec($list) {
    return {
      checklist_item_id: access($list, [1])
    };
  },
  get(spec) {
    return relational_checklists_relational_checklistsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "relational_checklists";
  }
};
function RelationalChecklist_relationalItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklist_relationalItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklist_relationalItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklist_relationalItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklist_relationalItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalChecklist_relationalItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklist_relationalItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklist_relationalItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklist_relationalItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklist_relationalItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalChecklist_relationalItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklist_relationalItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklist_relationalItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklist_relationalItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklist_relationalItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklist_relationalItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const handler20 = {
  typeName: "RelationalChecklistItem",
  codec: handler4.codec,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("relational_checklist_items", false), $record.get("checklist_item_item_id")]);
  },
  getSpec($list) {
    return {
      checklist_item_item_id: access($list, [1])
    };
  },
  get(spec) {
    return relational_checklist_items_relational_checklist_itemsPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "relational_checklist_items";
  }
};
function RelationalChecklistItem_relationalItemsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklistItem_relationalItemsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklistItem_relationalItemsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklistItem_relationalItemsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklistItem_relationalItemsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationsByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByChildId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByChildId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByChildId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByChildId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByChildId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByParentId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByParentId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByParentId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByParentId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function RelationalChecklistItem_relationalItemRelationCompositePksByParentId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_queryPlan() {
  return rootValue();
}
const handler21 = {
  typeName: "Query",
  codec: nodeIdCodecs.raw,
  match(specifier) {
    return specifier === "query";
  },
  getSpec() {
    return "irrelevant";
  },
  get() {
    return rootValue();
  },
  plan() {
    return constant`query`;
  }
};
const nodeIdHandlerByTypeName = Object.assign(Object.create(null), {
  Query: handler21,
  SingleTableTopic: handler4,
  SingleTablePost: handler11,
  SingleTableDivider: handler13,
  SingleTableChecklist: handler14,
  SingleTableChecklistItem: handler15,
  Organization: handler4,
  Person: handler2,
  Priority: handler12,
  RelationalChecklist: handler19,
  RelationalItemRelationCompositePk: handler8,
  RelationalTopic: handler16,
  SingleTableItemRelationCompositePk: handler10,
  RelationalChecklistItem: handler20,
  RelationalDivider: handler18,
  RelationalItemRelation: handler7,
  SingleTableItemRelation: handler9,
  LogEntry: handler3,
  RelationalPost: handler17,
  FirstPartyVulnerability: {
    typeName: "FirstPartyVulnerability",
    codec: handler4.codec,
    deprecationReason: undefined,
    plan($record) {
      return list([constant("first_party_vulnerabilities", false), $record.get("id")]);
    },
    getSpec($list) {
      return {
        id: access($list, [1])
      };
    },
    get(spec) {
      return paths_0_resource_first_party_vulnerabilitiesPgResource.get(spec);
    },
    match(obj) {
      return obj[0] === "first_party_vulnerabilities";
    }
  },
  ThirdPartyVulnerability: {
    typeName: "ThirdPartyVulnerability",
    codec: handler4.codec,
    deprecationReason: undefined,
    plan($record) {
      return list([constant("third_party_vulnerabilities", false), $record.get("id")]);
    },
    getSpec($list) {
      return {
        id: access($list, [1])
      };
    },
    get(spec) {
      return paths_1_resource_third_party_vulnerabilitiesPgResource.get(spec);
    },
    match(obj) {
      return obj[0] === "third_party_vulnerabilities";
    }
  },
  AwsApplication: handler5,
  GcpApplication: handler6
});
const argDetailsSimple = [];
const makeArgs = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_all_single_tablesPgResource = registry.pgResources["all_single_tables"];
const getSelectPlanFromParentAndArgs = ($root, args, _info) => {
  const selectArgs = makeArgs(args);
  return resource_all_single_tablesPgResource.execute(selectArgs);
};
function Query_allSingleTablesPlan($parent, args, info) {
  const $select = getSelectPlanFromParentAndArgs($parent, args, info);
  return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
}
function Query_allSingleTables_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allSingleTables_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allSingleTables_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allSingleTables_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allSingleTables_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple2 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs2 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple2[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_get_single_table_topic_by_idPgResource = registry.pgResources["get_single_table_topic_by_id"];
function specForHandler(handler) {
  function spec(nodeId) {
    // We only want to return the specifier if it matches
    // this handler; otherwise return null.
    try {
      const specifier = handler.codec.decode(nodeId);
      if (handler.match(specifier)) {
        return specifier;
      }
    } catch {
      // Ignore errors
    }
    return null;
  }
  spec.displayName = `specifier_${handler.typeName}_${handler.codec.name}`;
  spec.isSyncAndSafe = true; // Optimization
  return spec;
}
const fetcher = (() => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})();
const fetcher2 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler11);
const fetcher3 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler13);
const fetcher4 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler14);
const fetcher5 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler15);
const fetcher6 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler4);
const fetcher7 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler2);
const fetcher8 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler12);
const fetcher9 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler19);
const fetcher10 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler8);
const fetcher11 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler16);
const fetcher12 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler10);
const fetcher13 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler20);
const fetcher14 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler18);
const fetcher15 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler7);
const fetcher16 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler9);
const fetcher17 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler3);
const fetcher18 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler17);
const fetcher19 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(nodeIdHandlerByTypeName.FirstPartyVulnerability);
const fetcher20 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(nodeIdHandlerByTypeName.ThirdPartyVulnerability);
const fetcher21 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler5);
const fetcher22 = (handler => {
  const fn = $nodeId => {
    const $decoded = lambda($nodeId, specForHandler(handler));
    return handler.get(handler.getSpec($decoded));
  };
  fn.deprecationReason = handler.deprecationReason;
  return fn;
})(handler6);
const members7 = [{
  resource: paths_0_resource_first_party_vulnerabilitiesPgResource,
  typeName: "FirstPartyVulnerability"
}, {
  resource: paths_1_resource_third_party_vulnerabilitiesPgResource,
  typeName: "ThirdPartyVulnerability"
}];
const resourceByTypeName7 = Object.assign(Object.create(null), {
  FirstPartyVulnerability: paths_0_resource_first_party_vulnerabilitiesPgResource,
  ThirdPartyVulnerability: paths_1_resource_third_party_vulnerabilitiesPgResource
});
function Query_allVulnerabilities_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allVulnerabilities_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allVulnerabilities_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allVulnerabilities_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allVulnerabilities_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const members8 = [{
  resource: otherSource_aws_applicationsPgResource,
  typeName: "AwsApplication"
}, {
  resource: otherSource_gcp_applicationsPgResource,
  typeName: "GcpApplication"
}];
const resourceByTypeName8 = Object.assign(Object.create(null), {
  AwsApplication: otherSource_aws_applicationsPgResource,
  GcpApplication: otherSource_gcp_applicationsPgResource
});
function Query_allApplications_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allApplications_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allApplications_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allApplications_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allApplications_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const members9 = [];
const resourceByTypeName9 = Object.create(null);
function Query_allZeroImplementations_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allZeroImplementations_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allZeroImplementations_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allZeroImplementations_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allZeroImplementations_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allOrganizations_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allOrganizations_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allOrganizations_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allOrganizations_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allOrganizations_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allPeople_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allPeople_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allPeople_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allPeople_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allPeople_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allPriorities_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allPriorities_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allPriorities_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allPriorities_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allPriorities_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allRelationalChecklists_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allRelationalChecklists_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allRelationalChecklists_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allRelationalChecklists_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allRelationalChecklists_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allRelationalItemRelationCompositePks_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allRelationalItemRelationCompositePks_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allRelationalItemRelationCompositePks_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allRelationalItemRelationCompositePks_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allRelationalItemRelationCompositePks_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allRelationalTopics_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allRelationalTopics_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allRelationalTopics_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allRelationalTopics_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allRelationalTopics_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allSingleTableItemRelationCompositePks_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allSingleTableItemRelationCompositePks_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allSingleTableItemRelationCompositePks_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allSingleTableItemRelationCompositePks_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allSingleTableItemRelationCompositePks_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allRelationalChecklistItems_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allRelationalChecklistItems_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allRelationalChecklistItems_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allRelationalChecklistItems_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allRelationalChecklistItems_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allRelationalDividers_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allRelationalDividers_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allRelationalDividers_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allRelationalDividers_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allRelationalDividers_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allRelationalItemRelations_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allRelationalItemRelations_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allRelationalItemRelations_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allRelationalItemRelations_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allRelationalItemRelations_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allSingleTableItemRelations_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allSingleTableItemRelations_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allSingleTableItemRelations_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allSingleTableItemRelations_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allSingleTableItemRelations_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allLogEntries_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allLogEntries_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allLogEntries_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allLogEntries_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allLogEntries_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allRelationalPosts_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allRelationalPosts_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allRelationalPosts_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allRelationalPosts_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allRelationalPosts_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allFirstPartyVulnerabilities_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allFirstPartyVulnerabilities_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allFirstPartyVulnerabilities_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allFirstPartyVulnerabilities_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allFirstPartyVulnerabilities_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allThirdPartyVulnerabilities_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allThirdPartyVulnerabilities_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allThirdPartyVulnerabilities_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allThirdPartyVulnerabilities_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allThirdPartyVulnerabilities_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allAwsApplications_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allAwsApplications_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allAwsApplications_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allAwsApplications_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allAwsApplications_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allGcpApplications_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allGcpApplications_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allGcpApplications_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allGcpApplications_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allGcpApplications_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allSingleTableItems_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allSingleTableItems_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allSingleTableItems_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allSingleTableItems_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allSingleTableItems_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allRelationalItems_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allRelationalItems_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allRelationalItems_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allRelationalItems_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allRelationalItems_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const members10 = [{
  resource: members_0_resource_aws_application_first_party_vulnerabilitiesPgResource,
  typeName: "AwsApplication",
  path: [{
    relationName: "awsApplicationsByMyAwsApplicationId"
  }]
}, {
  resource: members_0_resource_gcp_application_first_party_vulnerabilitiesPgResource,
  typeName: "GcpApplication",
  path: [{
    relationName: "gcpApplicationsByMyGcpApplicationId"
  }]
}];
const paths7 = [{
  resource: otherSource_aws_applicationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.remoteAttributes,
    resource: members_0_resource_aws_application_first_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "awsApplicationsByMyAwsApplicationId",
    localAttributes: registryConfig.pgRelations.awsApplicationFirstPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplicationFirstPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.remoteAttributes,
    resource: otherSource_aws_applicationsPgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_gcp_applicationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.remoteAttributes,
    resource: members_0_resource_gcp_application_first_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "gcpApplicationsByMyGcpApplicationId",
    localAttributes: registryConfig.pgRelations.gcpApplicationFirstPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplicationFirstPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.remoteAttributes,
    resource: otherSource_gcp_applicationsPgResource,
    isUnique: true
  }]
}];
const resourceByTypeName10 = Object.assign(Object.create(null), {
  AwsApplication: otherSource_aws_applicationsPgResource,
  GcpApplication: otherSource_gcp_applicationsPgResource
});
function FirstPartyVulnerability_applications_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function FirstPartyVulnerability_applications_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function FirstPartyVulnerability_applications_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function FirstPartyVulnerability_applications_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function FirstPartyVulnerability_applications_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const attributes22 = {};
const members11 = [{
  resource: members_0_resource_aws_application_first_party_vulnerabilitiesPgResource,
  typeName: "Person",
  path: [{
    relationName: "awsApplicationsByMyAwsApplicationId"
  }, {
    relationName: "peopleByMyPersonId"
  }]
}, {
  resource: members_0_resource_aws_application_first_party_vulnerabilitiesPgResource,
  typeName: "Organization",
  path: [{
    relationName: "awsApplicationsByMyAwsApplicationId"
  }, {
    relationName: "organizationsByMyOrganizationId"
  }]
}, {
  resource: members_0_resource_gcp_application_first_party_vulnerabilitiesPgResource,
  typeName: "Person",
  path: [{
    relationName: "gcpApplicationsByMyGcpApplicationId"
  }, {
    relationName: "peopleByMyPersonId"
  }]
}, {
  resource: members_0_resource_gcp_application_first_party_vulnerabilitiesPgResource,
  typeName: "Organization",
  path: [{
    relationName: "gcpApplicationsByMyGcpApplicationId"
  }, {
    relationName: "organizationsByMyOrganizationId"
  }]
}];
const paths8 = [{
  resource: otherSource_peoplePgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.remoteAttributes,
    resource: members_0_resource_aws_application_first_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "awsApplicationsByMyAwsApplicationId",
    localAttributes: registryConfig.pgRelations.awsApplicationFirstPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplicationFirstPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.remoteAttributes,
    resource: otherSource_aws_applicationsPgResource,
    isUnique: true
  }, {
    relationName: "peopleByMyPersonId",
    localAttributes: registryConfig.pgRelations.awsApplications.peopleByMyPersonId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplications.peopleByMyPersonId.remoteAttributes,
    resource: otherSource_peoplePgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_organizationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.awsApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.remoteAttributes,
    resource: members_0_resource_aws_application_first_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "awsApplicationsByMyAwsApplicationId",
    localAttributes: registryConfig.pgRelations.awsApplicationFirstPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplicationFirstPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.remoteAttributes,
    resource: otherSource_aws_applicationsPgResource,
    isUnique: true
  }, {
    relationName: "organizationsByMyOrganizationId",
    localAttributes: registryConfig.pgRelations.awsApplications.organizationsByMyOrganizationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplications.organizationsByMyOrganizationId.remoteAttributes,
    resource: otherSource_organizationsPgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_peoplePgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.remoteAttributes,
    resource: members_0_resource_gcp_application_first_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "gcpApplicationsByMyGcpApplicationId",
    localAttributes: registryConfig.pgRelations.gcpApplicationFirstPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplicationFirstPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.remoteAttributes,
    resource: otherSource_gcp_applicationsPgResource,
    isUnique: true
  }, {
    relationName: "peopleByMyPersonId",
    localAttributes: registryConfig.pgRelations.gcpApplications.peopleByMyPersonId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplications.peopleByMyPersonId.remoteAttributes,
    resource: otherSource_peoplePgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_organizationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.firstPartyVulnerabilities.gcpApplicationFirstPartyVulnerabilitiesByTheirFirstPartyVulnerabilityId.remoteAttributes,
    resource: members_0_resource_gcp_application_first_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "gcpApplicationsByMyGcpApplicationId",
    localAttributes: registryConfig.pgRelations.gcpApplicationFirstPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplicationFirstPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.remoteAttributes,
    resource: otherSource_gcp_applicationsPgResource,
    isUnique: true
  }, {
    relationName: "organizationsByMyOrganizationId",
    localAttributes: registryConfig.pgRelations.gcpApplications.organizationsByMyOrganizationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplications.organizationsByMyOrganizationId.remoteAttributes,
    resource: otherSource_organizationsPgResource,
    isUnique: true
  }]
}];
const resourceByTypeName11 = Object.assign(Object.create(null), {
  Person: otherSource_peoplePgResource,
  Organization: otherSource_organizationsPgResource
});
const members12 = [{
  resource: members_1_resource_aws_application_third_party_vulnerabilitiesPgResource,
  typeName: "AwsApplication",
  path: [{
    relationName: "awsApplicationsByMyAwsApplicationId"
  }]
}, {
  resource: members_1_resource_gcp_application_third_party_vulnerabilitiesPgResource,
  typeName: "GcpApplication",
  path: [{
    relationName: "gcpApplicationsByMyGcpApplicationId"
  }]
}];
const paths9 = [{
  resource: otherSource_aws_applicationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.remoteAttributes,
    resource: members_1_resource_aws_application_third_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "awsApplicationsByMyAwsApplicationId",
    localAttributes: registryConfig.pgRelations.awsApplicationThirdPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplicationThirdPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.remoteAttributes,
    resource: otherSource_aws_applicationsPgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_gcp_applicationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.remoteAttributes,
    resource: members_1_resource_gcp_application_third_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "gcpApplicationsByMyGcpApplicationId",
    localAttributes: registryConfig.pgRelations.gcpApplicationThirdPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplicationThirdPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.remoteAttributes,
    resource: otherSource_gcp_applicationsPgResource,
    isUnique: true
  }]
}];
const resourceByTypeName12 = Object.assign(Object.create(null), {
  AwsApplication: otherSource_aws_applicationsPgResource,
  GcpApplication: otherSource_gcp_applicationsPgResource
});
function ThirdPartyVulnerability_applications_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function ThirdPartyVulnerability_applications_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function ThirdPartyVulnerability_applications_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function ThirdPartyVulnerability_applications_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function ThirdPartyVulnerability_applications_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const attributes23 = {};
const members13 = [{
  resource: members_1_resource_aws_application_third_party_vulnerabilitiesPgResource,
  typeName: "Person",
  path: [{
    relationName: "awsApplicationsByMyAwsApplicationId"
  }, {
    relationName: "peopleByMyPersonId"
  }]
}, {
  resource: members_1_resource_aws_application_third_party_vulnerabilitiesPgResource,
  typeName: "Organization",
  path: [{
    relationName: "awsApplicationsByMyAwsApplicationId"
  }, {
    relationName: "organizationsByMyOrganizationId"
  }]
}, {
  resource: members_1_resource_gcp_application_third_party_vulnerabilitiesPgResource,
  typeName: "Person",
  path: [{
    relationName: "gcpApplicationsByMyGcpApplicationId"
  }, {
    relationName: "peopleByMyPersonId"
  }]
}, {
  resource: members_1_resource_gcp_application_third_party_vulnerabilitiesPgResource,
  typeName: "Organization",
  path: [{
    relationName: "gcpApplicationsByMyGcpApplicationId"
  }, {
    relationName: "organizationsByMyOrganizationId"
  }]
}];
const paths10 = [{
  resource: otherSource_peoplePgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.remoteAttributes,
    resource: members_1_resource_aws_application_third_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "awsApplicationsByMyAwsApplicationId",
    localAttributes: registryConfig.pgRelations.awsApplicationThirdPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplicationThirdPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.remoteAttributes,
    resource: otherSource_aws_applicationsPgResource,
    isUnique: true
  }, {
    relationName: "peopleByMyPersonId",
    localAttributes: registryConfig.pgRelations.awsApplications.peopleByMyPersonId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplications.peopleByMyPersonId.remoteAttributes,
    resource: otherSource_peoplePgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_organizationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.awsApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.remoteAttributes,
    resource: members_1_resource_aws_application_third_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "awsApplicationsByMyAwsApplicationId",
    localAttributes: registryConfig.pgRelations.awsApplicationThirdPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplicationThirdPartyVulnerabilities.awsApplicationsByMyAwsApplicationId.remoteAttributes,
    resource: otherSource_aws_applicationsPgResource,
    isUnique: true
  }, {
    relationName: "organizationsByMyOrganizationId",
    localAttributes: registryConfig.pgRelations.awsApplications.organizationsByMyOrganizationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.awsApplications.organizationsByMyOrganizationId.remoteAttributes,
    resource: otherSource_organizationsPgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_peoplePgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.remoteAttributes,
    resource: members_1_resource_gcp_application_third_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "gcpApplicationsByMyGcpApplicationId",
    localAttributes: registryConfig.pgRelations.gcpApplicationThirdPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplicationThirdPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.remoteAttributes,
    resource: otherSource_gcp_applicationsPgResource,
    isUnique: true
  }, {
    relationName: "peopleByMyPersonId",
    localAttributes: registryConfig.pgRelations.gcpApplications.peopleByMyPersonId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplications.peopleByMyPersonId.remoteAttributes,
    resource: otherSource_peoplePgResource,
    isUnique: true
  }]
}, {
  resource: otherSource_organizationsPgResource,
  hasReferencee: true,
  isUnique: false,
  layers: [{
    relationName: "gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId",
    localAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.thirdPartyVulnerabilities.gcpApplicationThirdPartyVulnerabilitiesByTheirThirdPartyVulnerabilityId.remoteAttributes,
    resource: members_1_resource_gcp_application_third_party_vulnerabilitiesPgResource,
    isUnique: false
  }, {
    relationName: "gcpApplicationsByMyGcpApplicationId",
    localAttributes: registryConfig.pgRelations.gcpApplicationThirdPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplicationThirdPartyVulnerabilities.gcpApplicationsByMyGcpApplicationId.remoteAttributes,
    resource: otherSource_gcp_applicationsPgResource,
    isUnique: true
  }, {
    relationName: "organizationsByMyOrganizationId",
    localAttributes: registryConfig.pgRelations.gcpApplications.organizationsByMyOrganizationId.localAttributes,
    remoteAttributes: registryConfig.pgRelations.gcpApplications.organizationsByMyOrganizationId.remoteAttributes,
    resource: otherSource_organizationsPgResource,
    isUnique: true
  }]
}];
const resourceByTypeName13 = Object.assign(Object.create(null), {
  Person: otherSource_peoplePgResource,
  Organization: otherSource_organizationsPgResource
});
function ZeroImplementationsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ZeroImplementationsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ZeroImplementationsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function OrganizationsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function OrganizationsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function OrganizationsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PeopleConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PeopleConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PeopleConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PrioritiesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PrioritiesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PrioritiesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function RelationalChecklistsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function RelationalChecklistsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function RelationalChecklistsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function RelationalTopicsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function RelationalTopicsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function RelationalTopicsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function RelationalChecklistItemsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function RelationalChecklistItemsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function RelationalChecklistItemsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function RelationalDividersConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function RelationalDividersConnection_edgesPlan($connection) {
  return $connection.edges();
}
function RelationalDividersConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function RelationalPostsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function RelationalPostsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function RelationalPostsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function FirstPartyVulnerabilitiesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function FirstPartyVulnerabilitiesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function FirstPartyVulnerabilitiesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ThirdPartyVulnerabilitiesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ThirdPartyVulnerabilitiesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ThirdPartyVulnerabilitiesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const decodeNodeId = makeDecodeNodeId([handler16, handler17, handler18, handler19, handler20]);
const details = [{
  pkAttributes: uniques10[0].attributes,
  handler: handler16
}, {
  pkAttributes: uniques17[0].attributes,
  handler: handler17
}, {
  pkAttributes: uniques13[0].attributes,
  handler: handler18
}, {
  pkAttributes: uniques8[0].attributes,
  handler: handler19
}, {
  pkAttributes: uniques12[0].attributes,
  handler: handler20
}];
const getSpec = $nodeId => {
  const $specifier = decodeNodeId($nodeId);
  const $handlerMatches = list(details.map(({
    handler,
    pkAttributes
  }) => {
    const spec = handler.getSpec(access($specifier, handler.codec.name));
    return object({
      match: lambda($specifier, specifier => {
        const value = specifier?.[handler.codec.name];
        return value != null ? handler.match(value) : false;
      }),
      pks: list(pkAttributes.map(n => spec[n]))
    });
  }));
  const $pkValues = lambda($handlerMatches, handlerMatches => {
    const match = handlerMatches.find(pk => pk.match);
    return match?.pks;
  }, true);
  return uniques23[0].attributes.reduce((memo, pkAttribute, i) => {
    memo[pkAttribute] = access($pkValues, i);
    return memo;
  }, Object.create(null));
};
const argDetailsSimple3 = [{
  graphqlArgName: "nodeId",
  postgresArgName: "nodeId",
  pgCodec: registryConfig_pgCodecs_relationalItems_relationalItems,
  required: true,
  fetcher($nodeId) {
    return otherSource_relational_itemsPgResource.get(getSpec($nodeId));
  }
}];
const makeArgs3 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple3[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_custom_delete_relational_itemPgResource = registry.pgResources["custom_delete_relational_item"];
function Mutation_customDeleteRelationalItem_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createOrganization_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createPerson_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createRelationalItemRelationCompositePk_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createSingleTableItemRelationCompositePk_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createRelationalItemRelation_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createSingleTableItemRelation_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createLogEntry_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createFirstPartyVulnerability_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createThirdPartyVulnerability_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createAwsApplication_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createGcpApplication_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler4, $nodeId);
};
function Mutation_updateOrganization_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateOrganizationByOrganizationId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateOrganizationByName_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs2 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler2, $nodeId);
};
function Mutation_updatePerson_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updatePersonByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updatePersonByUsername_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs3 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler8, $nodeId);
};
function Mutation_updateRelationalItemRelationCompositePk_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateRelationalItemRelationCompositePkByParentIdAndChildId_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs4 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler10, $nodeId);
};
function Mutation_updateSingleTableItemRelationCompositePk_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateSingleTableItemRelationCompositePkByParentIdAndChildId_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs5 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler7, $nodeId);
};
function Mutation_updateRelationalItemRelation_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateRelationalItemRelationById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateRelationalItemRelationByParentIdAndChildId_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs6 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler9, $nodeId);
};
function Mutation_updateSingleTableItemRelation_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateSingleTableItemRelationById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateSingleTableItemRelationByParentIdAndChildId_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs7 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler3, $nodeId);
};
function Mutation_updateLogEntry_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateLogEntryById_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs8 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(nodeIdHandlerByTypeName.FirstPartyVulnerability, $nodeId);
};
function Mutation_updateFirstPartyVulnerability_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateFirstPartyVulnerabilityById_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs9 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(nodeIdHandlerByTypeName.ThirdPartyVulnerability, $nodeId);
};
function Mutation_updateThirdPartyVulnerability_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateThirdPartyVulnerabilityById_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs10 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler5, $nodeId);
};
function Mutation_updateAwsApplication_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateAwsApplicationById_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs11 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler6, $nodeId);
};
function Mutation_updateGcpApplication_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateGcpApplicationById_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs12 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler4, $nodeId);
};
function Mutation_deleteOrganization_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteOrganizationByOrganizationId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteOrganizationByName_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs13 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler2, $nodeId);
};
function Mutation_deletePerson_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deletePersonByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deletePersonByUsername_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs14 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler8, $nodeId);
};
function Mutation_deleteRelationalItemRelationCompositePk_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteRelationalItemRelationCompositePkByParentIdAndChildId_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs15 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler10, $nodeId);
};
function Mutation_deleteSingleTableItemRelationCompositePk_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteSingleTableItemRelationCompositePkByParentIdAndChildId_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs16 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler7, $nodeId);
};
function Mutation_deleteRelationalItemRelation_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteRelationalItemRelationById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteRelationalItemRelationByParentIdAndChildId_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs17 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler9, $nodeId);
};
function Mutation_deleteSingleTableItemRelation_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteSingleTableItemRelationById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteSingleTableItemRelationByParentIdAndChildId_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs18 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler3, $nodeId);
};
function Mutation_deleteLogEntry_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteLogEntryById_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs19 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(nodeIdHandlerByTypeName.FirstPartyVulnerability, $nodeId);
};
function Mutation_deleteFirstPartyVulnerability_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteFirstPartyVulnerabilityById_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs20 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(nodeIdHandlerByTypeName.ThirdPartyVulnerability, $nodeId);
};
function Mutation_deleteThirdPartyVulnerability_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteThirdPartyVulnerabilityById_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs21 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler5, $nodeId);
};
function Mutation_deleteAwsApplication_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteAwsApplicationById_input_applyPlan(_, $object) {
  return $object;
}
const specFromArgs22 = args => {
  const $nodeId = args.get(["input", "nodeId"]);
  return specFromNodeId(handler6, $nodeId);
};
function Mutation_deleteGcpApplication_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteGcpApplicationById_input_applyPlan(_, $object) {
  return $object;
}
function CustomDeleteRelationalItemPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CustomDeleteRelationalItemPayload_queryPlan() {
  return rootValue();
}
function CustomDeleteRelationalItemInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateOrganizationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateOrganizationPayload_organizationPlan($object) {
  return $object.get("result");
}
function CreateOrganizationPayload_queryPlan() {
  return rootValue();
}
function CreateOrganizationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateOrganizationInput_organization_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreatePersonPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreatePersonPayload_personPlan($object) {
  return $object.get("result");
}
function CreatePersonPayload_queryPlan() {
  return rootValue();
}
function CreatePersonInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreatePersonInput_person_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateRelationalItemRelationCompositePkPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateRelationalItemRelationCompositePkPayload_relationalItemRelationCompositePkPlan($object) {
  return $object.get("result");
}
function CreateRelationalItemRelationCompositePkPayload_queryPlan() {
  return rootValue();
}
function CreateRelationalItemRelationCompositePkInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateRelationalItemRelationCompositePkInput_relationalItemRelationCompositePk_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateSingleTableItemRelationCompositePkPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateSingleTableItemRelationCompositePkPayload_singleTableItemRelationCompositePkPlan($object) {
  return $object.get("result");
}
function CreateSingleTableItemRelationCompositePkPayload_queryPlan() {
  return rootValue();
}
function CreateSingleTableItemRelationCompositePkInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateSingleTableItemRelationCompositePkInput_singleTableItemRelationCompositePk_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateRelationalItemRelationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateRelationalItemRelationPayload_relationalItemRelationPlan($object) {
  return $object.get("result");
}
function CreateRelationalItemRelationPayload_queryPlan() {
  return rootValue();
}
function CreateRelationalItemRelationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateRelationalItemRelationInput_relationalItemRelation_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateSingleTableItemRelationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateSingleTableItemRelationPayload_singleTableItemRelationPlan($object) {
  return $object.get("result");
}
function CreateSingleTableItemRelationPayload_queryPlan() {
  return rootValue();
}
function CreateSingleTableItemRelationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateSingleTableItemRelationInput_singleTableItemRelation_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateLogEntryPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateLogEntryPayload_logEntryPlan($object) {
  return $object.get("result");
}
function CreateLogEntryPayload_queryPlan() {
  return rootValue();
}
function CreateLogEntryInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateLogEntryInput_logEntry_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateFirstPartyVulnerabilityPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateFirstPartyVulnerabilityPayload_firstPartyVulnerabilityPlan($object) {
  return $object.get("result");
}
function CreateFirstPartyVulnerabilityPayload_queryPlan() {
  return rootValue();
}
function CreateFirstPartyVulnerabilityInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateFirstPartyVulnerabilityInput_firstPartyVulnerability_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateThirdPartyVulnerabilityPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateThirdPartyVulnerabilityPayload_thirdPartyVulnerabilityPlan($object) {
  return $object.get("result");
}
function CreateThirdPartyVulnerabilityPayload_queryPlan() {
  return rootValue();
}
function CreateThirdPartyVulnerabilityInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateThirdPartyVulnerabilityInput_thirdPartyVulnerability_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateAwsApplicationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateAwsApplicationPayload_awsApplicationPlan($object) {
  return $object.get("result");
}
function CreateAwsApplicationPayload_queryPlan() {
  return rootValue();
}
function CreateAwsApplicationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateAwsApplicationInput_awsApplication_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateGcpApplicationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateGcpApplicationPayload_gcpApplicationPlan($object) {
  return $object.get("result");
}
function CreateGcpApplicationPayload_queryPlan() {
  return rootValue();
}
function CreateGcpApplicationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateGcpApplicationInput_gcpApplication_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateOrganizationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateOrganizationPayload_organizationPlan($object) {
  return $object.get("result");
}
function UpdateOrganizationPayload_queryPlan() {
  return rootValue();
}
function UpdateOrganizationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateOrganizationInput_organizationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateOrganizationByOrganizationIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateOrganizationByOrganizationIdInput_organizationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateOrganizationByNameInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateOrganizationByNameInput_organizationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePersonPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdatePersonPayload_personPlan($object) {
  return $object.get("result");
}
function UpdatePersonPayload_queryPlan() {
  return rootValue();
}
function UpdatePersonInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePersonInput_personPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePersonByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePersonByPersonIdInput_personPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePersonByUsernameInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePersonByUsernameInput_personPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateRelationalItemRelationCompositePkPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateRelationalItemRelationCompositePkPayload_relationalItemRelationCompositePkPlan($object) {
  return $object.get("result");
}
function UpdateRelationalItemRelationCompositePkPayload_queryPlan() {
  return rootValue();
}
function UpdateRelationalItemRelationCompositePkInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateRelationalItemRelationCompositePkInput_relationalItemRelationCompositePkPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateRelationalItemRelationCompositePkByParentIdAndChildIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateRelationalItemRelationCompositePkByParentIdAndChildIdInput_relationalItemRelationCompositePkPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateSingleTableItemRelationCompositePkPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateSingleTableItemRelationCompositePkPayload_singleTableItemRelationCompositePkPlan($object) {
  return $object.get("result");
}
function UpdateSingleTableItemRelationCompositePkPayload_queryPlan() {
  return rootValue();
}
function UpdateSingleTableItemRelationCompositePkInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateSingleTableItemRelationCompositePkInput_singleTableItemRelationCompositePkPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateSingleTableItemRelationCompositePkByParentIdAndChildIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateSingleTableItemRelationCompositePkByParentIdAndChildIdInput_singleTableItemRelationCompositePkPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateRelationalItemRelationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateRelationalItemRelationPayload_relationalItemRelationPlan($object) {
  return $object.get("result");
}
function UpdateRelationalItemRelationPayload_queryPlan() {
  return rootValue();
}
function UpdateRelationalItemRelationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateRelationalItemRelationInput_relationalItemRelationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateRelationalItemRelationByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateRelationalItemRelationByIdInput_relationalItemRelationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateRelationalItemRelationByParentIdAndChildIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateRelationalItemRelationByParentIdAndChildIdInput_relationalItemRelationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateSingleTableItemRelationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateSingleTableItemRelationPayload_singleTableItemRelationPlan($object) {
  return $object.get("result");
}
function UpdateSingleTableItemRelationPayload_queryPlan() {
  return rootValue();
}
function UpdateSingleTableItemRelationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateSingleTableItemRelationInput_singleTableItemRelationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateSingleTableItemRelationByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateSingleTableItemRelationByIdInput_singleTableItemRelationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateSingleTableItemRelationByParentIdAndChildIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateSingleTableItemRelationByParentIdAndChildIdInput_singleTableItemRelationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateLogEntryPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateLogEntryPayload_logEntryPlan($object) {
  return $object.get("result");
}
function UpdateLogEntryPayload_queryPlan() {
  return rootValue();
}
function UpdateLogEntryInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateLogEntryInput_logEntryPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateLogEntryByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateLogEntryByIdInput_logEntryPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateFirstPartyVulnerabilityPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateFirstPartyVulnerabilityPayload_firstPartyVulnerabilityPlan($object) {
  return $object.get("result");
}
function UpdateFirstPartyVulnerabilityPayload_queryPlan() {
  return rootValue();
}
function UpdateFirstPartyVulnerabilityInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateFirstPartyVulnerabilityInput_firstPartyVulnerabilityPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateFirstPartyVulnerabilityByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateFirstPartyVulnerabilityByIdInput_firstPartyVulnerabilityPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateThirdPartyVulnerabilityPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateThirdPartyVulnerabilityPayload_thirdPartyVulnerabilityPlan($object) {
  return $object.get("result");
}
function UpdateThirdPartyVulnerabilityPayload_queryPlan() {
  return rootValue();
}
function UpdateThirdPartyVulnerabilityInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateThirdPartyVulnerabilityInput_thirdPartyVulnerabilityPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateThirdPartyVulnerabilityByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateThirdPartyVulnerabilityByIdInput_thirdPartyVulnerabilityPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateAwsApplicationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateAwsApplicationPayload_awsApplicationPlan($object) {
  return $object.get("result");
}
function UpdateAwsApplicationPayload_queryPlan() {
  return rootValue();
}
function UpdateAwsApplicationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateAwsApplicationInput_awsApplicationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateAwsApplicationByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateAwsApplicationByIdInput_awsApplicationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateGcpApplicationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateGcpApplicationPayload_gcpApplicationPlan($object) {
  return $object.get("result");
}
function UpdateGcpApplicationPayload_queryPlan() {
  return rootValue();
}
function UpdateGcpApplicationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateGcpApplicationInput_gcpApplicationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateGcpApplicationByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateGcpApplicationByIdInput_gcpApplicationPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function DeleteOrganizationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteOrganizationPayload_organizationPlan($object) {
  return $object.get("result");
}
function DeleteOrganizationPayload_queryPlan() {
  return rootValue();
}
function DeleteOrganizationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteOrganizationByOrganizationIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteOrganizationByNameInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePersonPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeletePersonPayload_personPlan($object) {
  return $object.get("result");
}
function DeletePersonPayload_queryPlan() {
  return rootValue();
}
function DeletePersonInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePersonByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePersonByUsernameInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteRelationalItemRelationCompositePkPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteRelationalItemRelationCompositePkPayload_relationalItemRelationCompositePkPlan($object) {
  return $object.get("result");
}
function DeleteRelationalItemRelationCompositePkPayload_queryPlan() {
  return rootValue();
}
function DeleteRelationalItemRelationCompositePkInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteRelationalItemRelationCompositePkByParentIdAndChildIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteSingleTableItemRelationCompositePkPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteSingleTableItemRelationCompositePkPayload_singleTableItemRelationCompositePkPlan($object) {
  return $object.get("result");
}
function DeleteSingleTableItemRelationCompositePkPayload_queryPlan() {
  return rootValue();
}
function DeleteSingleTableItemRelationCompositePkInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteSingleTableItemRelationCompositePkByParentIdAndChildIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteRelationalItemRelationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteRelationalItemRelationPayload_relationalItemRelationPlan($object) {
  return $object.get("result");
}
function DeleteRelationalItemRelationPayload_queryPlan() {
  return rootValue();
}
function DeleteRelationalItemRelationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteRelationalItemRelationByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteRelationalItemRelationByParentIdAndChildIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteSingleTableItemRelationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteSingleTableItemRelationPayload_singleTableItemRelationPlan($object) {
  return $object.get("result");
}
function DeleteSingleTableItemRelationPayload_queryPlan() {
  return rootValue();
}
function DeleteSingleTableItemRelationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteSingleTableItemRelationByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteSingleTableItemRelationByParentIdAndChildIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteLogEntryPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteLogEntryPayload_logEntryPlan($object) {
  return $object.get("result");
}
function DeleteLogEntryPayload_queryPlan() {
  return rootValue();
}
function DeleteLogEntryInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteLogEntryByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteFirstPartyVulnerabilityPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteFirstPartyVulnerabilityPayload_firstPartyVulnerabilityPlan($object) {
  return $object.get("result");
}
function DeleteFirstPartyVulnerabilityPayload_queryPlan() {
  return rootValue();
}
function DeleteFirstPartyVulnerabilityInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteFirstPartyVulnerabilityByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteThirdPartyVulnerabilityPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteThirdPartyVulnerabilityPayload_thirdPartyVulnerabilityPlan($object) {
  return $object.get("result");
}
function DeleteThirdPartyVulnerabilityPayload_queryPlan() {
  return rootValue();
}
function DeleteThirdPartyVulnerabilityInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteThirdPartyVulnerabilityByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteAwsApplicationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteAwsApplicationPayload_awsApplicationPlan($object) {
  return $object.get("result");
}
function DeleteAwsApplicationPayload_queryPlan() {
  return rootValue();
}
function DeleteAwsApplicationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteAwsApplicationByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteGcpApplicationPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteGcpApplicationPayload_gcpApplicationPlan($object) {
  return $object.get("result");
}
function DeleteGcpApplicationPayload_queryPlan() {
  return rootValue();
}
function DeleteGcpApplicationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteGcpApplicationByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
export const typeDefs = /* GraphQL */`type SingleTableTopic implements SingleTableItem & Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime
  title: String!

  """Reads a single \`Person\` that is related to this \`SingleTableItem\`."""
  personByAuthorId: Person

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItem\`.
  """
  singleTableItemByParentId: SingleTableItem

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  singleTableItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItem\`."""
    orderBy: [SingleTableItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemCondition
  ): SingleTableItemsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads a single \`SingleTableTopic\` that is related to this \`SingleTableTopic\`.
  """
  rootTopic: SingleTableTopic
}

interface SingleTableItem implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime

  """Reads a single \`Person\` that is related to this \`SingleTableItem\`."""
  personByAuthorId: Person

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItem\`.
  """
  singleTableItemByParentId: SingleTableItem

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  singleTableItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): SingleTableItemsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads a single \`SingleTableTopic\` that is related to this \`SingleTableItem\`.
  """
  rootTopic: SingleTableTopic
}

"""An object with a globally unique \`ID\`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

enum ItemType {
  TOPIC
  POST
  DIVIDER
  CHECKLIST
  CHECKLIST_ITEM
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
to unexpected results.
"""
scalar Datetime

type Person implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  personId: Int!
  username: String!

  """Reads and enables pagination through a set of \`LogEntry\`."""
  logEntriesByPersonId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`LogEntry\`."""
    orderBy: [LogEntriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LogEntryCondition
  ): LogEntriesConnection!

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  singleTableItemsByAuthorId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItem\`."""
    orderBy: [SingleTableItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemCondition
  ): SingleTableItemsConnection!

  """Reads and enables pagination through a set of \`RelationalItem\`."""
  relationalItemsByAuthorId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItem\`."""
    orderBy: [RelationalItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemCondition
  ): RelationalItemsConnection!

  """Reads and enables pagination through a set of \`AwsApplication\`."""
  awsApplicationsByPersonId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`AwsApplication\`."""
    orderBy: [AwsApplicationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AwsApplicationCondition
  ): AwsApplicationsConnection!

  """Reads and enables pagination through a set of \`GcpApplication\`."""
  gcpApplicationsByPersonId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`GcpApplication\`."""
    orderBy: [GcpApplicationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GcpApplicationCondition
  ): GcpApplicationsConnection!

  """Reads and enables pagination through a set of \`Application\`."""
  applications(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Application\`."""
    orderBy: [ApplicationsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ApplicationCondition

    """Filter results to only those of the given types"""
    only: [ApplicationType!] @deprecated(reason: "EXPERIMENTAL")
  ): ApplicationsConnection!
}

"""A connection to a list of \`LogEntry\` values."""
type LogEntriesConnection {
  """A list of \`LogEntry\` objects."""
  nodes: [LogEntry]!

  """
  A list of edges which contains the \`LogEntry\` and cursor to aid in pagination.
  """
  edges: [LogEntriesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`LogEntry\` you could get from the connection."""
  totalCount: Int!
}

type LogEntry implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  personId: Int
  organizationId: Int
  text: String!

  """Reads a single \`Organization\` that is related to this \`LogEntry\`."""
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`LogEntry\`."""
  personByPersonId: Person

  """
  Reads a single \`PersonOrOrganization\` that is related to this \`LogEntry\`.
  """
  author: PersonOrOrganization
}

type Organization implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  organizationId: Int!
  name: String!

  """Reads and enables pagination through a set of \`LogEntry\`."""
  logEntriesByOrganizationId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`LogEntry\`."""
    orderBy: [LogEntriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LogEntryCondition
  ): LogEntriesConnection!

  """Reads and enables pagination through a set of \`AwsApplication\`."""
  awsApplicationsByOrganizationId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`AwsApplication\`."""
    orderBy: [AwsApplicationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AwsApplicationCondition
  ): AwsApplicationsConnection!

  """Reads and enables pagination through a set of \`GcpApplication\`."""
  gcpApplicationsByOrganizationId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`GcpApplication\`."""
    orderBy: [GcpApplicationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GcpApplicationCondition
  ): GcpApplicationsConnection!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Methods to use when ordering \`LogEntry\`."""
enum LogEntriesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  TEXT_ASC
  TEXT_DESC
}

"""
A condition to be used against \`LogEntry\` object types. All fields are tested
for equality and combined with a logical and.
"""
input LogEntryCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`personId\` field."""
  personId: Int

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: Int

  """Checks for equality with the objects \`text\` field."""
  text: String
}

"""A connection to a list of \`AwsApplication\` values."""
type AwsApplicationsConnection {
  """A list of \`AwsApplication\` objects."""
  nodes: [AwsApplication]!

  """
  A list of edges which contains the \`AwsApplication\` and cursor to aid in pagination.
  """
  edges: [AwsApplicationsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`AwsApplication\` you could get from the connection."""
  totalCount: Int!
}

type AwsApplication implements Node & Application {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  lastDeployed: Datetime
  personId: Int
  organizationId: Int
  awsId: String

  """
  Reads a single \`Organization\` that is related to this \`AwsApplication\`.
  """
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`AwsApplication\`."""
  personByPersonId: Person

  """Reads and enables pagination through a set of \`Vulnerability\`."""
  vulnerabilities(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Vulnerability\`."""
    orderBy: [VulnerabilitiesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VulnerabilityCondition

    """Filter results to only those of the given types"""
    only: [VulnerabilityType!] @deprecated(reason: "EXPERIMENTAL")
  ): VulnerabilitiesConnection!

  """
  Reads a single \`PersonOrOrganization\` that is related to this \`AwsApplication\`.
  """
  owner: PersonOrOrganization
}

interface Application implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  lastDeployed: Datetime

  """Reads and enables pagination through a set of \`Vulnerability\`."""
  vulnerabilities(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Filter results to only those of the given types"""
    only: [VulnerabilityType!] @deprecated(reason: "EXPERIMENTAL")
  ): VulnerabilitiesConnection!

  """
  Reads a single \`PersonOrOrganization\` that is related to this \`Application\`.
  """
  owner: PersonOrOrganization
}

"""A connection to a list of \`Vulnerability\` values."""
type VulnerabilitiesConnection {
  """A list of \`Vulnerability\` objects."""
  nodes: [Vulnerability]!

  """
  A list of edges which contains the \`Vulnerability\` and cursor to aid in pagination.
  """
  edges: [VulnerabilitiesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Vulnerability\` you could get from the connection."""
  totalCount: Int!
}

interface Vulnerability implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  cvssScore: Float!

  """Reads and enables pagination through a set of \`Application\`."""
  applications(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Filter results to only those of the given types"""
    only: [ApplicationType!] @deprecated(reason: "EXPERIMENTAL")
  ): ApplicationsConnection!

  """Reads and enables pagination through a set of \`PersonOrOrganization\`."""
  owners: PersonOrOrganizationConnection!
}

"""A connection to a list of \`Application\` values."""
type ApplicationsConnection {
  """A list of \`Application\` objects."""
  nodes: [Application]!

  """
  A list of edges which contains the \`Application\` and cursor to aid in pagination.
  """
  edges: [ApplicationsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Application\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Application\` edge in the connection."""
type ApplicationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Application\` at the end of the edge."""
  node: Application
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

enum ApplicationType {
  AwsApplication
  GcpApplication
}

"""A connection to a list of \`PersonOrOrganization\` values."""
type PersonOrOrganizationConnection {
  """A list of \`PersonOrOrganization\` objects."""
  nodes: [PersonOrOrganization]!

  """
  A list of edges which contains the \`PersonOrOrganization\` and cursor to aid in pagination.
  """
  edges: [PersonOrOrganizationEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

union PersonOrOrganization = Organization | Person

"""A \`PersonOrOrganization\` edge in the connection."""
type PersonOrOrganizationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`PersonOrOrganization\` at the end of the edge."""
  node: PersonOrOrganization
}

"""A \`Vulnerability\` edge in the connection."""
type VulnerabilitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Vulnerability\` at the end of the edge."""
  node: Vulnerability
}

enum VulnerabilityType {
  FirstPartyVulnerability
  ThirdPartyVulnerability
}

"""Methods to use when ordering \`Vulnerability\`."""
enum VulnerabilitiesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CVSS_SCORE_ASC
  CVSS_SCORE_DESC
}

"""
A condition to be used against \`Vulnerability\` object types. All fields are
tested for equality and combined with a logical and.
"""
input VulnerabilityCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`cvssScore\` field."""
  cvssScore: Float
}

"""A \`AwsApplication\` edge in the connection."""
type AwsApplicationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`AwsApplication\` at the end of the edge."""
  node: AwsApplication
}

"""Methods to use when ordering \`AwsApplication\`."""
enum AwsApplicationsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  LAST_DEPLOYED_ASC
  LAST_DEPLOYED_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  AWS_ID_ASC
  AWS_ID_DESC
}

"""
A condition to be used against \`AwsApplication\` object types. All fields are
tested for equality and combined with a logical and.
"""
input AwsApplicationCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`lastDeployed\` field."""
  lastDeployed: Datetime

  """Checks for equality with the objects \`personId\` field."""
  personId: Int

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: Int

  """Checks for equality with the objects \`awsId\` field."""
  awsId: String
}

"""A connection to a list of \`GcpApplication\` values."""
type GcpApplicationsConnection {
  """A list of \`GcpApplication\` objects."""
  nodes: [GcpApplication]!

  """
  A list of edges which contains the \`GcpApplication\` and cursor to aid in pagination.
  """
  edges: [GcpApplicationsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`GcpApplication\` you could get from the connection."""
  totalCount: Int!
}

type GcpApplication implements Node & Application {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  lastDeployed: Datetime
  personId: Int
  organizationId: Int
  gcpId: String

  """
  Reads a single \`Organization\` that is related to this \`GcpApplication\`.
  """
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`GcpApplication\`."""
  personByPersonId: Person

  """Reads and enables pagination through a set of \`Vulnerability\`."""
  vulnerabilities(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Vulnerability\`."""
    orderBy: [VulnerabilitiesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VulnerabilityCondition

    """Filter results to only those of the given types"""
    only: [VulnerabilityType!] @deprecated(reason: "EXPERIMENTAL")
  ): VulnerabilitiesConnection!

  """
  Reads a single \`PersonOrOrganization\` that is related to this \`GcpApplication\`.
  """
  owner: PersonOrOrganization
}

"""A \`GcpApplication\` edge in the connection."""
type GcpApplicationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`GcpApplication\` at the end of the edge."""
  node: GcpApplication
}

"""Methods to use when ordering \`GcpApplication\`."""
enum GcpApplicationsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  LAST_DEPLOYED_ASC
  LAST_DEPLOYED_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  GCP_ID_ASC
  GCP_ID_DESC
}

"""
A condition to be used against \`GcpApplication\` object types. All fields are
tested for equality and combined with a logical and.
"""
input GcpApplicationCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`lastDeployed\` field."""
  lastDeployed: Datetime

  """Checks for equality with the objects \`personId\` field."""
  personId: Int

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: Int

  """Checks for equality with the objects \`gcpId\` field."""
  gcpId: String
}

"""A \`LogEntry\` edge in the connection."""
type LogEntriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`LogEntry\` at the end of the edge."""
  node: LogEntry
}

"""A connection to a list of \`SingleTableItem\` values."""
type SingleTableItemsConnection {
  """A list of \`SingleTableItem\` objects."""
  nodes: [SingleTableItem]!

  """
  A list of edges which contains the \`SingleTableItem\` and cursor to aid in pagination.
  """
  edges: [SingleTableItemsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`SingleTableItem\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`SingleTableItem\` edge in the connection."""
type SingleTableItemsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`SingleTableItem\` at the end of the edge."""
  node: SingleTableItem
}

"""Methods to use when ordering \`SingleTableItem\`."""
enum SingleTableItemsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  ROOT_TOPIC_ID_ASC
  ROOT_TOPIC_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  POSITION_ASC
  POSITION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IS_EXPLICITLY_ARCHIVED_ASC
  IS_EXPLICITLY_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
}

"""
A condition to be used against \`SingleTableItem\` object types. All fields are
tested for equality and combined with a logical and.
"""
input SingleTableItemCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`type\` field."""
  type: ItemType

  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`rootTopicId\` field."""
  rootTopicId: Int

  """Checks for equality with the objects \`authorId\` field."""
  authorId: Int

  """Checks for equality with the objects \`position\` field."""
  position: BigInt

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`isExplicitlyArchived\` field."""
  isExplicitlyArchived: Boolean

  """Checks for equality with the objects \`archivedAt\` field."""
  archivedAt: Datetime
}

"""A connection to a list of \`RelationalItem\` values."""
type RelationalItemsConnection {
  """A list of \`RelationalItem\` objects."""
  nodes: [RelationalItem]!

  """
  A list of edges which contains the \`RelationalItem\` and cursor to aid in pagination.
  """
  edges: [RelationalItemsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`RelationalItem\` you could get from the connection."""
  totalCount: Int!
}

interface RelationalItem implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime

  """Reads a single \`Person\` that is related to this \`RelationalItem\`."""
  personByAuthorId: Person

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItem\`.
  """
  relationalItemByParentId: RelationalItem

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalItem\`.
  """
  relationalTopicByRootTopicId: RelationalTopic

  """Reads and enables pagination through a set of \`RelationalItem\`."""
  relationalItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): RelationalItemsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): RelationalItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): RelationalItemRelationCompositePksConnection!
}

"""A connection to a list of \`RelationalItemRelation\` values."""
type RelationalItemRelationsConnection {
  """A list of \`RelationalItemRelation\` objects."""
  nodes: [RelationalItemRelation]!

  """
  A list of edges which contains the \`RelationalItemRelation\` and cursor to aid in pagination.
  """
  edges: [RelationalItemRelationsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`RelationalItemRelation\` you could get from the connection.
  """
  totalCount: Int!
}

type RelationalItemRelation implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  parentId: Int!
  childId: Int!

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelation\`.
  """
  relationalItemByChildId: RelationalItem

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelation\`.
  """
  relationalItemByParentId: RelationalItem
}

"""A \`RelationalItemRelation\` edge in the connection."""
type RelationalItemRelationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`RelationalItemRelation\` at the end of the edge."""
  node: RelationalItemRelation
}

"""A connection to a list of \`RelationalItemRelationCompositePk\` values."""
type RelationalItemRelationCompositePksConnection {
  """A list of \`RelationalItemRelationCompositePk\` objects."""
  nodes: [RelationalItemRelationCompositePk]!

  """
  A list of edges which contains the \`RelationalItemRelationCompositePk\` and cursor to aid in pagination.
  """
  edges: [RelationalItemRelationCompositePksEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`RelationalItemRelationCompositePk\` you could get from the connection.
  """
  totalCount: Int!
}

type RelationalItemRelationCompositePk implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  parentId: Int!
  childId: Int!

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelationCompositePk\`.
  """
  relationalItemByChildId: RelationalItem

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelationCompositePk\`.
  """
  relationalItemByParentId: RelationalItem
}

"""A \`RelationalItemRelationCompositePk\` edge in the connection."""
type RelationalItemRelationCompositePksEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`RelationalItemRelationCompositePk\` at the end of the edge."""
  node: RelationalItemRelationCompositePk
}

"""A \`RelationalItem\` edge in the connection."""
type RelationalItemsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`RelationalItem\` at the end of the edge."""
  node: RelationalItem
}

"""Methods to use when ordering \`RelationalItem\`."""
enum RelationalItemsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  ROOT_TOPIC_ID_ASC
  ROOT_TOPIC_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  POSITION_ASC
  POSITION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IS_EXPLICITLY_ARCHIVED_ASC
  IS_EXPLICITLY_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
}

"""
A condition to be used against \`RelationalItem\` object types. All fields are
tested for equality and combined with a logical and.
"""
input RelationalItemCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`type\` field."""
  type: ItemType

  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`rootTopicId\` field."""
  rootTopicId: Int

  """Checks for equality with the objects \`authorId\` field."""
  authorId: Int

  """Checks for equality with the objects \`position\` field."""
  position: BigInt

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`isExplicitlyArchived\` field."""
  isExplicitlyArchived: Boolean

  """Checks for equality with the objects \`archivedAt\` field."""
  archivedAt: Datetime
}

"""Methods to use when ordering \`Application\`."""
enum ApplicationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  LAST_DEPLOYED_ASC
  LAST_DEPLOYED_DESC
}

"""
A condition to be used against \`Application\` object types. All fields are tested
for equality and combined with a logical and.
"""
input ApplicationCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`lastDeployed\` field."""
  lastDeployed: Datetime
}

"""A connection to a list of \`SingleTableItemRelation\` values."""
type SingleTableItemRelationsConnection {
  """A list of \`SingleTableItemRelation\` objects."""
  nodes: [SingleTableItemRelation]!

  """
  A list of edges which contains the \`SingleTableItemRelation\` and cursor to aid in pagination.
  """
  edges: [SingleTableItemRelationsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`SingleTableItemRelation\` you could get from the connection.
  """
  totalCount: Int!
}

type SingleTableItemRelation implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  parentId: Int!
  childId: Int!

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelation\`.
  """
  singleTableItemByChildId: SingleTableItem

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelation\`.
  """
  singleTableItemByParentId: SingleTableItem
}

"""A \`SingleTableItemRelation\` edge in the connection."""
type SingleTableItemRelationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`SingleTableItemRelation\` at the end of the edge."""
  node: SingleTableItemRelation
}

"""A connection to a list of \`SingleTableItemRelationCompositePk\` values."""
type SingleTableItemRelationCompositePksConnection {
  """A list of \`SingleTableItemRelationCompositePk\` objects."""
  nodes: [SingleTableItemRelationCompositePk]!

  """
  A list of edges which contains the \`SingleTableItemRelationCompositePk\` and cursor to aid in pagination.
  """
  edges: [SingleTableItemRelationCompositePksEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`SingleTableItemRelationCompositePk\` you could get from the connection.
  """
  totalCount: Int!
}

type SingleTableItemRelationCompositePk implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  parentId: Int!
  childId: Int!

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemByChildId: SingleTableItem

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemByParentId: SingleTableItem
}

"""A \`SingleTableItemRelationCompositePk\` edge in the connection."""
type SingleTableItemRelationCompositePksEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`SingleTableItemRelationCompositePk\` at the end of the edge."""
  node: SingleTableItemRelationCompositePk
}

"""Methods to use when ordering \`SingleTableItemRelation\`."""
enum SingleTableItemRelationsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  CHILD_ID_ASC
  CHILD_ID_DESC
}

"""
A condition to be used against \`SingleTableItemRelation\` object types. All
fields are tested for equality and combined with a logical and.
"""
input SingleTableItemRelationCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`childId\` field."""
  childId: Int
}

"""Methods to use when ordering \`SingleTableItemRelationCompositePk\`."""
enum SingleTableItemRelationCompositePksOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  CHILD_ID_ASC
  CHILD_ID_DESC
}

"""
A condition to be used against \`SingleTableItemRelationCompositePk\` object
types. All fields are tested for equality and combined with a logical and.
"""
input SingleTableItemRelationCompositePkCondition {
  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`childId\` field."""
  childId: Int
}

type SingleTablePost implements SingleTableItem & Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime
  subject: String
  description: String
  note: String
  priorityId: Int

  """Reads a single \`Person\` that is related to this \`SingleTableItem\`."""
  personByAuthorId: Person

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItem\`.
  """
  singleTableItemByParentId: SingleTableItem

  """Reads a single \`Priority\` that is related to this \`SingleTableItem\`."""
  priorityByPriorityId: Priority

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  singleTableItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItem\`."""
    orderBy: [SingleTableItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemCondition
  ): SingleTableItemsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads a single \`SingleTableTopic\` that is related to this \`SingleTablePost\`.
  """
  rootTopic: SingleTableTopic
}

type Priority implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  title: String!

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  singleTableItemsByPriorityId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItem\`."""
    orderBy: [SingleTableItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemCondition
  ): SingleTableItemsConnection!
}

type SingleTableDivider implements SingleTableItem & Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime
  title: String
  color: String

  """Reads a single \`Person\` that is related to this \`SingleTableItem\`."""
  personByAuthorId: Person

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItem\`.
  """
  singleTableItemByParentId: SingleTableItem

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  singleTableItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItem\`."""
    orderBy: [SingleTableItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemCondition
  ): SingleTableItemsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads a single \`SingleTableTopic\` that is related to this \`SingleTableDivider\`.
  """
  rootTopic: SingleTableTopic
}

type SingleTableChecklist implements SingleTableItem & Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime
  title: String

  """Reads a single \`Person\` that is related to this \`SingleTableItem\`."""
  personByAuthorId: Person

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItem\`.
  """
  singleTableItemByParentId: SingleTableItem

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  singleTableItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItem\`."""
    orderBy: [SingleTableItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemCondition
  ): SingleTableItemsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads a single \`SingleTableTopic\` that is related to this \`SingleTableChecklist\`.
  """
  rootTopic: SingleTableTopic

  """
  Reads a single \`SingleTableTopic\` that is related to this \`SingleTableChecklist\`.
  """
  rootChecklistTopic: SingleTableTopic
}

type SingleTableChecklistItem implements SingleTableItem & Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime
  description: String
  note: String
  priorityId: Int

  """Reads a single \`Person\` that is related to this \`SingleTableItem\`."""
  personByAuthorId: Person

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItem\`.
  """
  singleTableItemByParentId: SingleTableItem

  """Reads a single \`Priority\` that is related to this \`SingleTableItem\`."""
  priorityByPriorityId: Priority

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  singleTableItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItem\`."""
    orderBy: [SingleTableItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemCondition
  ): SingleTableItemsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  singleTableItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection!

  """
  Reads a single \`SingleTableTopic\` that is related to this \`SingleTableChecklistItem\`.
  """
  rootTopic: SingleTableTopic
}

type RelationalTopic implements Node & RelationalItem {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  title: String!
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime

  """Reads and enables pagination through a set of \`RelationalItem\`."""
  relationalItemsByRootTopicId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItem\`."""
    orderBy: [RelationalItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemCondition
  ): RelationalItemsConnection!

  """Reads a single \`Person\` that is related to this \`RelationalTopic\`."""
  personByAuthorId: Person

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalTopic\`.
  """
  relationalItemByParentId: RelationalItem

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalTopic\`.
  """
  relationalTopicByRootTopicId: RelationalTopic

  """Reads and enables pagination through a set of \`RelationalItem\`."""
  relationalItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItem\`."""
    orderBy: [RelationalItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemCondition
  ): RelationalItemsConnection!

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalTopic\`.
  """
  relationalTopicByTopicItemId: RelationalTopic

  """
  Reads a single \`RelationalPost\` that is related to this \`RelationalTopic\`.
  """
  relationalPostByPostItemId: RelationalPost

  """
  Reads a single \`RelationalDivider\` that is related to this \`RelationalTopic\`.
  """
  relationalDividerByDividerItemId: RelationalDivider

  """
  Reads a single \`RelationalChecklist\` that is related to this \`RelationalTopic\`.
  """
  relationalChecklistByChecklistItemId: RelationalChecklist

  """
  Reads a single \`RelationalChecklistItem\` that is related to this \`RelationalTopic\`.
  """
  relationalChecklistItemByChecklistItemItemId: RelationalChecklistItem

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!
}

"""Methods to use when ordering \`RelationalItemRelation\`."""
enum RelationalItemRelationsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  CHILD_ID_ASC
  CHILD_ID_DESC
}

"""
A condition to be used against \`RelationalItemRelation\` object types. All fields
are tested for equality and combined with a logical and.
"""
input RelationalItemRelationCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`childId\` field."""
  childId: Int
}

"""Methods to use when ordering \`RelationalItemRelationCompositePk\`."""
enum RelationalItemRelationCompositePksOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  CHILD_ID_ASC
  CHILD_ID_DESC
}

"""
A condition to be used against \`RelationalItemRelationCompositePk\` object types.
All fields are tested for equality and combined with a logical and.
"""
input RelationalItemRelationCompositePkCondition {
  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`childId\` field."""
  childId: Int
}

type RelationalPost implements Node & RelationalItem {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  title: String!
  description: String
  note: String
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime

  """Reads a single \`Person\` that is related to this \`RelationalPost\`."""
  personByAuthorId: Person

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalPost\`.
  """
  relationalItemByParentId: RelationalItem

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalPost\`.
  """
  relationalTopicByRootTopicId: RelationalTopic

  """Reads and enables pagination through a set of \`RelationalItem\`."""
  relationalItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItem\`."""
    orderBy: [RelationalItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemCondition
  ): RelationalItemsConnection!

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalPost\`.
  """
  relationalTopicByTopicItemId: RelationalTopic

  """
  Reads a single \`RelationalPost\` that is related to this \`RelationalPost\`.
  """
  relationalPostByPostItemId: RelationalPost

  """
  Reads a single \`RelationalDivider\` that is related to this \`RelationalPost\`.
  """
  relationalDividerByDividerItemId: RelationalDivider

  """
  Reads a single \`RelationalChecklist\` that is related to this \`RelationalPost\`.
  """
  relationalChecklistByChecklistItemId: RelationalChecklist

  """
  Reads a single \`RelationalChecklistItem\` that is related to this \`RelationalPost\`.
  """
  relationalChecklistItemByChecklistItemItemId: RelationalChecklistItem

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!
}

type RelationalDivider implements Node & RelationalItem {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  title: String
  color: String
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime

  """Reads a single \`Person\` that is related to this \`RelationalDivider\`."""
  personByAuthorId: Person

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalDivider\`.
  """
  relationalItemByParentId: RelationalItem

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalDivider\`.
  """
  relationalTopicByRootTopicId: RelationalTopic

  """Reads and enables pagination through a set of \`RelationalItem\`."""
  relationalItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItem\`."""
    orderBy: [RelationalItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemCondition
  ): RelationalItemsConnection!

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalDivider\`.
  """
  relationalTopicByTopicItemId: RelationalTopic

  """
  Reads a single \`RelationalPost\` that is related to this \`RelationalDivider\`.
  """
  relationalPostByPostItemId: RelationalPost

  """
  Reads a single \`RelationalDivider\` that is related to this \`RelationalDivider\`.
  """
  relationalDividerByDividerItemId: RelationalDivider

  """
  Reads a single \`RelationalChecklist\` that is related to this \`RelationalDivider\`.
  """
  relationalChecklistByChecklistItemId: RelationalChecklist

  """
  Reads a single \`RelationalChecklistItem\` that is related to this \`RelationalDivider\`.
  """
  relationalChecklistItemByChecklistItemItemId: RelationalChecklistItem

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!
}

type RelationalChecklist implements Node & RelationalItem {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  title: String!
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime

  """Reads a single \`Person\` that is related to this \`RelationalChecklist\`."""
  personByAuthorId: Person

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalChecklist\`.
  """
  relationalItemByParentId: RelationalItem

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalChecklist\`.
  """
  relationalTopicByRootTopicId: RelationalTopic

  """Reads and enables pagination through a set of \`RelationalItem\`."""
  relationalItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItem\`."""
    orderBy: [RelationalItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemCondition
  ): RelationalItemsConnection!

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalChecklist\`.
  """
  relationalTopicByTopicItemId: RelationalTopic

  """
  Reads a single \`RelationalPost\` that is related to this \`RelationalChecklist\`.
  """
  relationalPostByPostItemId: RelationalPost

  """
  Reads a single \`RelationalDivider\` that is related to this \`RelationalChecklist\`.
  """
  relationalDividerByDividerItemId: RelationalDivider

  """
  Reads a single \`RelationalChecklist\` that is related to this \`RelationalChecklist\`.
  """
  relationalChecklistByChecklistItemId: RelationalChecklist

  """
  Reads a single \`RelationalChecklistItem\` that is related to this \`RelationalChecklist\`.
  """
  relationalChecklistItemByChecklistItemItemId: RelationalChecklistItem

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!
}

type RelationalChecklistItem implements Node & RelationalItem {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  description: String!
  note: String
  id: Int!
  type: ItemType!
  parentId: Int
  rootTopicId: Int
  authorId: Int!
  position: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  isExplicitlyArchived: Boolean!
  archivedAt: Datetime

  """
  Reads a single \`Person\` that is related to this \`RelationalChecklistItem\`.
  """
  personByAuthorId: Person

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalChecklistItem\`.
  """
  relationalItemByParentId: RelationalItem

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalChecklistItem\`.
  """
  relationalTopicByRootTopicId: RelationalTopic

  """Reads and enables pagination through a set of \`RelationalItem\`."""
  relationalItemsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItem\`."""
    orderBy: [RelationalItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemCondition
  ): RelationalItemsConnection!

  """
  Reads a single \`RelationalTopic\` that is related to this \`RelationalChecklistItem\`.
  """
  relationalTopicByTopicItemId: RelationalTopic

  """
  Reads a single \`RelationalPost\` that is related to this \`RelationalChecklistItem\`.
  """
  relationalPostByPostItemId: RelationalPost

  """
  Reads a single \`RelationalDivider\` that is related to this \`RelationalChecklistItem\`.
  """
  relationalDividerByDividerItemId: RelationalDivider

  """
  Reads a single \`RelationalChecklist\` that is related to this \`RelationalChecklistItem\`.
  """
  relationalChecklistByChecklistItemId: RelationalChecklist

  """
  Reads a single \`RelationalChecklistItem\` that is related to this \`RelationalChecklistItem\`.
  """
  relationalChecklistItemByChecklistItemItemId: RelationalChecklistItem

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  relationalItemRelationsByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByChildId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  relationalItemRelationCompositePksByParentId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection!
}

"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a \`Node\` to work well with Relay 1 mutations. This just resolves to \`query\`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique \`ID\`."""
  node(
    """The globally unique \`ID\`."""
    nodeId: ID!
  ): Node

  """Get a single \`Organization\`."""
  organizationByOrganizationId(organizationId: Int!): Organization

  """Get a single \`Organization\`."""
  organizationByName(name: String!): Organization

  """Get a single \`Person\`."""
  personByPersonId(personId: Int!): Person

  """Get a single \`Person\`."""
  personByUsername(username: String!): Person

  """Get a single \`Priority\`."""
  priorityById(id: Int!): Priority

  """Get a single \`RelationalChecklist\`."""
  relationalChecklistByChecklistItemId(checklistItemId: Int!): RelationalChecklist

  """Get a single \`RelationalItemRelationCompositePk\`."""
  relationalItemRelationCompositePkByParentIdAndChildId(parentId: Int!, childId: Int!): RelationalItemRelationCompositePk

  """Get a single \`RelationalTopic\`."""
  relationalTopicByTopicItemId(topicItemId: Int!): RelationalTopic

  """Get a single \`SingleTableItemRelationCompositePk\`."""
  singleTableItemRelationCompositePkByParentIdAndChildId(parentId: Int!, childId: Int!): SingleTableItemRelationCompositePk

  """Get a single \`RelationalChecklistItem\`."""
  relationalChecklistItemByChecklistItemItemId(checklistItemItemId: Int!): RelationalChecklistItem

  """Get a single \`RelationalDivider\`."""
  relationalDividerByDividerItemId(dividerItemId: Int!): RelationalDivider

  """Get a single \`RelationalItemRelation\`."""
  relationalItemRelationById(id: Int!): RelationalItemRelation

  """Get a single \`RelationalItemRelation\`."""
  relationalItemRelationByParentIdAndChildId(parentId: Int!, childId: Int!): RelationalItemRelation

  """Get a single \`SingleTableItemRelation\`."""
  singleTableItemRelationById(id: Int!): SingleTableItemRelation

  """Get a single \`SingleTableItemRelation\`."""
  singleTableItemRelationByParentIdAndChildId(parentId: Int!, childId: Int!): SingleTableItemRelation

  """Get a single \`LogEntry\`."""
  logEntryById(id: Int!): LogEntry

  """Get a single \`RelationalPost\`."""
  relationalPostByPostItemId(postItemId: Int!): RelationalPost

  """Get a single \`FirstPartyVulnerability\`."""
  firstPartyVulnerabilityById(id: Int!): FirstPartyVulnerability

  """Get a single \`ThirdPartyVulnerability\`."""
  thirdPartyVulnerabilityById(id: Int!): ThirdPartyVulnerability

  """Get a single \`AwsApplication\`."""
  awsApplicationById(id: Int!): AwsApplication

  """Get a single \`GcpApplication\`."""
  gcpApplicationById(id: Int!): GcpApplication

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  allSingleTables(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): SingleTableItemsConnection
  getSingleTableTopicById(id: Int): SingleTableTopic

  """Reads a single \`SingleTableTopic\` using its globally unique \`ID\`."""
  singleTableTopic(
    """
    The globally unique \`ID\` to be used in selecting a single \`SingleTableTopic\`.
    """
    nodeId: ID!
  ): SingleTableTopic

  """Reads a single \`SingleTablePost\` using its globally unique \`ID\`."""
  singleTablePost(
    """
    The globally unique \`ID\` to be used in selecting a single \`SingleTablePost\`.
    """
    nodeId: ID!
  ): SingleTablePost

  """Reads a single \`SingleTableDivider\` using its globally unique \`ID\`."""
  singleTableDivider(
    """
    The globally unique \`ID\` to be used in selecting a single \`SingleTableDivider\`.
    """
    nodeId: ID!
  ): SingleTableDivider

  """Reads a single \`SingleTableChecklist\` using its globally unique \`ID\`."""
  singleTableChecklist(
    """
    The globally unique \`ID\` to be used in selecting a single \`SingleTableChecklist\`.
    """
    nodeId: ID!
  ): SingleTableChecklist

  """
  Reads a single \`SingleTableChecklistItem\` using its globally unique \`ID\`.
  """
  singleTableChecklistItem(
    """
    The globally unique \`ID\` to be used in selecting a single \`SingleTableChecklistItem\`.
    """
    nodeId: ID!
  ): SingleTableChecklistItem

  """Reads a single \`Organization\` using its globally unique \`ID\`."""
  organization(
    """
    The globally unique \`ID\` to be used in selecting a single \`Organization\`.
    """
    nodeId: ID!
  ): Organization

  """Reads a single \`Person\` using its globally unique \`ID\`."""
  person(
    """The globally unique \`ID\` to be used in selecting a single \`Person\`."""
    nodeId: ID!
  ): Person

  """Reads a single \`Priority\` using its globally unique \`ID\`."""
  priority(
    """The globally unique \`ID\` to be used in selecting a single \`Priority\`."""
    nodeId: ID!
  ): Priority

  """Reads a single \`RelationalChecklist\` using its globally unique \`ID\`."""
  relationalChecklist(
    """
    The globally unique \`ID\` to be used in selecting a single \`RelationalChecklist\`.
    """
    nodeId: ID!
  ): RelationalChecklist

  """
  Reads a single \`RelationalItemRelationCompositePk\` using its globally unique \`ID\`.
  """
  relationalItemRelationCompositePk(
    """
    The globally unique \`ID\` to be used in selecting a single \`RelationalItemRelationCompositePk\`.
    """
    nodeId: ID!
  ): RelationalItemRelationCompositePk

  """Reads a single \`RelationalTopic\` using its globally unique \`ID\`."""
  relationalTopic(
    """
    The globally unique \`ID\` to be used in selecting a single \`RelationalTopic\`.
    """
    nodeId: ID!
  ): RelationalTopic

  """
  Reads a single \`SingleTableItemRelationCompositePk\` using its globally unique \`ID\`.
  """
  singleTableItemRelationCompositePk(
    """
    The globally unique \`ID\` to be used in selecting a single \`SingleTableItemRelationCompositePk\`.
    """
    nodeId: ID!
  ): SingleTableItemRelationCompositePk

  """
  Reads a single \`RelationalChecklistItem\` using its globally unique \`ID\`.
  """
  relationalChecklistItem(
    """
    The globally unique \`ID\` to be used in selecting a single \`RelationalChecklistItem\`.
    """
    nodeId: ID!
  ): RelationalChecklistItem

  """Reads a single \`RelationalDivider\` using its globally unique \`ID\`."""
  relationalDivider(
    """
    The globally unique \`ID\` to be used in selecting a single \`RelationalDivider\`.
    """
    nodeId: ID!
  ): RelationalDivider

  """
  Reads a single \`RelationalItemRelation\` using its globally unique \`ID\`.
  """
  relationalItemRelation(
    """
    The globally unique \`ID\` to be used in selecting a single \`RelationalItemRelation\`.
    """
    nodeId: ID!
  ): RelationalItemRelation

  """
  Reads a single \`SingleTableItemRelation\` using its globally unique \`ID\`.
  """
  singleTableItemRelation(
    """
    The globally unique \`ID\` to be used in selecting a single \`SingleTableItemRelation\`.
    """
    nodeId: ID!
  ): SingleTableItemRelation

  """Reads a single \`LogEntry\` using its globally unique \`ID\`."""
  logEntry(
    """The globally unique \`ID\` to be used in selecting a single \`LogEntry\`."""
    nodeId: ID!
  ): LogEntry

  """Reads a single \`RelationalPost\` using its globally unique \`ID\`."""
  relationalPost(
    """
    The globally unique \`ID\` to be used in selecting a single \`RelationalPost\`.
    """
    nodeId: ID!
  ): RelationalPost

  """
  Reads a single \`FirstPartyVulnerability\` using its globally unique \`ID\`.
  """
  firstPartyVulnerability(
    """
    The globally unique \`ID\` to be used in selecting a single \`FirstPartyVulnerability\`.
    """
    nodeId: ID!
  ): FirstPartyVulnerability

  """
  Reads a single \`ThirdPartyVulnerability\` using its globally unique \`ID\`.
  """
  thirdPartyVulnerability(
    """
    The globally unique \`ID\` to be used in selecting a single \`ThirdPartyVulnerability\`.
    """
    nodeId: ID!
  ): ThirdPartyVulnerability

  """Reads a single \`AwsApplication\` using its globally unique \`ID\`."""
  awsApplication(
    """
    The globally unique \`ID\` to be used in selecting a single \`AwsApplication\`.
    """
    nodeId: ID!
  ): AwsApplication

  """Reads a single \`GcpApplication\` using its globally unique \`ID\`."""
  gcpApplication(
    """
    The globally unique \`ID\` to be used in selecting a single \`GcpApplication\`.
    """
    nodeId: ID!
  ): GcpApplication
  allVulnerabilities(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Vulnerability\`."""
    orderBy: [VulnerabilitiesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VulnerabilityCondition

    """Filter results to only those of the given types"""
    only: [VulnerabilityType!] @deprecated(reason: "EXPERIMENTAL")
  ): VulnerabilitiesConnection
  allApplications(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Application\`."""
    orderBy: [ApplicationsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ApplicationCondition

    """Filter results to only those of the given types"""
    only: [ApplicationType!] @deprecated(reason: "EXPERIMENTAL")
  ): ApplicationsConnection
  allZeroImplementations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ZeroImplementation\`."""
    orderBy: [ZeroImplementationsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ZeroImplementationCondition
  ): ZeroImplementationsConnection

  """Reads and enables pagination through a set of \`Organization\`."""
  allOrganizations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganizationCondition
  ): OrganizationsConnection

  """Reads and enables pagination through a set of \`Person\`."""
  allPeople(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonCondition
  ): PeopleConnection

  """Reads and enables pagination through a set of \`Priority\`."""
  allPriorities(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): PrioritiesConnection

  """Reads and enables pagination through a set of \`RelationalChecklist\`."""
  allRelationalChecklists(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalChecklist\`."""
    orderBy: [RelationalChecklistsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalChecklistCondition
  ): RelationalChecklistsConnection

  """
  Reads and enables pagination through a set of \`RelationalItemRelationCompositePk\`.
  """
  allRelationalItemRelationCompositePks(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCompositePkCondition
  ): RelationalItemRelationCompositePksConnection

  """Reads and enables pagination through a set of \`RelationalTopic\`."""
  allRelationalTopics(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalTopic\`."""
    orderBy: [RelationalTopicsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalTopicCondition
  ): RelationalTopicsConnection

  """
  Reads and enables pagination through a set of \`SingleTableItemRelationCompositePk\`.
  """
  allSingleTableItemRelationCompositePks(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCompositePkCondition
  ): SingleTableItemRelationCompositePksConnection

  """
  Reads and enables pagination through a set of \`RelationalChecklistItem\`.
  """
  allRelationalChecklistItems(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalChecklistItem\`."""
    orderBy: [RelationalChecklistItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalChecklistItemCondition
  ): RelationalChecklistItemsConnection

  """Reads and enables pagination through a set of \`RelationalDivider\`."""
  allRelationalDividers(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalDivider\`."""
    orderBy: [RelationalDividersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalDividerCondition
  ): RelationalDividersConnection

  """
  Reads and enables pagination through a set of \`RelationalItemRelation\`.
  """
  allRelationalItemRelations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemRelationCondition
  ): RelationalItemRelationsConnection

  """
  Reads and enables pagination through a set of \`SingleTableItemRelation\`.
  """
  allSingleTableItemRelations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemRelationCondition
  ): SingleTableItemRelationsConnection

  """Reads and enables pagination through a set of \`LogEntry\`."""
  allLogEntries(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`LogEntry\`."""
    orderBy: [LogEntriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LogEntryCondition
  ): LogEntriesConnection

  """Reads and enables pagination through a set of \`RelationalPost\`."""
  allRelationalPosts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalPost\`."""
    orderBy: [RelationalPostsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalPostCondition
  ): RelationalPostsConnection

  """
  Reads and enables pagination through a set of \`FirstPartyVulnerability\`.
  """
  allFirstPartyVulnerabilities(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`FirstPartyVulnerability\`."""
    orderBy: [FirstPartyVulnerabilitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FirstPartyVulnerabilityCondition
  ): FirstPartyVulnerabilitiesConnection

  """
  Reads and enables pagination through a set of \`ThirdPartyVulnerability\`.
  """
  allThirdPartyVulnerabilities(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ThirdPartyVulnerability\`."""
    orderBy: [ThirdPartyVulnerabilitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ThirdPartyVulnerabilityCondition
  ): ThirdPartyVulnerabilitiesConnection

  """Reads and enables pagination through a set of \`AwsApplication\`."""
  allAwsApplications(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`AwsApplication\`."""
    orderBy: [AwsApplicationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AwsApplicationCondition
  ): AwsApplicationsConnection

  """Reads and enables pagination through a set of \`GcpApplication\`."""
  allGcpApplications(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`GcpApplication\`."""
    orderBy: [GcpApplicationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GcpApplicationCondition
  ): GcpApplicationsConnection

  """Reads and enables pagination through a set of \`SingleTableItem\`."""
  allSingleTableItems(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SingleTableItem\`."""
    orderBy: [SingleTableItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SingleTableItemCondition
  ): SingleTableItemsConnection

  """Reads and enables pagination through a set of \`RelationalItem\`."""
  allRelationalItems(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`RelationalItem\`."""
    orderBy: [RelationalItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RelationalItemCondition
  ): RelationalItemsConnection
}

type FirstPartyVulnerability implements Node & Vulnerability {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  cvssScore: Float!
  teamName: String

  """Reads and enables pagination through a set of \`Application\`."""
  applications(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Application\`."""
    orderBy: [ApplicationsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ApplicationCondition

    """Filter results to only those of the given types"""
    only: [ApplicationType!] @deprecated(reason: "EXPERIMENTAL")
  ): ApplicationsConnection!

  """Reads and enables pagination through a set of \`PersonOrOrganization\`."""
  owners: PersonOrOrganizationConnection!
}

type ThirdPartyVulnerability implements Node & Vulnerability {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  cvssScore: Float!
  vendorName: String

  """Reads and enables pagination through a set of \`Application\`."""
  applications(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Application\`."""
    orderBy: [ApplicationsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ApplicationCondition

    """Filter results to only those of the given types"""
    only: [ApplicationType!] @deprecated(reason: "EXPERIMENTAL")
  ): ApplicationsConnection!

  """Reads and enables pagination through a set of \`PersonOrOrganization\`."""
  owners: PersonOrOrganizationConnection!
}

"""A connection to a list of \`ZeroImplementation\` values."""
type ZeroImplementationsConnection {
  """A list of \`ZeroImplementation\` objects."""
  nodes: [ZeroImplementation]!

  """
  A list of edges which contains the \`ZeroImplementation\` and cursor to aid in pagination.
  """
  edges: [ZeroImplementationsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`ZeroImplementation\` you could get from the connection.
  """
  totalCount: Int!
}

interface ZeroImplementation implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int
  name: String
}

"""A \`ZeroImplementation\` edge in the connection."""
type ZeroImplementationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ZeroImplementation\` at the end of the edge."""
  node: ZeroImplementation
}

"""Methods to use when ordering \`ZeroImplementation\`."""
enum ZeroImplementationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
}

"""
A condition to be used against \`ZeroImplementation\` object types. All fields are
tested for equality and combined with a logical and.
"""
input ZeroImplementationCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`name\` field."""
  name: String
}

"""A connection to a list of \`Organization\` values."""
type OrganizationsConnection {
  """A list of \`Organization\` objects."""
  nodes: [Organization]!

  """
  A list of edges which contains the \`Organization\` and cursor to aid in pagination.
  """
  edges: [OrganizationsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Organization\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Organization\` edge in the connection."""
type OrganizationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Organization\` at the end of the edge."""
  node: Organization
}

"""Methods to use when ordering \`Organization\`."""
enum OrganizationsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  NAME_ASC
  NAME_DESC
}

"""
A condition to be used against \`Organization\` object types. All fields are
tested for equality and combined with a logical and.
"""
input OrganizationCondition {
  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: Int

  """Checks for equality with the objects \`name\` field."""
  name: String
}

"""A connection to a list of \`Person\` values."""
type PeopleConnection {
  """A list of \`Person\` objects."""
  nodes: [Person]!

  """
  A list of edges which contains the \`Person\` and cursor to aid in pagination.
  """
  edges: [PeopleEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Person\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Person\` edge in the connection."""
type PeopleEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Person\` at the end of the edge."""
  node: Person
}

"""Methods to use when ordering \`Person\`."""
enum PeopleOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  USERNAME_ASC
  USERNAME_DESC
}

"""
A condition to be used against \`Person\` object types. All fields are tested for equality and combined with a logical and.
"""
input PersonCondition {
  """Checks for equality with the objects \`personId\` field."""
  personId: Int

  """Checks for equality with the objects \`username\` field."""
  username: String
}

"""A connection to a list of \`Priority\` values."""
type PrioritiesConnection {
  """A list of \`Priority\` objects."""
  nodes: [Priority]!

  """
  A list of edges which contains the \`Priority\` and cursor to aid in pagination.
  """
  edges: [PrioritiesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Priority\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Priority\` edge in the connection."""
type PrioritiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Priority\` at the end of the edge."""
  node: Priority
}

"""A connection to a list of \`RelationalChecklist\` values."""
type RelationalChecklistsConnection {
  """A list of \`RelationalChecklist\` objects."""
  nodes: [RelationalChecklist]!

  """
  A list of edges which contains the \`RelationalChecklist\` and cursor to aid in pagination.
  """
  edges: [RelationalChecklistsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`RelationalChecklist\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`RelationalChecklist\` edge in the connection."""
type RelationalChecklistsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`RelationalChecklist\` at the end of the edge."""
  node: RelationalChecklist
}

"""Methods to use when ordering \`RelationalChecklist\`."""
enum RelationalChecklistsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TITLE_ASC
  TITLE_DESC
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  ROOT_TOPIC_ID_ASC
  ROOT_TOPIC_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  POSITION_ASC
  POSITION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IS_EXPLICITLY_ARCHIVED_ASC
  IS_EXPLICITLY_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
}

"""
A condition to be used against \`RelationalChecklist\` object types. All fields
are tested for equality and combined with a logical and.
"""
input RelationalChecklistCondition {
  """Checks for equality with the objects \`title\` field."""
  title: String

  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`type\` field."""
  type: ItemType

  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`rootTopicId\` field."""
  rootTopicId: Int

  """Checks for equality with the objects \`authorId\` field."""
  authorId: Int

  """Checks for equality with the objects \`position\` field."""
  position: BigInt

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`isExplicitlyArchived\` field."""
  isExplicitlyArchived: Boolean

  """Checks for equality with the objects \`archivedAt\` field."""
  archivedAt: Datetime
}

"""A connection to a list of \`RelationalTopic\` values."""
type RelationalTopicsConnection {
  """A list of \`RelationalTopic\` objects."""
  nodes: [RelationalTopic]!

  """
  A list of edges which contains the \`RelationalTopic\` and cursor to aid in pagination.
  """
  edges: [RelationalTopicsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`RelationalTopic\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`RelationalTopic\` edge in the connection."""
type RelationalTopicsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`RelationalTopic\` at the end of the edge."""
  node: RelationalTopic
}

"""Methods to use when ordering \`RelationalTopic\`."""
enum RelationalTopicsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TITLE_ASC
  TITLE_DESC
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  ROOT_TOPIC_ID_ASC
  ROOT_TOPIC_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  POSITION_ASC
  POSITION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IS_EXPLICITLY_ARCHIVED_ASC
  IS_EXPLICITLY_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
}

"""
A condition to be used against \`RelationalTopic\` object types. All fields are
tested for equality and combined with a logical and.
"""
input RelationalTopicCondition {
  """Checks for equality with the objects \`title\` field."""
  title: String

  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`type\` field."""
  type: ItemType

  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`rootTopicId\` field."""
  rootTopicId: Int

  """Checks for equality with the objects \`authorId\` field."""
  authorId: Int

  """Checks for equality with the objects \`position\` field."""
  position: BigInt

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`isExplicitlyArchived\` field."""
  isExplicitlyArchived: Boolean

  """Checks for equality with the objects \`archivedAt\` field."""
  archivedAt: Datetime
}

"""A connection to a list of \`RelationalChecklistItem\` values."""
type RelationalChecklistItemsConnection {
  """A list of \`RelationalChecklistItem\` objects."""
  nodes: [RelationalChecklistItem]!

  """
  A list of edges which contains the \`RelationalChecklistItem\` and cursor to aid in pagination.
  """
  edges: [RelationalChecklistItemsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`RelationalChecklistItem\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`RelationalChecklistItem\` edge in the connection."""
type RelationalChecklistItemsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`RelationalChecklistItem\` at the end of the edge."""
  node: RelationalChecklistItem
}

"""Methods to use when ordering \`RelationalChecklistItem\`."""
enum RelationalChecklistItemsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  NOTE_ASC
  NOTE_DESC
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  ROOT_TOPIC_ID_ASC
  ROOT_TOPIC_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  POSITION_ASC
  POSITION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IS_EXPLICITLY_ARCHIVED_ASC
  IS_EXPLICITLY_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
}

"""
A condition to be used against \`RelationalChecklistItem\` object types. All
fields are tested for equality and combined with a logical and.
"""
input RelationalChecklistItemCondition {
  """Checks for equality with the objects \`description\` field."""
  description: String

  """Checks for equality with the objects \`note\` field."""
  note: String

  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`type\` field."""
  type: ItemType

  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`rootTopicId\` field."""
  rootTopicId: Int

  """Checks for equality with the objects \`authorId\` field."""
  authorId: Int

  """Checks for equality with the objects \`position\` field."""
  position: BigInt

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`isExplicitlyArchived\` field."""
  isExplicitlyArchived: Boolean

  """Checks for equality with the objects \`archivedAt\` field."""
  archivedAt: Datetime
}

"""A connection to a list of \`RelationalDivider\` values."""
type RelationalDividersConnection {
  """A list of \`RelationalDivider\` objects."""
  nodes: [RelationalDivider]!

  """
  A list of edges which contains the \`RelationalDivider\` and cursor to aid in pagination.
  """
  edges: [RelationalDividersEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`RelationalDivider\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`RelationalDivider\` edge in the connection."""
type RelationalDividersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`RelationalDivider\` at the end of the edge."""
  node: RelationalDivider
}

"""Methods to use when ordering \`RelationalDivider\`."""
enum RelationalDividersOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TITLE_ASC
  TITLE_DESC
  COLOR_ASC
  COLOR_DESC
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  ROOT_TOPIC_ID_ASC
  ROOT_TOPIC_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  POSITION_ASC
  POSITION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IS_EXPLICITLY_ARCHIVED_ASC
  IS_EXPLICITLY_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
}

"""
A condition to be used against \`RelationalDivider\` object types. All fields are
tested for equality and combined with a logical and.
"""
input RelationalDividerCondition {
  """Checks for equality with the objects \`title\` field."""
  title: String

  """Checks for equality with the objects \`color\` field."""
  color: String

  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`type\` field."""
  type: ItemType

  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`rootTopicId\` field."""
  rootTopicId: Int

  """Checks for equality with the objects \`authorId\` field."""
  authorId: Int

  """Checks for equality with the objects \`position\` field."""
  position: BigInt

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`isExplicitlyArchived\` field."""
  isExplicitlyArchived: Boolean

  """Checks for equality with the objects \`archivedAt\` field."""
  archivedAt: Datetime
}

"""A connection to a list of \`RelationalPost\` values."""
type RelationalPostsConnection {
  """A list of \`RelationalPost\` objects."""
  nodes: [RelationalPost]!

  """
  A list of edges which contains the \`RelationalPost\` and cursor to aid in pagination.
  """
  edges: [RelationalPostsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`RelationalPost\` you could get from the connection."""
  totalCount: Int!
}

"""A \`RelationalPost\` edge in the connection."""
type RelationalPostsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`RelationalPost\` at the end of the edge."""
  node: RelationalPost
}

"""Methods to use when ordering \`RelationalPost\`."""
enum RelationalPostsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  NOTE_ASC
  NOTE_DESC
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  ROOT_TOPIC_ID_ASC
  ROOT_TOPIC_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  POSITION_ASC
  POSITION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IS_EXPLICITLY_ARCHIVED_ASC
  IS_EXPLICITLY_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
}

"""
A condition to be used against \`RelationalPost\` object types. All fields are
tested for equality and combined with a logical and.
"""
input RelationalPostCondition {
  """Checks for equality with the objects \`title\` field."""
  title: String

  """Checks for equality with the objects \`description\` field."""
  description: String

  """Checks for equality with the objects \`note\` field."""
  note: String

  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`type\` field."""
  type: ItemType

  """Checks for equality with the objects \`parentId\` field."""
  parentId: Int

  """Checks for equality with the objects \`rootTopicId\` field."""
  rootTopicId: Int

  """Checks for equality with the objects \`authorId\` field."""
  authorId: Int

  """Checks for equality with the objects \`position\` field."""
  position: BigInt

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`isExplicitlyArchived\` field."""
  isExplicitlyArchived: Boolean

  """Checks for equality with the objects \`archivedAt\` field."""
  archivedAt: Datetime
}

"""A connection to a list of \`FirstPartyVulnerability\` values."""
type FirstPartyVulnerabilitiesConnection {
  """A list of \`FirstPartyVulnerability\` objects."""
  nodes: [FirstPartyVulnerability]!

  """
  A list of edges which contains the \`FirstPartyVulnerability\` and cursor to aid in pagination.
  """
  edges: [FirstPartyVulnerabilitiesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`FirstPartyVulnerability\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`FirstPartyVulnerability\` edge in the connection."""
type FirstPartyVulnerabilitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`FirstPartyVulnerability\` at the end of the edge."""
  node: FirstPartyVulnerability
}

"""Methods to use when ordering \`FirstPartyVulnerability\`."""
enum FirstPartyVulnerabilitiesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CVSS_SCORE_ASC
  CVSS_SCORE_DESC
  TEAM_NAME_ASC
  TEAM_NAME_DESC
}

"""
A condition to be used against \`FirstPartyVulnerability\` object types. All
fields are tested for equality and combined with a logical and.
"""
input FirstPartyVulnerabilityCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`cvssScore\` field."""
  cvssScore: Float

  """Checks for equality with the objects \`teamName\` field."""
  teamName: String
}

"""A connection to a list of \`ThirdPartyVulnerability\` values."""
type ThirdPartyVulnerabilitiesConnection {
  """A list of \`ThirdPartyVulnerability\` objects."""
  nodes: [ThirdPartyVulnerability]!

  """
  A list of edges which contains the \`ThirdPartyVulnerability\` and cursor to aid in pagination.
  """
  edges: [ThirdPartyVulnerabilitiesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`ThirdPartyVulnerability\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`ThirdPartyVulnerability\` edge in the connection."""
type ThirdPartyVulnerabilitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ThirdPartyVulnerability\` at the end of the edge."""
  node: ThirdPartyVulnerability
}

"""Methods to use when ordering \`ThirdPartyVulnerability\`."""
enum ThirdPartyVulnerabilitiesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CVSS_SCORE_ASC
  CVSS_SCORE_DESC
  VENDOR_NAME_ASC
  VENDOR_NAME_DESC
}

"""
A condition to be used against \`ThirdPartyVulnerability\` object types. All
fields are tested for equality and combined with a logical and.
"""
input ThirdPartyVulnerabilityCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`cvssScore\` field."""
  cvssScore: Float

  """Checks for equality with the objects \`vendorName\` field."""
  vendorName: String
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  customDeleteRelationalItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CustomDeleteRelationalItemInput!
  ): CustomDeleteRelationalItemPayload

  """Creates a single \`Organization\`."""
  createOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateOrganizationInput!
  ): CreateOrganizationPayload

  """Creates a single \`Person\`."""
  createPerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePersonInput!
  ): CreatePersonPayload

  """Creates a single \`RelationalItemRelationCompositePk\`."""
  createRelationalItemRelationCompositePk(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateRelationalItemRelationCompositePkInput!
  ): CreateRelationalItemRelationCompositePkPayload

  """Creates a single \`SingleTableItemRelationCompositePk\`."""
  createSingleTableItemRelationCompositePk(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateSingleTableItemRelationCompositePkInput!
  ): CreateSingleTableItemRelationCompositePkPayload

  """Creates a single \`RelationalItemRelation\`."""
  createRelationalItemRelation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateRelationalItemRelationInput!
  ): CreateRelationalItemRelationPayload

  """Creates a single \`SingleTableItemRelation\`."""
  createSingleTableItemRelation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateSingleTableItemRelationInput!
  ): CreateSingleTableItemRelationPayload

  """Creates a single \`LogEntry\`."""
  createLogEntry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateLogEntryInput!
  ): CreateLogEntryPayload

  """Creates a single \`FirstPartyVulnerability\`."""
  createFirstPartyVulnerability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateFirstPartyVulnerabilityInput!
  ): CreateFirstPartyVulnerabilityPayload

  """Creates a single \`ThirdPartyVulnerability\`."""
  createThirdPartyVulnerability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateThirdPartyVulnerabilityInput!
  ): CreateThirdPartyVulnerabilityPayload

  """Creates a single \`AwsApplication\`."""
  createAwsApplication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAwsApplicationInput!
  ): CreateAwsApplicationPayload

  """Creates a single \`GcpApplication\`."""
  createGcpApplication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateGcpApplicationInput!
  ): CreateGcpApplicationPayload

  """
  Updates a single \`Organization\` using its globally unique id and a patch.
  """
  updateOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateOrganizationInput!
  ): UpdateOrganizationPayload

  """Updates a single \`Organization\` using a unique key and a patch."""
  updateOrganizationByOrganizationId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateOrganizationByOrganizationIdInput!
  ): UpdateOrganizationPayload

  """Updates a single \`Organization\` using a unique key and a patch."""
  updateOrganizationByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateOrganizationByNameInput!
  ): UpdateOrganizationPayload

  """Updates a single \`Person\` using its globally unique id and a patch."""
  updatePerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePersonInput!
  ): UpdatePersonPayload

  """Updates a single \`Person\` using a unique key and a patch."""
  updatePersonByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePersonByPersonIdInput!
  ): UpdatePersonPayload

  """Updates a single \`Person\` using a unique key and a patch."""
  updatePersonByUsername(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePersonByUsernameInput!
  ): UpdatePersonPayload

  """
  Updates a single \`RelationalItemRelationCompositePk\` using its globally unique id and a patch.
  """
  updateRelationalItemRelationCompositePk(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRelationalItemRelationCompositePkInput!
  ): UpdateRelationalItemRelationCompositePkPayload

  """
  Updates a single \`RelationalItemRelationCompositePk\` using a unique key and a patch.
  """
  updateRelationalItemRelationCompositePkByParentIdAndChildId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRelationalItemRelationCompositePkByParentIdAndChildIdInput!
  ): UpdateRelationalItemRelationCompositePkPayload

  """
  Updates a single \`SingleTableItemRelationCompositePk\` using its globally unique id and a patch.
  """
  updateSingleTableItemRelationCompositePk(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSingleTableItemRelationCompositePkInput!
  ): UpdateSingleTableItemRelationCompositePkPayload

  """
  Updates a single \`SingleTableItemRelationCompositePk\` using a unique key and a patch.
  """
  updateSingleTableItemRelationCompositePkByParentIdAndChildId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSingleTableItemRelationCompositePkByParentIdAndChildIdInput!
  ): UpdateSingleTableItemRelationCompositePkPayload

  """
  Updates a single \`RelationalItemRelation\` using its globally unique id and a patch.
  """
  updateRelationalItemRelation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRelationalItemRelationInput!
  ): UpdateRelationalItemRelationPayload

  """
  Updates a single \`RelationalItemRelation\` using a unique key and a patch.
  """
  updateRelationalItemRelationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRelationalItemRelationByIdInput!
  ): UpdateRelationalItemRelationPayload

  """
  Updates a single \`RelationalItemRelation\` using a unique key and a patch.
  """
  updateRelationalItemRelationByParentIdAndChildId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateRelationalItemRelationByParentIdAndChildIdInput!
  ): UpdateRelationalItemRelationPayload

  """
  Updates a single \`SingleTableItemRelation\` using its globally unique id and a patch.
  """
  updateSingleTableItemRelation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSingleTableItemRelationInput!
  ): UpdateSingleTableItemRelationPayload

  """
  Updates a single \`SingleTableItemRelation\` using a unique key and a patch.
  """
  updateSingleTableItemRelationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSingleTableItemRelationByIdInput!
  ): UpdateSingleTableItemRelationPayload

  """
  Updates a single \`SingleTableItemRelation\` using a unique key and a patch.
  """
  updateSingleTableItemRelationByParentIdAndChildId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSingleTableItemRelationByParentIdAndChildIdInput!
  ): UpdateSingleTableItemRelationPayload

  """Updates a single \`LogEntry\` using its globally unique id and a patch."""
  updateLogEntry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateLogEntryInput!
  ): UpdateLogEntryPayload

  """Updates a single \`LogEntry\` using a unique key and a patch."""
  updateLogEntryById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateLogEntryByIdInput!
  ): UpdateLogEntryPayload

  """
  Updates a single \`FirstPartyVulnerability\` using its globally unique id and a patch.
  """
  updateFirstPartyVulnerability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateFirstPartyVulnerabilityInput!
  ): UpdateFirstPartyVulnerabilityPayload

  """
  Updates a single \`FirstPartyVulnerability\` using a unique key and a patch.
  """
  updateFirstPartyVulnerabilityById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateFirstPartyVulnerabilityByIdInput!
  ): UpdateFirstPartyVulnerabilityPayload

  """
  Updates a single \`ThirdPartyVulnerability\` using its globally unique id and a patch.
  """
  updateThirdPartyVulnerability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateThirdPartyVulnerabilityInput!
  ): UpdateThirdPartyVulnerabilityPayload

  """
  Updates a single \`ThirdPartyVulnerability\` using a unique key and a patch.
  """
  updateThirdPartyVulnerabilityById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateThirdPartyVulnerabilityByIdInput!
  ): UpdateThirdPartyVulnerabilityPayload

  """
  Updates a single \`AwsApplication\` using its globally unique id and a patch.
  """
  updateAwsApplication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAwsApplicationInput!
  ): UpdateAwsApplicationPayload

  """Updates a single \`AwsApplication\` using a unique key and a patch."""
  updateAwsApplicationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAwsApplicationByIdInput!
  ): UpdateAwsApplicationPayload

  """
  Updates a single \`GcpApplication\` using its globally unique id and a patch.
  """
  updateGcpApplication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGcpApplicationInput!
  ): UpdateGcpApplicationPayload

  """Updates a single \`GcpApplication\` using a unique key and a patch."""
  updateGcpApplicationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGcpApplicationByIdInput!
  ): UpdateGcpApplicationPayload

  """Deletes a single \`Organization\` using its globally unique id."""
  deleteOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteOrganizationInput!
  ): DeleteOrganizationPayload

  """Deletes a single \`Organization\` using a unique key."""
  deleteOrganizationByOrganizationId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteOrganizationByOrganizationIdInput!
  ): DeleteOrganizationPayload

  """Deletes a single \`Organization\` using a unique key."""
  deleteOrganizationByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteOrganizationByNameInput!
  ): DeleteOrganizationPayload

  """Deletes a single \`Person\` using its globally unique id."""
  deletePerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePersonInput!
  ): DeletePersonPayload

  """Deletes a single \`Person\` using a unique key."""
  deletePersonByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePersonByPersonIdInput!
  ): DeletePersonPayload

  """Deletes a single \`Person\` using a unique key."""
  deletePersonByUsername(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePersonByUsernameInput!
  ): DeletePersonPayload

  """
  Deletes a single \`RelationalItemRelationCompositePk\` using its globally unique id.
  """
  deleteRelationalItemRelationCompositePk(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRelationalItemRelationCompositePkInput!
  ): DeleteRelationalItemRelationCompositePkPayload

  """
  Deletes a single \`RelationalItemRelationCompositePk\` using a unique key.
  """
  deleteRelationalItemRelationCompositePkByParentIdAndChildId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRelationalItemRelationCompositePkByParentIdAndChildIdInput!
  ): DeleteRelationalItemRelationCompositePkPayload

  """
  Deletes a single \`SingleTableItemRelationCompositePk\` using its globally unique id.
  """
  deleteSingleTableItemRelationCompositePk(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSingleTableItemRelationCompositePkInput!
  ): DeleteSingleTableItemRelationCompositePkPayload

  """
  Deletes a single \`SingleTableItemRelationCompositePk\` using a unique key.
  """
  deleteSingleTableItemRelationCompositePkByParentIdAndChildId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSingleTableItemRelationCompositePkByParentIdAndChildIdInput!
  ): DeleteSingleTableItemRelationCompositePkPayload

  """
  Deletes a single \`RelationalItemRelation\` using its globally unique id.
  """
  deleteRelationalItemRelation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRelationalItemRelationInput!
  ): DeleteRelationalItemRelationPayload

  """Deletes a single \`RelationalItemRelation\` using a unique key."""
  deleteRelationalItemRelationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRelationalItemRelationByIdInput!
  ): DeleteRelationalItemRelationPayload

  """Deletes a single \`RelationalItemRelation\` using a unique key."""
  deleteRelationalItemRelationByParentIdAndChildId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteRelationalItemRelationByParentIdAndChildIdInput!
  ): DeleteRelationalItemRelationPayload

  """
  Deletes a single \`SingleTableItemRelation\` using its globally unique id.
  """
  deleteSingleTableItemRelation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSingleTableItemRelationInput!
  ): DeleteSingleTableItemRelationPayload

  """Deletes a single \`SingleTableItemRelation\` using a unique key."""
  deleteSingleTableItemRelationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSingleTableItemRelationByIdInput!
  ): DeleteSingleTableItemRelationPayload

  """Deletes a single \`SingleTableItemRelation\` using a unique key."""
  deleteSingleTableItemRelationByParentIdAndChildId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSingleTableItemRelationByParentIdAndChildIdInput!
  ): DeleteSingleTableItemRelationPayload

  """Deletes a single \`LogEntry\` using its globally unique id."""
  deleteLogEntry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteLogEntryInput!
  ): DeleteLogEntryPayload

  """Deletes a single \`LogEntry\` using a unique key."""
  deleteLogEntryById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteLogEntryByIdInput!
  ): DeleteLogEntryPayload

  """
  Deletes a single \`FirstPartyVulnerability\` using its globally unique id.
  """
  deleteFirstPartyVulnerability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteFirstPartyVulnerabilityInput!
  ): DeleteFirstPartyVulnerabilityPayload

  """Deletes a single \`FirstPartyVulnerability\` using a unique key."""
  deleteFirstPartyVulnerabilityById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteFirstPartyVulnerabilityByIdInput!
  ): DeleteFirstPartyVulnerabilityPayload

  """
  Deletes a single \`ThirdPartyVulnerability\` using its globally unique id.
  """
  deleteThirdPartyVulnerability(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteThirdPartyVulnerabilityInput!
  ): DeleteThirdPartyVulnerabilityPayload

  """Deletes a single \`ThirdPartyVulnerability\` using a unique key."""
  deleteThirdPartyVulnerabilityById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteThirdPartyVulnerabilityByIdInput!
  ): DeleteThirdPartyVulnerabilityPayload

  """Deletes a single \`AwsApplication\` using its globally unique id."""
  deleteAwsApplication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAwsApplicationInput!
  ): DeleteAwsApplicationPayload

  """Deletes a single \`AwsApplication\` using a unique key."""
  deleteAwsApplicationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAwsApplicationByIdInput!
  ): DeleteAwsApplicationPayload

  """Deletes a single \`GcpApplication\` using its globally unique id."""
  deleteGcpApplication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGcpApplicationInput!
  ): DeleteGcpApplicationPayload

  """Deletes a single \`GcpApplication\` using a unique key."""
  deleteGcpApplicationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGcpApplicationByIdInput!
  ): DeleteGcpApplicationPayload
}

"""The output of our \`customDeleteRelationalItem\` mutation."""
type CustomDeleteRelationalItemPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  boolean: Boolean

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`customDeleteRelationalItem\` mutation."""
input CustomDeleteRelationalItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  nodeId: ID
}

"""The output of our create \`Organization\` mutation."""
type CreateOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was created by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationsEdge
}

"""All input for the create \`Organization\` mutation."""
input CreateOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Organization\` to be created by this mutation."""
  organization: OrganizationInput!
}

"""An input for mutations affecting \`Organization\`"""
input OrganizationInput {
  organizationId: Int
  name: String!
}

"""The output of our create \`Person\` mutation."""
type CreatePersonPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Person\` that was created by this mutation."""
  person: Person

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Person\`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the create \`Person\` mutation."""
input CreatePersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Person\` to be created by this mutation."""
  person: PersonInput!
}

"""An input for mutations affecting \`Person\`"""
input PersonInput {
  personId: Int
  username: String!
}

"""The output of our create \`RelationalItemRelationCompositePk\` mutation."""
type CreateRelationalItemRelationCompositePkPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The \`RelationalItemRelationCompositePk\` that was created by this mutation.
  """
  relationalItemRelationCompositePk: RelationalItemRelationCompositePk

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our \`RelationalItemRelationCompositePk\`. May be used by Relay 1.
  """
  relationalItemRelationCompositePkEdge(
    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!]! = [PRIMARY_KEY_ASC]
  ): RelationalItemRelationCompositePksEdge

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelationCompositePk\`.
  """
  relationalItemByChildId: RelationalItem

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelationCompositePk\`.
  """
  relationalItemByParentId: RelationalItem
}

"""All input for the create \`RelationalItemRelationCompositePk\` mutation."""
input CreateRelationalItemRelationCompositePkInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The \`RelationalItemRelationCompositePk\` to be created by this mutation.
  """
  relationalItemRelationCompositePk: RelationalItemRelationCompositePkInput!
}

"""An input for mutations affecting \`RelationalItemRelationCompositePk\`"""
input RelationalItemRelationCompositePkInput {
  parentId: Int!
  childId: Int!
}

"""
The output of our create \`SingleTableItemRelationCompositePk\` mutation.
"""
type CreateSingleTableItemRelationCompositePkPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The \`SingleTableItemRelationCompositePk\` that was created by this mutation.
  """
  singleTableItemRelationCompositePk: SingleTableItemRelationCompositePk

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our \`SingleTableItemRelationCompositePk\`. May be used by Relay 1.
  """
  singleTableItemRelationCompositePkEdge(
    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SingleTableItemRelationCompositePksEdge

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemByChildId: SingleTableItem

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemByParentId: SingleTableItem
}

"""
All input for the create \`SingleTableItemRelationCompositePk\` mutation.
"""
input CreateSingleTableItemRelationCompositePkInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The \`SingleTableItemRelationCompositePk\` to be created by this mutation.
  """
  singleTableItemRelationCompositePk: SingleTableItemRelationCompositePkInput!
}

"""An input for mutations affecting \`SingleTableItemRelationCompositePk\`"""
input SingleTableItemRelationCompositePkInput {
  parentId: Int!
  childId: Int!
}

"""The output of our create \`RelationalItemRelation\` mutation."""
type CreateRelationalItemRelationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`RelationalItemRelation\` that was created by this mutation."""
  relationalItemRelation: RelationalItemRelation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`RelationalItemRelation\`. May be used by Relay 1."""
  relationalItemRelationEdge(
    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): RelationalItemRelationsEdge

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelation\`.
  """
  relationalItemByChildId: RelationalItem

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelation\`.
  """
  relationalItemByParentId: RelationalItem
}

"""All input for the create \`RelationalItemRelation\` mutation."""
input CreateRelationalItemRelationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`RelationalItemRelation\` to be created by this mutation."""
  relationalItemRelation: RelationalItemRelationInput!
}

"""An input for mutations affecting \`RelationalItemRelation\`"""
input RelationalItemRelationInput {
  id: Int
  parentId: Int!
  childId: Int!
}

"""The output of our create \`SingleTableItemRelation\` mutation."""
type CreateSingleTableItemRelationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SingleTableItemRelation\` that was created by this mutation."""
  singleTableItemRelation: SingleTableItemRelation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SingleTableItemRelation\`. May be used by Relay 1."""
  singleTableItemRelationEdge(
    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SingleTableItemRelationsEdge

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelation\`.
  """
  singleTableItemByChildId: SingleTableItem

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelation\`.
  """
  singleTableItemByParentId: SingleTableItem
}

"""All input for the create \`SingleTableItemRelation\` mutation."""
input CreateSingleTableItemRelationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`SingleTableItemRelation\` to be created by this mutation."""
  singleTableItemRelation: SingleTableItemRelationInput!
}

"""An input for mutations affecting \`SingleTableItemRelation\`"""
input SingleTableItemRelationInput {
  id: Int
  parentId: Int!
  childId: Int!
}

"""The output of our create \`LogEntry\` mutation."""
type CreateLogEntryPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`LogEntry\` that was created by this mutation."""
  logEntry: LogEntry

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`LogEntry\`. May be used by Relay 1."""
  logEntryEdge(
    """The method to use when ordering \`LogEntry\`."""
    orderBy: [LogEntriesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LogEntriesEdge

  """Reads a single \`Organization\` that is related to this \`LogEntry\`."""
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`LogEntry\`."""
  personByPersonId: Person
}

"""All input for the create \`LogEntry\` mutation."""
input CreateLogEntryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`LogEntry\` to be created by this mutation."""
  logEntry: LogEntryInput!
}

"""An input for mutations affecting \`LogEntry\`"""
input LogEntryInput {
  id: Int
  personId: Int
  organizationId: Int
  text: String!
}

"""The output of our create \`FirstPartyVulnerability\` mutation."""
type CreateFirstPartyVulnerabilityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`FirstPartyVulnerability\` that was created by this mutation."""
  firstPartyVulnerability: FirstPartyVulnerability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`FirstPartyVulnerability\`. May be used by Relay 1."""
  firstPartyVulnerabilityEdge(
    """The method to use when ordering \`FirstPartyVulnerability\`."""
    orderBy: [FirstPartyVulnerabilitiesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): FirstPartyVulnerabilitiesEdge
}

"""All input for the create \`FirstPartyVulnerability\` mutation."""
input CreateFirstPartyVulnerabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`FirstPartyVulnerability\` to be created by this mutation."""
  firstPartyVulnerability: FirstPartyVulnerabilityInput!
}

"""An input for mutations affecting \`FirstPartyVulnerability\`"""
input FirstPartyVulnerabilityInput {
  id: Int!
  name: String!
  cvssScore: Float!
  teamName: String
}

"""The output of our create \`ThirdPartyVulnerability\` mutation."""
type CreateThirdPartyVulnerabilityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ThirdPartyVulnerability\` that was created by this mutation."""
  thirdPartyVulnerability: ThirdPartyVulnerability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ThirdPartyVulnerability\`. May be used by Relay 1."""
  thirdPartyVulnerabilityEdge(
    """The method to use when ordering \`ThirdPartyVulnerability\`."""
    orderBy: [ThirdPartyVulnerabilitiesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ThirdPartyVulnerabilitiesEdge
}

"""All input for the create \`ThirdPartyVulnerability\` mutation."""
input CreateThirdPartyVulnerabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`ThirdPartyVulnerability\` to be created by this mutation."""
  thirdPartyVulnerability: ThirdPartyVulnerabilityInput!
}

"""An input for mutations affecting \`ThirdPartyVulnerability\`"""
input ThirdPartyVulnerabilityInput {
  id: Int!
  name: String!
  cvssScore: Float!
  vendorName: String
}

"""The output of our create \`AwsApplication\` mutation."""
type CreateAwsApplicationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`AwsApplication\` that was created by this mutation."""
  awsApplication: AwsApplication

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`AwsApplication\`. May be used by Relay 1."""
  awsApplicationEdge(
    """The method to use when ordering \`AwsApplication\`."""
    orderBy: [AwsApplicationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AwsApplicationsEdge

  """
  Reads a single \`Organization\` that is related to this \`AwsApplication\`.
  """
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`AwsApplication\`."""
  personByPersonId: Person
}

"""All input for the create \`AwsApplication\` mutation."""
input CreateAwsApplicationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`AwsApplication\` to be created by this mutation."""
  awsApplication: AwsApplicationInput!
}

"""An input for mutations affecting \`AwsApplication\`"""
input AwsApplicationInput {
  id: Int!
  name: String!
  lastDeployed: Datetime
  personId: Int
  organizationId: Int
  awsId: String
}

"""The output of our create \`GcpApplication\` mutation."""
type CreateGcpApplicationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GcpApplication\` that was created by this mutation."""
  gcpApplication: GcpApplication

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GcpApplication\`. May be used by Relay 1."""
  gcpApplicationEdge(
    """The method to use when ordering \`GcpApplication\`."""
    orderBy: [GcpApplicationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GcpApplicationsEdge

  """
  Reads a single \`Organization\` that is related to this \`GcpApplication\`.
  """
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`GcpApplication\`."""
  personByPersonId: Person
}

"""All input for the create \`GcpApplication\` mutation."""
input CreateGcpApplicationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`GcpApplication\` to be created by this mutation."""
  gcpApplication: GcpApplicationInput!
}

"""An input for mutations affecting \`GcpApplication\`"""
input GcpApplicationInput {
  id: Int!
  name: String!
  lastDeployed: Datetime
  personId: Int
  organizationId: Int
  gcpId: String
}

"""The output of our update \`Organization\` mutation."""
type UpdateOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was updated by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationsEdge
}

"""All input for the \`updateOrganization\` mutation."""
input UpdateOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Organization\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`Organization\` being updated.
  """
  organizationPatch: OrganizationPatch!
}

"""
Represents an update to a \`Organization\`. Fields that are set will be updated.
"""
input OrganizationPatch {
  organizationId: Int
  name: String
}

"""All input for the \`updateOrganizationByOrganizationId\` mutation."""
input UpdateOrganizationByOrganizationIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  organizationId: Int!

  """
  An object where the defined keys will be set on the \`Organization\` being updated.
  """
  organizationPatch: OrganizationPatch!
}

"""All input for the \`updateOrganizationByName\` mutation."""
input UpdateOrganizationByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!

  """
  An object where the defined keys will be set on the \`Organization\` being updated.
  """
  organizationPatch: OrganizationPatch!
}

"""The output of our update \`Person\` mutation."""
type UpdatePersonPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Person\` that was updated by this mutation."""
  person: Person

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Person\`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the \`updatePerson\` mutation."""
input UpdatePersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Person\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`Person\` being updated.
  """
  personPatch: PersonPatch!
}

"""
Represents an update to a \`Person\`. Fields that are set will be updated.
"""
input PersonPatch {
  personId: Int
  username: String
}

"""All input for the \`updatePersonByPersonId\` mutation."""
input UpdatePersonByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!

  """
  An object where the defined keys will be set on the \`Person\` being updated.
  """
  personPatch: PersonPatch!
}

"""All input for the \`updatePersonByUsername\` mutation."""
input UpdatePersonByUsernameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  username: String!

  """
  An object where the defined keys will be set on the \`Person\` being updated.
  """
  personPatch: PersonPatch!
}

"""The output of our update \`RelationalItemRelationCompositePk\` mutation."""
type UpdateRelationalItemRelationCompositePkPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The \`RelationalItemRelationCompositePk\` that was updated by this mutation.
  """
  relationalItemRelationCompositePk: RelationalItemRelationCompositePk

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our \`RelationalItemRelationCompositePk\`. May be used by Relay 1.
  """
  relationalItemRelationCompositePkEdge(
    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!]! = [PRIMARY_KEY_ASC]
  ): RelationalItemRelationCompositePksEdge

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelationCompositePk\`.
  """
  relationalItemByChildId: RelationalItem

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelationCompositePk\`.
  """
  relationalItemByParentId: RelationalItem
}

"""All input for the \`updateRelationalItemRelationCompositePk\` mutation."""
input UpdateRelationalItemRelationCompositePkInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`RelationalItemRelationCompositePk\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`RelationalItemRelationCompositePk\` being updated.
  """
  relationalItemRelationCompositePkPatch: RelationalItemRelationCompositePkPatch!
}

"""
Represents an update to a \`RelationalItemRelationCompositePk\`. Fields that are set will be updated.
"""
input RelationalItemRelationCompositePkPatch {
  parentId: Int
  childId: Int
}

"""
All input for the \`updateRelationalItemRelationCompositePkByParentIdAndChildId\` mutation.
"""
input UpdateRelationalItemRelationCompositePkByParentIdAndChildIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  parentId: Int!
  childId: Int!

  """
  An object where the defined keys will be set on the \`RelationalItemRelationCompositePk\` being updated.
  """
  relationalItemRelationCompositePkPatch: RelationalItemRelationCompositePkPatch!
}

"""
The output of our update \`SingleTableItemRelationCompositePk\` mutation.
"""
type UpdateSingleTableItemRelationCompositePkPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The \`SingleTableItemRelationCompositePk\` that was updated by this mutation.
  """
  singleTableItemRelationCompositePk: SingleTableItemRelationCompositePk

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our \`SingleTableItemRelationCompositePk\`. May be used by Relay 1.
  """
  singleTableItemRelationCompositePkEdge(
    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SingleTableItemRelationCompositePksEdge

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemByChildId: SingleTableItem

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemByParentId: SingleTableItem
}

"""All input for the \`updateSingleTableItemRelationCompositePk\` mutation."""
input UpdateSingleTableItemRelationCompositePkInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`SingleTableItemRelationCompositePk\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`SingleTableItemRelationCompositePk\` being updated.
  """
  singleTableItemRelationCompositePkPatch: SingleTableItemRelationCompositePkPatch!
}

"""
Represents an update to a \`SingleTableItemRelationCompositePk\`. Fields that are set will be updated.
"""
input SingleTableItemRelationCompositePkPatch {
  parentId: Int
  childId: Int
}

"""
All input for the \`updateSingleTableItemRelationCompositePkByParentIdAndChildId\` mutation.
"""
input UpdateSingleTableItemRelationCompositePkByParentIdAndChildIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  parentId: Int!
  childId: Int!

  """
  An object where the defined keys will be set on the \`SingleTableItemRelationCompositePk\` being updated.
  """
  singleTableItemRelationCompositePkPatch: SingleTableItemRelationCompositePkPatch!
}

"""The output of our update \`RelationalItemRelation\` mutation."""
type UpdateRelationalItemRelationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`RelationalItemRelation\` that was updated by this mutation."""
  relationalItemRelation: RelationalItemRelation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`RelationalItemRelation\`. May be used by Relay 1."""
  relationalItemRelationEdge(
    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): RelationalItemRelationsEdge

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelation\`.
  """
  relationalItemByChildId: RelationalItem

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelation\`.
  """
  relationalItemByParentId: RelationalItem
}

"""All input for the \`updateRelationalItemRelation\` mutation."""
input UpdateRelationalItemRelationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`RelationalItemRelation\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`RelationalItemRelation\` being updated.
  """
  relationalItemRelationPatch: RelationalItemRelationPatch!
}

"""
Represents an update to a \`RelationalItemRelation\`. Fields that are set will be updated.
"""
input RelationalItemRelationPatch {
  id: Int
  parentId: Int
  childId: Int
}

"""All input for the \`updateRelationalItemRelationById\` mutation."""
input UpdateRelationalItemRelationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`RelationalItemRelation\` being updated.
  """
  relationalItemRelationPatch: RelationalItemRelationPatch!
}

"""
All input for the \`updateRelationalItemRelationByParentIdAndChildId\` mutation.
"""
input UpdateRelationalItemRelationByParentIdAndChildIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  parentId: Int!
  childId: Int!

  """
  An object where the defined keys will be set on the \`RelationalItemRelation\` being updated.
  """
  relationalItemRelationPatch: RelationalItemRelationPatch!
}

"""The output of our update \`SingleTableItemRelation\` mutation."""
type UpdateSingleTableItemRelationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SingleTableItemRelation\` that was updated by this mutation."""
  singleTableItemRelation: SingleTableItemRelation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SingleTableItemRelation\`. May be used by Relay 1."""
  singleTableItemRelationEdge(
    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SingleTableItemRelationsEdge

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelation\`.
  """
  singleTableItemByChildId: SingleTableItem

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelation\`.
  """
  singleTableItemByParentId: SingleTableItem
}

"""All input for the \`updateSingleTableItemRelation\` mutation."""
input UpdateSingleTableItemRelationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`SingleTableItemRelation\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`SingleTableItemRelation\` being updated.
  """
  singleTableItemRelationPatch: SingleTableItemRelationPatch!
}

"""
Represents an update to a \`SingleTableItemRelation\`. Fields that are set will be updated.
"""
input SingleTableItemRelationPatch {
  id: Int
  parentId: Int
  childId: Int
}

"""All input for the \`updateSingleTableItemRelationById\` mutation."""
input UpdateSingleTableItemRelationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`SingleTableItemRelation\` being updated.
  """
  singleTableItemRelationPatch: SingleTableItemRelationPatch!
}

"""
All input for the \`updateSingleTableItemRelationByParentIdAndChildId\` mutation.
"""
input UpdateSingleTableItemRelationByParentIdAndChildIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  parentId: Int!
  childId: Int!

  """
  An object where the defined keys will be set on the \`SingleTableItemRelation\` being updated.
  """
  singleTableItemRelationPatch: SingleTableItemRelationPatch!
}

"""The output of our update \`LogEntry\` mutation."""
type UpdateLogEntryPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`LogEntry\` that was updated by this mutation."""
  logEntry: LogEntry

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`LogEntry\`. May be used by Relay 1."""
  logEntryEdge(
    """The method to use when ordering \`LogEntry\`."""
    orderBy: [LogEntriesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LogEntriesEdge

  """Reads a single \`Organization\` that is related to this \`LogEntry\`."""
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`LogEntry\`."""
  personByPersonId: Person
}

"""All input for the \`updateLogEntry\` mutation."""
input UpdateLogEntryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`LogEntry\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`LogEntry\` being updated.
  """
  logEntryPatch: LogEntryPatch!
}

"""
Represents an update to a \`LogEntry\`. Fields that are set will be updated.
"""
input LogEntryPatch {
  id: Int
  personId: Int
  organizationId: Int
  text: String
}

"""All input for the \`updateLogEntryById\` mutation."""
input UpdateLogEntryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`LogEntry\` being updated.
  """
  logEntryPatch: LogEntryPatch!
}

"""The output of our update \`FirstPartyVulnerability\` mutation."""
type UpdateFirstPartyVulnerabilityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`FirstPartyVulnerability\` that was updated by this mutation."""
  firstPartyVulnerability: FirstPartyVulnerability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`FirstPartyVulnerability\`. May be used by Relay 1."""
  firstPartyVulnerabilityEdge(
    """The method to use when ordering \`FirstPartyVulnerability\`."""
    orderBy: [FirstPartyVulnerabilitiesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): FirstPartyVulnerabilitiesEdge
}

"""All input for the \`updateFirstPartyVulnerability\` mutation."""
input UpdateFirstPartyVulnerabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`FirstPartyVulnerability\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`FirstPartyVulnerability\` being updated.
  """
  firstPartyVulnerabilityPatch: FirstPartyVulnerabilityPatch!
}

"""
Represents an update to a \`FirstPartyVulnerability\`. Fields that are set will be updated.
"""
input FirstPartyVulnerabilityPatch {
  id: Int
  name: String
  cvssScore: Float
  teamName: String
}

"""All input for the \`updateFirstPartyVulnerabilityById\` mutation."""
input UpdateFirstPartyVulnerabilityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`FirstPartyVulnerability\` being updated.
  """
  firstPartyVulnerabilityPatch: FirstPartyVulnerabilityPatch!
}

"""The output of our update \`ThirdPartyVulnerability\` mutation."""
type UpdateThirdPartyVulnerabilityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ThirdPartyVulnerability\` that was updated by this mutation."""
  thirdPartyVulnerability: ThirdPartyVulnerability

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ThirdPartyVulnerability\`. May be used by Relay 1."""
  thirdPartyVulnerabilityEdge(
    """The method to use when ordering \`ThirdPartyVulnerability\`."""
    orderBy: [ThirdPartyVulnerabilitiesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ThirdPartyVulnerabilitiesEdge
}

"""All input for the \`updateThirdPartyVulnerability\` mutation."""
input UpdateThirdPartyVulnerabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`ThirdPartyVulnerability\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`ThirdPartyVulnerability\` being updated.
  """
  thirdPartyVulnerabilityPatch: ThirdPartyVulnerabilityPatch!
}

"""
Represents an update to a \`ThirdPartyVulnerability\`. Fields that are set will be updated.
"""
input ThirdPartyVulnerabilityPatch {
  id: Int
  name: String
  cvssScore: Float
  vendorName: String
}

"""All input for the \`updateThirdPartyVulnerabilityById\` mutation."""
input UpdateThirdPartyVulnerabilityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`ThirdPartyVulnerability\` being updated.
  """
  thirdPartyVulnerabilityPatch: ThirdPartyVulnerabilityPatch!
}

"""The output of our update \`AwsApplication\` mutation."""
type UpdateAwsApplicationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`AwsApplication\` that was updated by this mutation."""
  awsApplication: AwsApplication

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`AwsApplication\`. May be used by Relay 1."""
  awsApplicationEdge(
    """The method to use when ordering \`AwsApplication\`."""
    orderBy: [AwsApplicationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AwsApplicationsEdge

  """
  Reads a single \`Organization\` that is related to this \`AwsApplication\`.
  """
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`AwsApplication\`."""
  personByPersonId: Person
}

"""All input for the \`updateAwsApplication\` mutation."""
input UpdateAwsApplicationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`AwsApplication\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`AwsApplication\` being updated.
  """
  awsApplicationPatch: AwsApplicationPatch!
}

"""
Represents an update to a \`AwsApplication\`. Fields that are set will be updated.
"""
input AwsApplicationPatch {
  id: Int
  name: String
  lastDeployed: Datetime
  personId: Int
  organizationId: Int
  awsId: String
}

"""All input for the \`updateAwsApplicationById\` mutation."""
input UpdateAwsApplicationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`AwsApplication\` being updated.
  """
  awsApplicationPatch: AwsApplicationPatch!
}

"""The output of our update \`GcpApplication\` mutation."""
type UpdateGcpApplicationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GcpApplication\` that was updated by this mutation."""
  gcpApplication: GcpApplication

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GcpApplication\`. May be used by Relay 1."""
  gcpApplicationEdge(
    """The method to use when ordering \`GcpApplication\`."""
    orderBy: [GcpApplicationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GcpApplicationsEdge

  """
  Reads a single \`Organization\` that is related to this \`GcpApplication\`.
  """
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`GcpApplication\`."""
  personByPersonId: Person
}

"""All input for the \`updateGcpApplication\` mutation."""
input UpdateGcpApplicationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`GcpApplication\` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the \`GcpApplication\` being updated.
  """
  gcpApplicationPatch: GcpApplicationPatch!
}

"""
Represents an update to a \`GcpApplication\`. Fields that are set will be updated.
"""
input GcpApplicationPatch {
  id: Int
  name: String
  lastDeployed: Datetime
  personId: Int
  organizationId: Int
  gcpId: String
}

"""All input for the \`updateGcpApplicationById\` mutation."""
input UpdateGcpApplicationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`GcpApplication\` being updated.
  """
  gcpApplicationPatch: GcpApplicationPatch!
}

"""The output of our delete \`Organization\` mutation."""
type DeleteOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was deleted by this mutation."""
  organization: Organization
  deletedOrganizationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationsEdge
}

"""All input for the \`deleteOrganization\` mutation."""
input DeleteOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Organization\` to be deleted.
  """
  nodeId: ID!
}

"""All input for the \`deleteOrganizationByOrganizationId\` mutation."""
input DeleteOrganizationByOrganizationIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  organizationId: Int!
}

"""All input for the \`deleteOrganizationByName\` mutation."""
input DeleteOrganizationByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""The output of our delete \`Person\` mutation."""
type DeletePersonPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Person\` that was deleted by this mutation."""
  person: Person
  deletedPersonId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Person\`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the \`deletePerson\` mutation."""
input DeletePersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Person\` to be deleted.
  """
  nodeId: ID!
}

"""All input for the \`deletePersonByPersonId\` mutation."""
input DeletePersonByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!
}

"""All input for the \`deletePersonByUsername\` mutation."""
input DeletePersonByUsernameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  username: String!
}

"""The output of our delete \`RelationalItemRelationCompositePk\` mutation."""
type DeleteRelationalItemRelationCompositePkPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The \`RelationalItemRelationCompositePk\` that was deleted by this mutation.
  """
  relationalItemRelationCompositePk: RelationalItemRelationCompositePk
  deletedRelationalItemRelationCompositePkId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our \`RelationalItemRelationCompositePk\`. May be used by Relay 1.
  """
  relationalItemRelationCompositePkEdge(
    """The method to use when ordering \`RelationalItemRelationCompositePk\`."""
    orderBy: [RelationalItemRelationCompositePksOrderBy!]! = [PRIMARY_KEY_ASC]
  ): RelationalItemRelationCompositePksEdge

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelationCompositePk\`.
  """
  relationalItemByChildId: RelationalItem

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelationCompositePk\`.
  """
  relationalItemByParentId: RelationalItem
}

"""All input for the \`deleteRelationalItemRelationCompositePk\` mutation."""
input DeleteRelationalItemRelationCompositePkInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`RelationalItemRelationCompositePk\` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the \`deleteRelationalItemRelationCompositePkByParentIdAndChildId\` mutation.
"""
input DeleteRelationalItemRelationCompositePkByParentIdAndChildIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  parentId: Int!
  childId: Int!
}

"""
The output of our delete \`SingleTableItemRelationCompositePk\` mutation.
"""
type DeleteSingleTableItemRelationCompositePkPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The \`SingleTableItemRelationCompositePk\` that was deleted by this mutation.
  """
  singleTableItemRelationCompositePk: SingleTableItemRelationCompositePk
  deletedSingleTableItemRelationCompositePkId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our \`SingleTableItemRelationCompositePk\`. May be used by Relay 1.
  """
  singleTableItemRelationCompositePkEdge(
    """The method to use when ordering \`SingleTableItemRelationCompositePk\`."""
    orderBy: [SingleTableItemRelationCompositePksOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SingleTableItemRelationCompositePksEdge

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemByChildId: SingleTableItem

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelationCompositePk\`.
  """
  singleTableItemByParentId: SingleTableItem
}

"""All input for the \`deleteSingleTableItemRelationCompositePk\` mutation."""
input DeleteSingleTableItemRelationCompositePkInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`SingleTableItemRelationCompositePk\` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the \`deleteSingleTableItemRelationCompositePkByParentIdAndChildId\` mutation.
"""
input DeleteSingleTableItemRelationCompositePkByParentIdAndChildIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  parentId: Int!
  childId: Int!
}

"""The output of our delete \`RelationalItemRelation\` mutation."""
type DeleteRelationalItemRelationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`RelationalItemRelation\` that was deleted by this mutation."""
  relationalItemRelation: RelationalItemRelation
  deletedRelationalItemRelationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`RelationalItemRelation\`. May be used by Relay 1."""
  relationalItemRelationEdge(
    """The method to use when ordering \`RelationalItemRelation\`."""
    orderBy: [RelationalItemRelationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): RelationalItemRelationsEdge

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelation\`.
  """
  relationalItemByChildId: RelationalItem

  """
  Reads a single \`RelationalItem\` that is related to this \`RelationalItemRelation\`.
  """
  relationalItemByParentId: RelationalItem
}

"""All input for the \`deleteRelationalItemRelation\` mutation."""
input DeleteRelationalItemRelationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`RelationalItemRelation\` to be deleted.
  """
  nodeId: ID!
}

"""All input for the \`deleteRelationalItemRelationById\` mutation."""
input DeleteRelationalItemRelationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""
All input for the \`deleteRelationalItemRelationByParentIdAndChildId\` mutation.
"""
input DeleteRelationalItemRelationByParentIdAndChildIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  parentId: Int!
  childId: Int!
}

"""The output of our delete \`SingleTableItemRelation\` mutation."""
type DeleteSingleTableItemRelationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SingleTableItemRelation\` that was deleted by this mutation."""
  singleTableItemRelation: SingleTableItemRelation
  deletedSingleTableItemRelationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SingleTableItemRelation\`. May be used by Relay 1."""
  singleTableItemRelationEdge(
    """The method to use when ordering \`SingleTableItemRelation\`."""
    orderBy: [SingleTableItemRelationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SingleTableItemRelationsEdge

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelation\`.
  """
  singleTableItemByChildId: SingleTableItem

  """
  Reads a single \`SingleTableItem\` that is related to this \`SingleTableItemRelation\`.
  """
  singleTableItemByParentId: SingleTableItem
}

"""All input for the \`deleteSingleTableItemRelation\` mutation."""
input DeleteSingleTableItemRelationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`SingleTableItemRelation\` to be deleted.
  """
  nodeId: ID!
}

"""All input for the \`deleteSingleTableItemRelationById\` mutation."""
input DeleteSingleTableItemRelationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""
All input for the \`deleteSingleTableItemRelationByParentIdAndChildId\` mutation.
"""
input DeleteSingleTableItemRelationByParentIdAndChildIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  parentId: Int!
  childId: Int!
}

"""The output of our delete \`LogEntry\` mutation."""
type DeleteLogEntryPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`LogEntry\` that was deleted by this mutation."""
  logEntry: LogEntry
  deletedLogEntryId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`LogEntry\`. May be used by Relay 1."""
  logEntryEdge(
    """The method to use when ordering \`LogEntry\`."""
    orderBy: [LogEntriesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LogEntriesEdge

  """Reads a single \`Organization\` that is related to this \`LogEntry\`."""
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`LogEntry\`."""
  personByPersonId: Person
}

"""All input for the \`deleteLogEntry\` mutation."""
input DeleteLogEntryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`LogEntry\` to be deleted.
  """
  nodeId: ID!
}

"""All input for the \`deleteLogEntryById\` mutation."""
input DeleteLogEntryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`FirstPartyVulnerability\` mutation."""
type DeleteFirstPartyVulnerabilityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`FirstPartyVulnerability\` that was deleted by this mutation."""
  firstPartyVulnerability: FirstPartyVulnerability
  deletedFirstPartyVulnerabilityId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`FirstPartyVulnerability\`. May be used by Relay 1."""
  firstPartyVulnerabilityEdge(
    """The method to use when ordering \`FirstPartyVulnerability\`."""
    orderBy: [FirstPartyVulnerabilitiesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): FirstPartyVulnerabilitiesEdge
}

"""All input for the \`deleteFirstPartyVulnerability\` mutation."""
input DeleteFirstPartyVulnerabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`FirstPartyVulnerability\` to be deleted.
  """
  nodeId: ID!
}

"""All input for the \`deleteFirstPartyVulnerabilityById\` mutation."""
input DeleteFirstPartyVulnerabilityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`ThirdPartyVulnerability\` mutation."""
type DeleteThirdPartyVulnerabilityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ThirdPartyVulnerability\` that was deleted by this mutation."""
  thirdPartyVulnerability: ThirdPartyVulnerability
  deletedThirdPartyVulnerabilityId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ThirdPartyVulnerability\`. May be used by Relay 1."""
  thirdPartyVulnerabilityEdge(
    """The method to use when ordering \`ThirdPartyVulnerability\`."""
    orderBy: [ThirdPartyVulnerabilitiesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ThirdPartyVulnerabilitiesEdge
}

"""All input for the \`deleteThirdPartyVulnerability\` mutation."""
input DeleteThirdPartyVulnerabilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`ThirdPartyVulnerability\` to be deleted.
  """
  nodeId: ID!
}

"""All input for the \`deleteThirdPartyVulnerabilityById\` mutation."""
input DeleteThirdPartyVulnerabilityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`AwsApplication\` mutation."""
type DeleteAwsApplicationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`AwsApplication\` that was deleted by this mutation."""
  awsApplication: AwsApplication
  deletedAwsApplicationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`AwsApplication\`. May be used by Relay 1."""
  awsApplicationEdge(
    """The method to use when ordering \`AwsApplication\`."""
    orderBy: [AwsApplicationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AwsApplicationsEdge

  """
  Reads a single \`Organization\` that is related to this \`AwsApplication\`.
  """
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`AwsApplication\`."""
  personByPersonId: Person
}

"""All input for the \`deleteAwsApplication\` mutation."""
input DeleteAwsApplicationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`AwsApplication\` to be deleted.
  """
  nodeId: ID!
}

"""All input for the \`deleteAwsApplicationById\` mutation."""
input DeleteAwsApplicationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`GcpApplication\` mutation."""
type DeleteGcpApplicationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GcpApplication\` that was deleted by this mutation."""
  gcpApplication: GcpApplication
  deletedGcpApplicationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GcpApplication\`. May be used by Relay 1."""
  gcpApplicationEdge(
    """The method to use when ordering \`GcpApplication\`."""
    orderBy: [GcpApplicationsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GcpApplicationsEdge

  """
  Reads a single \`Organization\` that is related to this \`GcpApplication\`.
  """
  organizationByOrganizationId: Organization

  """Reads a single \`Person\` that is related to this \`GcpApplication\`."""
  personByPersonId: Person
}

"""All input for the \`deleteGcpApplication\` mutation."""
input DeleteGcpApplicationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`GcpApplication\` to be deleted.
  """
  nodeId: ID!
}

"""All input for the \`deleteGcpApplicationById\` mutation."""
input DeleteGcpApplicationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}`;
export const plans = {
  SingleTableTopic: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    title($record) {
      return $record.get("title");
    },
    personByAuthorId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("author_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("parent_id")
      });
    },
    singleTableItemsByParentId: {
      plan($record) {
        const $records = resource_single_table_itemsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableTopic_singleTableItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    rootTopic($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("root_topic_id")
      });
    }
  },
  Person: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler2.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler2.codec.name].encode);
    },
    personId($record) {
      return $record.get("person_id");
    },
    username($record) {
      return $record.get("username");
    },
    logEntriesByPersonId: {
      plan($record) {
        const $records = otherSource_log_entriesPgResource.find({
          person_id: $record.get("person_id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_logEntriesByPersonId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_logEntriesByPersonId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_logEntriesByPersonId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_logEntriesByPersonId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_logEntriesByPersonId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("LogEntriesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemsByAuthorId: {
      plan($record) {
        const $records = resource_single_table_itemsPgResource.find({
          author_id: $record.get("person_id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_singleTableItemsByAuthorId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_singleTableItemsByAuthorId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_singleTableItemsByAuthorId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_singleTableItemsByAuthorId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_singleTableItemsByAuthorId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemsByAuthorId: {
      plan($record) {
        const $records = otherSource_relational_itemsPgResource.find({
          author_id: $record.get("person_id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_relationalItemsByAuthorId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_relationalItemsByAuthorId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_relationalItemsByAuthorId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_relationalItemsByAuthorId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_relationalItemsByAuthorId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    awsApplicationsByPersonId: {
      plan($record) {
        const $records = otherSource_aws_applicationsPgResource.find({
          person_id: $record.get("person_id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_awsApplicationsByPersonId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_awsApplicationsByPersonId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_awsApplicationsByPersonId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_awsApplicationsByPersonId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_awsApplicationsByPersonId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("AwsApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    gcpApplicationsByPersonId: {
      plan($record) {
        const $records = otherSource_gcp_applicationsPgResource.find({
          person_id: $record.get("person_id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_gcpApplicationsByPersonId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_gcpApplicationsByPersonId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_gcpApplicationsByPersonId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_gcpApplicationsByPersonId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_gcpApplicationsByPersonId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("GcpApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    applications: {
      plan($parent) {
        const $record = undefined ? $parent.get("result") : $parent;
        for (let i = 0, l = paths.length; i < l; i++) {
          const path = paths[i];
          const firstLayer = path.layers[0];
          const member = members[i];
          member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
            memo[firstLayer.remoteAttributes[idx]] = {
              step: $record.get(col)
            };
            return memo;
          }, Object.create(null));
        }
        const $list = pgUnionAll({
          attributes: attributes_object_Object_6,
          resourceByTypeName,
          members,
          name: "applications"
        });
        if (true) {
          return connection($list);
        } else if (false) {
          return $list.single();
        } else {
          return $list;
        }
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_applications_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_applications_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_applications_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_applications_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_applications_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        },
        only: {
          autoApplyAfterParentPlan: true,
          applyPlan($parent, $connection, fieldArgs) {
            const $union = $connection.getSubplan();
            $union.limitToTypes(fieldArgs.getRaw().eval());
          }
        }
      }
    }
  },
  LogEntriesConnection: {
    __assertStep: ConnectionStep,
    nodes: LogEntriesConnection_nodesPlan,
    edges: LogEntriesConnection_edgesPlan,
    pageInfo: LogEntriesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  LogEntry: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler3.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler3.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    personId($record) {
      return $record.get("person_id");
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    text($record) {
      return $record.get("text");
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("person_id")
      });
    },
    author($parent) {
      const $record = undefined ? $parent.get("result") : $parent;
      for (let i = 0, l = paths2.length; i < l; i++) {
        const path = paths2[i];
        const firstLayer = path.layers[0];
        const member = members2[i];
        member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
          memo[firstLayer.remoteAttributes[idx]] = {
            step: $record.get(col)
          };
          return memo;
        }, Object.create(null));
      }
      const $list = pgUnionAll({
        attributes: attributes19,
        resourceByTypeName: resourceByTypeName2,
        members: members2,
        name: "author"
      });
      if (false) {
        return connection($list);
      } else if (true) {
        return $list.single();
      } else {
        return $list;
      }
    }
  },
  Organization: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler4.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler4.codec.name].encode);
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    name($record) {
      return $record.get("name");
    },
    logEntriesByOrganizationId: {
      plan($record) {
        const $records = otherSource_log_entriesPgResource.find({
          organization_id: $record.get("organization_id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_logEntriesByOrganizationId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_logEntriesByOrganizationId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_logEntriesByOrganizationId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_logEntriesByOrganizationId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_logEntriesByOrganizationId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("LogEntriesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    awsApplicationsByOrganizationId: {
      plan($record) {
        const $records = otherSource_aws_applicationsPgResource.find({
          organization_id: $record.get("organization_id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_awsApplicationsByOrganizationId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_awsApplicationsByOrganizationId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_awsApplicationsByOrganizationId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_awsApplicationsByOrganizationId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_awsApplicationsByOrganizationId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("AwsApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    gcpApplicationsByOrganizationId: {
      plan($record) {
        const $records = otherSource_gcp_applicationsPgResource.find({
          organization_id: $record.get("organization_id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_gcpApplicationsByOrganizationId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_gcpApplicationsByOrganizationId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_gcpApplicationsByOrganizationId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_gcpApplicationsByOrganizationId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Organization_gcpApplicationsByOrganizationId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("GcpApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  LogEntriesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques16[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_logEntries_logEntries.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques16[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_logEntries_logEntries.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ORGANIZATION_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "organization_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ORGANIZATION_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "organization_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TEXT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "text",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TEXT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "text",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  LogEntryCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes15.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes15.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "organization_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "organization_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes15.organization_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    text: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "text",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "text",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes15.text.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  AwsApplicationsConnection: {
    __assertStep: ConnectionStep,
    nodes: AwsApplicationsConnection_nodesPlan,
    edges: AwsApplicationsConnection_edgesPlan,
    pageInfo: AwsApplicationsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  AwsApplication: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler5.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler5.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    name($record) {
      return $record.get("name");
    },
    lastDeployed($record) {
      return $record.get("last_deployed");
    },
    personId($record) {
      return $record.get("person_id");
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    awsId($record) {
      return $record.get("aws_id");
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("person_id")
      });
    },
    vulnerabilities: {
      plan($parent) {
        const $record = undefined ? $parent.get("result") : $parent;
        for (let i = 0, l = paths3.length; i < l; i++) {
          const path = paths3[i];
          const firstLayer = path.layers[0];
          const member = members3[i];
          member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
            memo[firstLayer.remoteAttributes[idx]] = {
              step: $record.get(col)
            };
            return memo;
          }, Object.create(null));
        }
        const $list = pgUnionAll({
          attributes: attributes_object_Object_7,
          resourceByTypeName: resourceByTypeName3,
          members: members3,
          name: "vulnerabilities"
        });
        if (true) {
          return connection($list);
        } else if (false) {
          return $list.single();
        } else {
          return $list;
        }
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: AwsApplication_vulnerabilities_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: AwsApplication_vulnerabilities_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: AwsApplication_vulnerabilities_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: AwsApplication_vulnerabilities_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: AwsApplication_vulnerabilities_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("VulnerabilitiesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        },
        only: {
          autoApplyAfterParentPlan: true,
          applyPlan($parent, $connection, fieldArgs) {
            const $union = $connection.getSubplan();
            $union.limitToTypes(fieldArgs.getRaw().eval());
          }
        }
      }
    },
    owner($parent) {
      const $record = undefined ? $parent.get("result") : $parent;
      for (let i = 0, l = paths4.length; i < l; i++) {
        const path = paths4[i];
        const firstLayer = path.layers[0];
        const member = members4[i];
        member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
          memo[firstLayer.remoteAttributes[idx]] = {
            step: $record.get(col)
          };
          return memo;
        }, Object.create(null));
      }
      const $list = pgUnionAll({
        attributes: attributes20,
        resourceByTypeName: resourceByTypeName4,
        members: members4,
        name: "owner"
      });
      if (false) {
        return connection($list);
      } else if (true) {
        return $list.single();
      } else {
        return $list;
      }
    }
  },
  VulnerabilitiesConnection: {
    __assertStep: ConnectionStep,
    nodes: VulnerabilitiesConnection_nodesPlan,
    edges: VulnerabilitiesConnection_edgesPlan,
    pageInfo: VulnerabilitiesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ApplicationsConnection: {
    __assertStep: ConnectionStep,
    nodes: ApplicationsConnection_nodesPlan,
    edges: ApplicationsConnection_edgesPlan,
    pageInfo: ApplicationsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ApplicationsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PageInfo: {
    __assertStep: assertPageInfoCapableStep,
    hasNextPage: PageInfo_hasNextPagePlan,
    hasPreviousPage: PageInfo_hasPreviousPagePlan,
    startCursor($pageInfo) {
      return $pageInfo.startCursor();
    },
    endCursor($pageInfo) {
      return $pageInfo.endCursor();
    }
  },
  PersonOrOrganizationConnection: {
    __assertStep: ConnectionStep,
    nodes: PersonOrOrganizationConnection_nodesPlan,
    edges: PersonOrOrganizationConnection_edgesPlan,
    pageInfo: PersonOrOrganizationConnection_pageInfoPlan
  },
  PersonOrOrganizationEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  VulnerabilitiesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  VulnerabilitiesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CVSS_SCORE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cvss_score",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CVSS_SCORE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cvss_score",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  VulnerabilityCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_7.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_7.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cvssScore: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "cvss_score",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "cvss_score",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_7.cvss_score.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  AwsApplicationsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  AwsApplicationsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques20[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_awsApplications_awsApplications.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques20[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_awsApplications_awsApplications.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_DEPLOYED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_deployed",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_DEPLOYED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_deployed",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ORGANIZATION_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "organization_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ORGANIZATION_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "organization_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AWS_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "aws_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AWS_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "aws_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  AwsApplicationCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_4.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_4.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastDeployed: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "last_deployed",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "last_deployed",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_4.last_deployed.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_4.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "organization_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "organization_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_4.organization_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    awsId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "aws_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "aws_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_4.aws_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  GcpApplicationsConnection: {
    __assertStep: ConnectionStep,
    nodes: GcpApplicationsConnection_nodesPlan,
    edges: GcpApplicationsConnection_edgesPlan,
    pageInfo: GcpApplicationsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  GcpApplication: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler6.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler6.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    name($record) {
      return $record.get("name");
    },
    lastDeployed($record) {
      return $record.get("last_deployed");
    },
    personId($record) {
      return $record.get("person_id");
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    gcpId($record) {
      return $record.get("gcp_id");
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("person_id")
      });
    },
    vulnerabilities: {
      plan($parent) {
        const $record = undefined ? $parent.get("result") : $parent;
        for (let i = 0, l = paths5.length; i < l; i++) {
          const path = paths5[i];
          const firstLayer = path.layers[0];
          const member = members5[i];
          member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
            memo[firstLayer.remoteAttributes[idx]] = {
              step: $record.get(col)
            };
            return memo;
          }, Object.create(null));
        }
        const $list = pgUnionAll({
          attributes: attributes_object_Object_7,
          resourceByTypeName: resourceByTypeName5,
          members: members5,
          name: "vulnerabilities"
        });
        if (true) {
          return connection($list);
        } else if (false) {
          return $list.single();
        } else {
          return $list;
        }
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: GcpApplication_vulnerabilities_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: GcpApplication_vulnerabilities_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: GcpApplication_vulnerabilities_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: GcpApplication_vulnerabilities_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: GcpApplication_vulnerabilities_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("VulnerabilitiesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        },
        only: {
          autoApplyAfterParentPlan: true,
          applyPlan($parent, $connection, fieldArgs) {
            const $union = $connection.getSubplan();
            $union.limitToTypes(fieldArgs.getRaw().eval());
          }
        }
      }
    },
    owner($parent) {
      const $record = undefined ? $parent.get("result") : $parent;
      for (let i = 0, l = paths6.length; i < l; i++) {
        const path = paths6[i];
        const firstLayer = path.layers[0];
        const member = members6[i];
        member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
          memo[firstLayer.remoteAttributes[idx]] = {
            step: $record.get(col)
          };
          return memo;
        }, Object.create(null));
      }
      const $list = pgUnionAll({
        attributes: attributes21,
        resourceByTypeName: resourceByTypeName6,
        members: members6,
        name: "owner"
      });
      if (false) {
        return connection($list);
      } else if (true) {
        return $list.single();
      } else {
        return $list;
      }
    }
  },
  GcpApplicationsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  GcpApplicationsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques21[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_gcpApplications_gcpApplications.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques21[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_gcpApplications_gcpApplications.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_DEPLOYED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_deployed",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_DEPLOYED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_deployed",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ORGANIZATION_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "organization_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ORGANIZATION_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "organization_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    GCP_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "gcp_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    GCP_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "gcp_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  GcpApplicationCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_5.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_5.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastDeployed: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "last_deployed",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "last_deployed",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_5.last_deployed.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_5.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "organization_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "organization_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_5.organization_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    gcpId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "gcp_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "gcp_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_5.gcp_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  LogEntriesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  SingleTableItemsConnection: {
    __assertStep: ConnectionStep,
    nodes: SingleTableItemsConnection_nodesPlan,
    edges: SingleTableItemsConnection_edgesPlan,
    pageInfo: SingleTableItemsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  SingleTableItemsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  SingleTableItemsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques22[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_singleTableItems_singleTableItems.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques22[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_singleTableItems_singleTableItems.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  SingleTableItemCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    type: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rootTopicId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.root_topic_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.author_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    position: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.position.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.created_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.updated_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isExplicitlyArchived: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.is_explicitly_archived.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    archivedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.archived_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  RelationalItemsConnection: {
    __assertStep: ConnectionStep,
    nodes: RelationalItemsConnection_nodesPlan,
    edges: RelationalItemsConnection_edgesPlan,
    pageInfo: RelationalItemsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  RelationalItemRelationsConnection: {
    __assertStep: ConnectionStep,
    nodes: RelationalItemRelationsConnection_nodesPlan,
    edges: RelationalItemRelationsConnection_edgesPlan,
    pageInfo: RelationalItemRelationsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  RelationalItemRelation: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler7.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler7.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    childId($record) {
      return $record.get("child_id");
    },
    relationalItemByChildId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("child_id")
      });
    },
    relationalItemByParentId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("parent_id")
      });
    }
  },
  RelationalItemRelationsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  RelationalItemRelationCompositePksConnection: {
    __assertStep: ConnectionStep,
    nodes: RelationalItemRelationCompositePksConnection_nodesPlan,
    edges: RelationalItemRelationCompositePksConnection_edgesPlan,
    pageInfo: RelationalItemRelationCompositePksConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  RelationalItemRelationCompositePk: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler8.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler8.codec.name].encode);
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    childId($record) {
      return $record.get("child_id");
    },
    relationalItemByChildId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("child_id")
      });
    },
    relationalItemByParentId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("parent_id")
      });
    }
  },
  RelationalItemRelationCompositePksEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  RelationalItemsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  RelationalItemsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques23[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalItems_relationalItems.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques23[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalItems_relationalItems.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  RelationalItemCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    type: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rootTopicId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.root_topic_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.author_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    position: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.position.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.created_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.updated_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isExplicitlyArchived: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.is_explicitly_archived.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    archivedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.archived_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ApplicationsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_DEPLOYED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_deployed",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_DEPLOYED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_deployed",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ApplicationCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_6.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_6.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastDeployed: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "last_deployed",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "last_deployed",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_6.last_deployed.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SingleTableItemRelationsConnection: {
    __assertStep: ConnectionStep,
    nodes: SingleTableItemRelationsConnection_nodesPlan,
    edges: SingleTableItemRelationsConnection_edgesPlan,
    pageInfo: SingleTableItemRelationsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  SingleTableItemRelation: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler9.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler9.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    childId($record) {
      return $record.get("child_id");
    },
    singleTableItemByChildId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("child_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("parent_id")
      });
    }
  },
  SingleTableItemRelationsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  SingleTableItemRelationCompositePksConnection: {
    __assertStep: ConnectionStep,
    nodes: SingleTableItemRelationCompositePksConnection_nodesPlan,
    edges: SingleTableItemRelationCompositePksConnection_edgesPlan,
    pageInfo: SingleTableItemRelationCompositePksConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  SingleTableItemRelationCompositePk: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler10.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler10.codec.name].encode);
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    childId($record) {
      return $record.get("child_id");
    },
    singleTableItemByChildId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("child_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("parent_id")
      });
    }
  },
  SingleTableItemRelationCompositePksEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  SingleTableItemRelationsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques15[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_singleTableItemRelations_singleTableItemRelations.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques15[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_singleTableItemRelations_singleTableItemRelations.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    CHILD_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "child_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CHILD_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "child_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  SingleTableItemRelationCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes14.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes14.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "child_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "child_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes14.child_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SingleTableItemRelationCompositePksOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques11[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_singleTableItemRelationCompositePks_singleTableItemRelationCompositePks.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques11[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_singleTableItemRelationCompositePks_singleTableItemRelationCompositePks.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    CHILD_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "child_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CHILD_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "child_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  SingleTableItemRelationCompositePkCondition: {
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes10.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "child_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "child_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes10.child_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SingleTablePost: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler11.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler11.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    subject($record) {
      return $record.get("title");
    },
    description($record) {
      return $record.get("description");
    },
    note($record) {
      return $record.get("note");
    },
    priorityId($record) {
      return $record.get("priority_id");
    },
    personByAuthorId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("author_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("parent_id")
      });
    },
    priorityByPriorityId($record) {
      return otherSource_prioritiesPgResource.get({
        id: $record.get("priority_id")
      });
    },
    singleTableItemsByParentId: {
      plan($record) {
        const $records = resource_single_table_itemsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTablePost_singleTableItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    rootTopic($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("root_topic_id")
      });
    }
  },
  Priority: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler12.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler12.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    title($record) {
      return $record.get("title");
    },
    singleTableItemsByPriorityId: {
      plan($record) {
        const $records = resource_single_table_itemsPgResource.find({
          priority_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Priority_singleTableItemsByPriorityId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Priority_singleTableItemsByPriorityId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Priority_singleTableItemsByPriorityId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Priority_singleTableItemsByPriorityId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Priority_singleTableItemsByPriorityId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  SingleTableDivider: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler13.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler13.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    title($record) {
      return $record.get("title");
    },
    color($record) {
      return $record.get("color");
    },
    personByAuthorId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("author_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("parent_id")
      });
    },
    singleTableItemsByParentId: {
      plan($record) {
        const $records = resource_single_table_itemsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableDivider_singleTableItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    rootTopic($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("root_topic_id")
      });
    }
  },
  SingleTableChecklist: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler14.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler14.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    title($record) {
      return $record.get("title");
    },
    personByAuthorId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("author_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("parent_id")
      });
    },
    singleTableItemsByParentId: {
      plan($record) {
        const $records = resource_single_table_itemsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklist_singleTableItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    rootTopic($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("root_topic_id")
      });
    },
    rootChecklistTopic($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("root_topic_id")
      });
    }
  },
  SingleTableChecklistItem: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler15.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler15.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    description($record) {
      return $record.get("description");
    },
    note($record) {
      return $record.get("note");
    },
    priorityId($record) {
      return $record.get("priority_id");
    },
    personByAuthorId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("author_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("parent_id")
      });
    },
    priorityByPriorityId($record) {
      return otherSource_prioritiesPgResource.get({
        id: $record.get("priority_id")
      });
    },
    singleTableItemsByParentId: {
      plan($record) {
        const $records = resource_single_table_itemsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationsByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relationsPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByChildId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          child_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    singleTableItemRelationCompositePksByParentId: {
      plan($record) {
        const $records = otherSource_single_table_item_relation_composite_pksPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: SingleTableChecklistItem_singleTableItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    rootTopic($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("root_topic_id")
      });
    }
  },
  RelationalTopic: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler16.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler16.codec.name].encode);
    },
    title($record) {
      return $record.get("title");
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    relationalItemsByRootTopicId: {
      plan($record) {
        const $records = otherSource_relational_itemsPgResource.find({
          root_topic_id: $record.get("topic_item_id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByRootTopicId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByRootTopicId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByRootTopicId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByRootTopicId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByRootTopicId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    personByAuthorId($record) {
      const $people = otherSource_peoplePgResource.find();
      let previousAlias = $people.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $people.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("person_id")} = ${relational_itemsAlias}.${sql.identifier("author_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $people.where(sql`${previousAlias}.${sql.identifier("id")} = ${$people.placeholder($record.get("topic_item_id"))}`);
      return $people.single();
    },
    relationalItemByParentId($record) {
      const $relational_items = otherSource_relational_itemsPgResource.find();
      let previousAlias = $relational_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("id")} = ${relational_itemsAlias}.${sql.identifier("parent_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("topic_item_id"))}`);
      return $relational_items.single();
    },
    relationalTopicByRootTopicId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("root_topic_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("topic_item_id"))}`);
      return $relational_topics.single();
    },
    relationalItemsByParentId: {
      plan($record) {
        const $relational_items = otherSource_relational_itemsPgResource.find();
        let previousAlias = $relational_items.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_items.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("topic_item_id"))}`);
        return connection($relational_items);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalTopicByTopicItemId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("topic_item_id"))}`);
      return $relational_topics.single();
    },
    relationalPostByPostItemId($record) {
      const $relational_posts = relational_posts_relational_postsPgResource.find();
      let previousAlias = $relational_posts.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_posts.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("post_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_posts.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_posts.placeholder($record.get("topic_item_id"))}`);
      return $relational_posts.single();
    },
    relationalDividerByDividerItemId($record) {
      const $relational_dividers = relational_dividers_relational_dividersPgResource.find();
      let previousAlias = $relational_dividers.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_dividers.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("divider_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_dividers.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_dividers.placeholder($record.get("topic_item_id"))}`);
      return $relational_dividers.single();
    },
    relationalChecklistByChecklistItemId($record) {
      const $relational_checklists = relational_checklists_relational_checklistsPgResource.find();
      let previousAlias = $relational_checklists.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklists.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklists.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklists.placeholder($record.get("topic_item_id"))}`);
      return $relational_checklists.single();
    },
    relationalChecklistItemByChecklistItemItemId($record) {
      const $relational_checklist_items = relational_checklist_items_relational_checklist_itemsPgResource.find();
      let previousAlias = $relational_checklist_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklist_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklist_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklist_items.placeholder($record.get("topic_item_id"))}`);
      return $relational_checklist_items.single();
    },
    relationalItemRelationsByChildId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("topic_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationsByParentId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("topic_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByChildId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("topic_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByParentId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("topic_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalTopic_relationalItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  RelationalItemRelationsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques14[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalItemRelations_relationalItemRelations.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques14[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalItemRelations_relationalItemRelations.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    CHILD_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "child_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CHILD_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "child_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  RelationalItemRelationCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes13.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes13.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "child_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "child_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes13.child_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  RelationalItemRelationCompositePksOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques9[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalItemRelationCompositePks_relationalItemRelationCompositePks.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques9[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalItemRelationCompositePks_relationalItemRelationCompositePks.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    CHILD_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "child_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CHILD_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "child_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  RelationalItemRelationCompositePkCondition: {
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes8.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "child_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "child_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes8.child_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  RelationalPost: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler17.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler17.codec.name].encode);
    },
    title($record) {
      return $record.get("title");
    },
    description($record) {
      return $record.get("description");
    },
    note($record) {
      return $record.get("note");
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    personByAuthorId($record) {
      const $people = otherSource_peoplePgResource.find();
      let previousAlias = $people.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $people.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("person_id")} = ${relational_itemsAlias}.${sql.identifier("author_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $people.where(sql`${previousAlias}.${sql.identifier("id")} = ${$people.placeholder($record.get("post_item_id"))}`);
      return $people.single();
    },
    relationalItemByParentId($record) {
      const $relational_items = otherSource_relational_itemsPgResource.find();
      let previousAlias = $relational_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("id")} = ${relational_itemsAlias}.${sql.identifier("parent_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("post_item_id"))}`);
      return $relational_items.single();
    },
    relationalTopicByRootTopicId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("root_topic_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("post_item_id"))}`);
      return $relational_topics.single();
    },
    relationalItemsByParentId: {
      plan($record) {
        const $relational_items = otherSource_relational_itemsPgResource.find();
        let previousAlias = $relational_items.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_items.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("post_item_id"))}`);
        return connection($relational_items);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalTopicByTopicItemId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("post_item_id"))}`);
      return $relational_topics.single();
    },
    relationalPostByPostItemId($record) {
      const $relational_posts = relational_posts_relational_postsPgResource.find();
      let previousAlias = $relational_posts.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_posts.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("post_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_posts.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_posts.placeholder($record.get("post_item_id"))}`);
      return $relational_posts.single();
    },
    relationalDividerByDividerItemId($record) {
      const $relational_dividers = relational_dividers_relational_dividersPgResource.find();
      let previousAlias = $relational_dividers.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_dividers.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("divider_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_dividers.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_dividers.placeholder($record.get("post_item_id"))}`);
      return $relational_dividers.single();
    },
    relationalChecklistByChecklistItemId($record) {
      const $relational_checklists = relational_checklists_relational_checklistsPgResource.find();
      let previousAlias = $relational_checklists.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklists.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklists.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklists.placeholder($record.get("post_item_id"))}`);
      return $relational_checklists.single();
    },
    relationalChecklistItemByChecklistItemItemId($record) {
      const $relational_checklist_items = relational_checklist_items_relational_checklist_itemsPgResource.find();
      let previousAlias = $relational_checklist_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklist_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklist_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklist_items.placeholder($record.get("post_item_id"))}`);
      return $relational_checklist_items.single();
    },
    relationalItemRelationsByChildId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("post_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationsByParentId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("post_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByChildId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("post_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByParentId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("post_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalPost_relationalItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  RelationalDivider: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler18.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler18.codec.name].encode);
    },
    title($record) {
      return $record.get("title");
    },
    color($record) {
      return $record.get("color");
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    personByAuthorId($record) {
      const $people = otherSource_peoplePgResource.find();
      let previousAlias = $people.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $people.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("person_id")} = ${relational_itemsAlias}.${sql.identifier("author_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $people.where(sql`${previousAlias}.${sql.identifier("id")} = ${$people.placeholder($record.get("divider_item_id"))}`);
      return $people.single();
    },
    relationalItemByParentId($record) {
      const $relational_items = otherSource_relational_itemsPgResource.find();
      let previousAlias = $relational_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("id")} = ${relational_itemsAlias}.${sql.identifier("parent_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("divider_item_id"))}`);
      return $relational_items.single();
    },
    relationalTopicByRootTopicId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("root_topic_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("divider_item_id"))}`);
      return $relational_topics.single();
    },
    relationalItemsByParentId: {
      plan($record) {
        const $relational_items = otherSource_relational_itemsPgResource.find();
        let previousAlias = $relational_items.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_items.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("divider_item_id"))}`);
        return connection($relational_items);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalTopicByTopicItemId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("divider_item_id"))}`);
      return $relational_topics.single();
    },
    relationalPostByPostItemId($record) {
      const $relational_posts = relational_posts_relational_postsPgResource.find();
      let previousAlias = $relational_posts.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_posts.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("post_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_posts.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_posts.placeholder($record.get("divider_item_id"))}`);
      return $relational_posts.single();
    },
    relationalDividerByDividerItemId($record) {
      const $relational_dividers = relational_dividers_relational_dividersPgResource.find();
      let previousAlias = $relational_dividers.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_dividers.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("divider_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_dividers.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_dividers.placeholder($record.get("divider_item_id"))}`);
      return $relational_dividers.single();
    },
    relationalChecklistByChecklistItemId($record) {
      const $relational_checklists = relational_checklists_relational_checklistsPgResource.find();
      let previousAlias = $relational_checklists.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklists.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklists.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklists.placeholder($record.get("divider_item_id"))}`);
      return $relational_checklists.single();
    },
    relationalChecklistItemByChecklistItemItemId($record) {
      const $relational_checklist_items = relational_checklist_items_relational_checklist_itemsPgResource.find();
      let previousAlias = $relational_checklist_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklist_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklist_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklist_items.placeholder($record.get("divider_item_id"))}`);
      return $relational_checklist_items.single();
    },
    relationalItemRelationsByChildId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("divider_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationsByParentId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("divider_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByChildId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("divider_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByParentId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("divider_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalDivider_relationalItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  RelationalChecklist: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler19.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler19.codec.name].encode);
    },
    title($record) {
      return $record.get("title");
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    personByAuthorId($record) {
      const $people = otherSource_peoplePgResource.find();
      let previousAlias = $people.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $people.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("person_id")} = ${relational_itemsAlias}.${sql.identifier("author_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $people.where(sql`${previousAlias}.${sql.identifier("id")} = ${$people.placeholder($record.get("checklist_item_id"))}`);
      return $people.single();
    },
    relationalItemByParentId($record) {
      const $relational_items = otherSource_relational_itemsPgResource.find();
      let previousAlias = $relational_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("id")} = ${relational_itemsAlias}.${sql.identifier("parent_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("checklist_item_id"))}`);
      return $relational_items.single();
    },
    relationalTopicByRootTopicId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("root_topic_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("checklist_item_id"))}`);
      return $relational_topics.single();
    },
    relationalItemsByParentId: {
      plan($record) {
        const $relational_items = otherSource_relational_itemsPgResource.find();
        let previousAlias = $relational_items.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_items.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("checklist_item_id"))}`);
        return connection($relational_items);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalTopicByTopicItemId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("checklist_item_id"))}`);
      return $relational_topics.single();
    },
    relationalPostByPostItemId($record) {
      const $relational_posts = relational_posts_relational_postsPgResource.find();
      let previousAlias = $relational_posts.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_posts.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("post_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_posts.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_posts.placeholder($record.get("checklist_item_id"))}`);
      return $relational_posts.single();
    },
    relationalDividerByDividerItemId($record) {
      const $relational_dividers = relational_dividers_relational_dividersPgResource.find();
      let previousAlias = $relational_dividers.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_dividers.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("divider_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_dividers.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_dividers.placeholder($record.get("checklist_item_id"))}`);
      return $relational_dividers.single();
    },
    relationalChecklistByChecklistItemId($record) {
      const $relational_checklists = relational_checklists_relational_checklistsPgResource.find();
      let previousAlias = $relational_checklists.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklists.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklists.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklists.placeholder($record.get("checklist_item_id"))}`);
      return $relational_checklists.single();
    },
    relationalChecklistItemByChecklistItemItemId($record) {
      const $relational_checklist_items = relational_checklist_items_relational_checklist_itemsPgResource.find();
      let previousAlias = $relational_checklist_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklist_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklist_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklist_items.placeholder($record.get("checklist_item_id"))}`);
      return $relational_checklist_items.single();
    },
    relationalItemRelationsByChildId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("checklist_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationsByParentId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("checklist_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByChildId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("checklist_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByParentId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("checklist_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklist_relationalItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  RelationalChecklistItem: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = handler20.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler20.codec.name].encode);
    },
    description($record) {
      return $record.get("description");
    },
    note($record) {
      return $record.get("note");
    },
    id($record) {
      return $record.get("id");
    },
    type($record) {
      return $record.get("type");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    rootTopicId($record) {
      return $record.get("root_topic_id");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    position($record) {
      return $record.get("position");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    isExplicitlyArchived($record) {
      return $record.get("is_explicitly_archived");
    },
    archivedAt($record) {
      return $record.get("archived_at");
    },
    personByAuthorId($record) {
      const $people = otherSource_peoplePgResource.find();
      let previousAlias = $people.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $people.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("person_id")} = ${relational_itemsAlias}.${sql.identifier("author_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $people.where(sql`${previousAlias}.${sql.identifier("id")} = ${$people.placeholder($record.get("checklist_item_item_id"))}`);
      return $people.single();
    },
    relationalItemByParentId($record) {
      const $relational_items = otherSource_relational_itemsPgResource.find();
      let previousAlias = $relational_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("id")} = ${relational_itemsAlias}.${sql.identifier("parent_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("checklist_item_item_id"))}`);
      return $relational_items.single();
    },
    relationalTopicByRootTopicId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("root_topic_id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("checklist_item_item_id"))}`);
      return $relational_topics.single();
    },
    relationalItemsByParentId: {
      plan($record) {
        const $relational_items = otherSource_relational_itemsPgResource.find();
        let previousAlias = $relational_items.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_items.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_items.placeholder($record.get("checklist_item_item_id"))}`);
        return connection($relational_items);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalTopicByTopicItemId($record) {
      const $relational_topics = pgResource_relational_topicsPgResource.find();
      let previousAlias = $relational_topics.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_topics.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("topic_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_topics.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_topics.placeholder($record.get("checklist_item_item_id"))}`);
      return $relational_topics.single();
    },
    relationalPostByPostItemId($record) {
      const $relational_posts = relational_posts_relational_postsPgResource.find();
      let previousAlias = $relational_posts.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_posts.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("post_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_posts.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_posts.placeholder($record.get("checklist_item_item_id"))}`);
      return $relational_posts.single();
    },
    relationalDividerByDividerItemId($record) {
      const $relational_dividers = relational_dividers_relational_dividersPgResource.find();
      let previousAlias = $relational_dividers.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_dividers.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("divider_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_dividers.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_dividers.placeholder($record.get("checklist_item_item_id"))}`);
      return $relational_dividers.single();
    },
    relationalChecklistByChecklistItemId($record) {
      const $relational_checklists = relational_checklists_relational_checklistsPgResource.find();
      let previousAlias = $relational_checklists.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklists.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklists.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklists.placeholder($record.get("checklist_item_item_id"))}`);
      return $relational_checklists.single();
    },
    relationalChecklistItemByChecklistItemItemId($record) {
      const $relational_checklist_items = relational_checklist_items_relational_checklist_itemsPgResource.find();
      let previousAlias = $relational_checklist_items.alias;
      const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
      $relational_checklist_items.join({
        type: "inner",
        from: otherSource_relational_itemsPgResource.from,
        alias: relational_itemsAlias,
        conditions: [sql`${previousAlias}.${sql.identifier("checklist_item_item_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
      });
      previousAlias = relational_itemsAlias;
      $relational_checklist_items.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_checklist_items.placeholder($record.get("checklist_item_item_id"))}`);
      return $relational_checklist_items.single();
    },
    relationalItemRelationsByChildId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("checklist_item_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationsByParentId: {
      plan($record) {
        const $relational_item_relations = pgResource_relational_item_relationsPgResource.find();
        let previousAlias = $relational_item_relations.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relations.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relations.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relations.placeholder($record.get("checklist_item_item_id"))}`);
        return connection($relational_item_relations);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationsByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByChildId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("child_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("checklist_item_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByChildId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByChildId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByChildId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByChildId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByChildId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    relationalItemRelationCompositePksByParentId: {
      plan($record) {
        const $relational_item_relation_composite_pks = pgResource_relational_item_relation_composite_pksPgResource.find();
        let previousAlias = $relational_item_relation_composite_pks.alias;
        const relational_itemsAlias = sql.identifier(Symbol("relational_items"));
        $relational_item_relation_composite_pks.join({
          type: "inner",
          from: otherSource_relational_itemsPgResource.from,
          alias: relational_itemsAlias,
          conditions: [sql`${previousAlias}.${sql.identifier("parent_id")} = ${relational_itemsAlias}.${sql.identifier("id")}`]
        });
        previousAlias = relational_itemsAlias;
        $relational_item_relation_composite_pks.where(sql`${previousAlias}.${sql.identifier("id")} = ${$relational_item_relation_composite_pks.placeholder($record.get("checklist_item_item_id"))}`);
        return connection($relational_item_relation_composite_pks);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByParentId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByParentId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByParentId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByParentId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: RelationalChecklistItem_relationalItemRelationCompositePksByParentId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  Query: {
    __assertStep() {
      return true;
    },
    query: Query_queryPlan,
    nodeId($parent) {
      const specifier = handler21.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler21.codec.name].encode);
    },
    node: {
      plan(_$root, args) {
        return node(nodeIdHandlerByTypeName, args.get("nodeId"));
      },
      args: {
        nodeId: undefined
      }
    },
    organizationByOrganizationId: {
      plan(_$root, args) {
        return otherSource_organizationsPgResource.get({
          organization_id: args.get("organizationId")
        });
      },
      args: {
        organizationId: undefined
      }
    },
    organizationByName: {
      plan(_$root, args) {
        return otherSource_organizationsPgResource.get({
          name: args.get("name")
        });
      },
      args: {
        name: undefined
      }
    },
    personByPersonId: {
      plan(_$root, args) {
        return otherSource_peoplePgResource.get({
          person_id: args.get("personId")
        });
      },
      args: {
        personId: undefined
      }
    },
    personByUsername: {
      plan(_$root, args) {
        return otherSource_peoplePgResource.get({
          username: args.get("username")
        });
      },
      args: {
        username: undefined
      }
    },
    priorityById: {
      plan(_$root, args) {
        return otherSource_prioritiesPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    relationalChecklistByChecklistItemId: {
      plan(_$root, args) {
        return relational_checklists_relational_checklistsPgResource.get({
          checklist_item_id: args.get("checklistItemId")
        });
      },
      args: {
        checklistItemId: undefined
      }
    },
    relationalItemRelationCompositePkByParentIdAndChildId: {
      plan(_$root, args) {
        return pgResource_relational_item_relation_composite_pksPgResource.get({
          parent_id: args.get("parentId"),
          child_id: args.get("childId")
        });
      },
      args: {
        parentId: undefined,
        childId: undefined
      }
    },
    relationalTopicByTopicItemId: {
      plan(_$root, args) {
        return pgResource_relational_topicsPgResource.get({
          topic_item_id: args.get("topicItemId")
        });
      },
      args: {
        topicItemId: undefined
      }
    },
    singleTableItemRelationCompositePkByParentIdAndChildId: {
      plan(_$root, args) {
        return otherSource_single_table_item_relation_composite_pksPgResource.get({
          parent_id: args.get("parentId"),
          child_id: args.get("childId")
        });
      },
      args: {
        parentId: undefined,
        childId: undefined
      }
    },
    relationalChecklistItemByChecklistItemItemId: {
      plan(_$root, args) {
        return relational_checklist_items_relational_checklist_itemsPgResource.get({
          checklist_item_item_id: args.get("checklistItemItemId")
        });
      },
      args: {
        checklistItemItemId: undefined
      }
    },
    relationalDividerByDividerItemId: {
      plan(_$root, args) {
        return relational_dividers_relational_dividersPgResource.get({
          divider_item_id: args.get("dividerItemId")
        });
      },
      args: {
        dividerItemId: undefined
      }
    },
    relationalItemRelationById: {
      plan(_$root, args) {
        return pgResource_relational_item_relationsPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    relationalItemRelationByParentIdAndChildId: {
      plan(_$root, args) {
        return pgResource_relational_item_relationsPgResource.get({
          parent_id: args.get("parentId"),
          child_id: args.get("childId")
        });
      },
      args: {
        parentId: undefined,
        childId: undefined
      }
    },
    singleTableItemRelationById: {
      plan(_$root, args) {
        return otherSource_single_table_item_relationsPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    singleTableItemRelationByParentIdAndChildId: {
      plan(_$root, args) {
        return otherSource_single_table_item_relationsPgResource.get({
          parent_id: args.get("parentId"),
          child_id: args.get("childId")
        });
      },
      args: {
        parentId: undefined,
        childId: undefined
      }
    },
    logEntryById: {
      plan(_$root, args) {
        return otherSource_log_entriesPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    relationalPostByPostItemId: {
      plan(_$root, args) {
        return relational_posts_relational_postsPgResource.get({
          post_item_id: args.get("postItemId")
        });
      },
      args: {
        postItemId: undefined
      }
    },
    firstPartyVulnerabilityById: {
      plan(_$root, args) {
        return paths_0_resource_first_party_vulnerabilitiesPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    thirdPartyVulnerabilityById: {
      plan(_$root, args) {
        return paths_1_resource_third_party_vulnerabilitiesPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    awsApplicationById: {
      plan(_$root, args) {
        return otherSource_aws_applicationsPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    gcpApplicationById: {
      plan(_$root, args) {
        return otherSource_gcp_applicationsPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    allSingleTables: {
      plan: Query_allSingleTablesPlan,
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTables_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTables_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTables_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTables_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTables_after_applyPlan
        }
      }
    },
    getSingleTableTopicById: {
      plan($root, args, _info) {
        const selectArgs = makeArgs2(args);
        return resource_get_single_table_topic_by_idPgResource.execute(selectArgs);
      },
      args: {
        id: undefined
      }
    },
    singleTableTopic: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    singleTablePost: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher2($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    singleTableDivider: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher3($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    singleTableChecklist: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher4($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    singleTableChecklistItem: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher5($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    organization: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher6($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    person: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher7($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    priority: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher8($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    relationalChecklist: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher9($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    relationalItemRelationCompositePk: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher10($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    relationalTopic: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher11($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    singleTableItemRelationCompositePk: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher12($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    relationalChecklistItem: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher13($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    relationalDivider: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher14($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    relationalItemRelation: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher15($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    singleTableItemRelation: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher16($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    logEntry: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher17($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    relationalPost: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher18($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    firstPartyVulnerability: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher19($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    thirdPartyVulnerability: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher20($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    awsApplication: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher21($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    gcpApplication: {
      plan(_$parent, args) {
        const $nodeId = args.get("nodeId");
        return fetcher22($nodeId);
      },
      args: {
        nodeId: undefined
      }
    },
    allVulnerabilities: {
      plan() {
        const $list = pgUnionAll({
          attributes: attributes_object_Object_7,
          resourceByTypeName: resourceByTypeName7,
          members: members7,
          name: "Vulnerability"
        });
        return true ? connection($list) : $list;
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allVulnerabilities_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allVulnerabilities_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allVulnerabilities_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allVulnerabilities_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allVulnerabilities_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("VulnerabilitiesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        },
        only: {
          autoApplyAfterParentPlan: true,
          applyPlan($parent, $connection, fieldArgs) {
            const $union = $connection.getSubplan();
            $union.limitToTypes(fieldArgs.getRaw().eval());
          }
        }
      }
    },
    allApplications: {
      plan() {
        const $list = pgUnionAll({
          attributes: attributes_object_Object_6,
          resourceByTypeName: resourceByTypeName8,
          members: members8,
          name: "Application"
        });
        return true ? connection($list) : $list;
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allApplications_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allApplications_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allApplications_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allApplications_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allApplications_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        },
        only: {
          autoApplyAfterParentPlan: true,
          applyPlan($parent, $connection, fieldArgs) {
            const $union = $connection.getSubplan();
            $union.limitToTypes(fieldArgs.getRaw().eval());
          }
        }
      }
    },
    allZeroImplementations: {
      plan() {
        const $list = pgUnionAll({
          attributes: attributes_object_Object_8,
          resourceByTypeName: resourceByTypeName9,
          members: members9,
          name: "ZeroImplementation"
        });
        return true ? connection($list) : $list;
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allZeroImplementations_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allZeroImplementations_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allZeroImplementations_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allZeroImplementations_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allZeroImplementations_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ZeroImplementationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allOrganizations: {
      plan() {
        return connection(otherSource_organizationsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allOrganizations_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allOrganizations_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allOrganizations_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allOrganizations_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allOrganizations_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("OrganizationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allPeople: {
      plan() {
        return connection(otherSource_peoplePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allPriorities: {
      plan() {
        return connection(otherSource_prioritiesPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPriorities_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPriorities_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPriorities_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPriorities_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPriorities_after_applyPlan
        }
      }
    },
    allRelationalChecklists: {
      plan() {
        return connection(relational_checklists_relational_checklistsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklists_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklists_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklists_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklists_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklists_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalChecklistsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allRelationalItemRelationCompositePks: {
      plan() {
        return connection(pgResource_relational_item_relation_composite_pksPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelationCompositePks_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelationCompositePks_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelationCompositePks_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelationCompositePks_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelationCompositePks_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allRelationalTopics: {
      plan() {
        return connection(pgResource_relational_topicsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalTopics_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalTopics_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalTopics_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalTopics_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalTopics_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalTopicsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allSingleTableItemRelationCompositePks: {
      plan() {
        return connection(otherSource_single_table_item_relation_composite_pksPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelationCompositePks_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelationCompositePks_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelationCompositePks_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelationCompositePks_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelationCompositePks_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allRelationalChecklistItems: {
      plan() {
        return connection(relational_checklist_items_relational_checklist_itemsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklistItems_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklistItems_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklistItems_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklistItems_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalChecklistItems_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalChecklistItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allRelationalDividers: {
      plan() {
        return connection(relational_dividers_relational_dividersPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalDividers_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalDividers_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalDividers_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalDividers_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalDividers_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalDividersOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allRelationalItemRelations: {
      plan() {
        return connection(pgResource_relational_item_relationsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelations_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelations_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelations_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelations_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItemRelations_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allSingleTableItemRelations: {
      plan() {
        return connection(otherSource_single_table_item_relationsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelations_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelations_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelations_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelations_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItemRelations_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allLogEntries: {
      plan() {
        return connection(otherSource_log_entriesPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLogEntries_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLogEntries_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLogEntries_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLogEntries_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLogEntries_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("LogEntriesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allRelationalPosts: {
      plan() {
        return connection(relational_posts_relational_postsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalPosts_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalPosts_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalPosts_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalPosts_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalPosts_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalPostsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allFirstPartyVulnerabilities: {
      plan() {
        return connection(paths_0_resource_first_party_vulnerabilitiesPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allFirstPartyVulnerabilities_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allFirstPartyVulnerabilities_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allFirstPartyVulnerabilities_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allFirstPartyVulnerabilities_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allFirstPartyVulnerabilities_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("FirstPartyVulnerabilitiesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allThirdPartyVulnerabilities: {
      plan() {
        return connection(paths_1_resource_third_party_vulnerabilitiesPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allThirdPartyVulnerabilities_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allThirdPartyVulnerabilities_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allThirdPartyVulnerabilities_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allThirdPartyVulnerabilities_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allThirdPartyVulnerabilities_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ThirdPartyVulnerabilitiesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allAwsApplications: {
      plan() {
        return connection(otherSource_aws_applicationsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allAwsApplications_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allAwsApplications_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allAwsApplications_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allAwsApplications_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allAwsApplications_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("AwsApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allGcpApplications: {
      plan() {
        return connection(otherSource_gcp_applicationsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allGcpApplications_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allGcpApplications_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allGcpApplications_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allGcpApplications_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allGcpApplications_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("GcpApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allSingleTableItems: {
      plan() {
        return connection(resource_single_table_itemsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItems_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItems_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItems_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItems_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSingleTableItems_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allRelationalItems: {
      plan() {
        return connection(otherSource_relational_itemsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItems_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItems_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItems_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItems_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allRelationalItems_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("RelationalItemsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  FirstPartyVulnerability: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = nodeIdHandlerByTypeName.FirstPartyVulnerability.plan($parent);
      return lambda(specifier, nodeIdCodecs[nodeIdHandlerByTypeName.FirstPartyVulnerability.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    name($record) {
      return $record.get("name");
    },
    cvssScore($record) {
      return $record.get("cvss_score");
    },
    teamName($record) {
      return $record.get("team_name");
    },
    applications: {
      plan($parent) {
        const $record = undefined ? $parent.get("result") : $parent;
        for (let i = 0, l = paths7.length; i < l; i++) {
          const path = paths7[i];
          const firstLayer = path.layers[0];
          const member = members10[i];
          member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
            memo[firstLayer.remoteAttributes[idx]] = {
              step: $record.get(col)
            };
            return memo;
          }, Object.create(null));
        }
        const $list = pgUnionAll({
          attributes: attributes_object_Object_6,
          resourceByTypeName: resourceByTypeName10,
          members: members10,
          name: "applications"
        });
        if (true) {
          return connection($list);
        } else if (false) {
          return $list.single();
        } else {
          return $list;
        }
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: FirstPartyVulnerability_applications_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: FirstPartyVulnerability_applications_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: FirstPartyVulnerability_applications_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: FirstPartyVulnerability_applications_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: FirstPartyVulnerability_applications_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        },
        only: {
          autoApplyAfterParentPlan: true,
          applyPlan($parent, $connection, fieldArgs) {
            const $union = $connection.getSubplan();
            $union.limitToTypes(fieldArgs.getRaw().eval());
          }
        }
      }
    },
    owners($parent) {
      const $record = undefined ? $parent.get("result") : $parent;
      for (let i = 0, l = paths8.length; i < l; i++) {
        const path = paths8[i];
        const firstLayer = path.layers[0];
        const member = members11[i];
        member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
          memo[firstLayer.remoteAttributes[idx]] = {
            step: $record.get(col)
          };
          return memo;
        }, Object.create(null));
      }
      const $list = pgUnionAll({
        attributes: attributes22,
        resourceByTypeName: resourceByTypeName11,
        members: members11,
        name: "owners"
      });
      if (true) {
        return connection($list);
      } else if (false) {
        return $list.single();
      } else {
        return $list;
      }
    }
  },
  ThirdPartyVulnerability: {
    __assertStep: assertPgClassSingleStep,
    nodeId($parent) {
      const specifier = nodeIdHandlerByTypeName.ThirdPartyVulnerability.plan($parent);
      return lambda(specifier, nodeIdCodecs[nodeIdHandlerByTypeName.ThirdPartyVulnerability.codec.name].encode);
    },
    id($record) {
      return $record.get("id");
    },
    name($record) {
      return $record.get("name");
    },
    cvssScore($record) {
      return $record.get("cvss_score");
    },
    vendorName($record) {
      return $record.get("vendor_name");
    },
    applications: {
      plan($parent) {
        const $record = undefined ? $parent.get("result") : $parent;
        for (let i = 0, l = paths9.length; i < l; i++) {
          const path = paths9[i];
          const firstLayer = path.layers[0];
          const member = members12[i];
          member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
            memo[firstLayer.remoteAttributes[idx]] = {
              step: $record.get(col)
            };
            return memo;
          }, Object.create(null));
        }
        const $list = pgUnionAll({
          attributes: attributes_object_Object_6,
          resourceByTypeName: resourceByTypeName12,
          members: members12,
          name: "applications"
        });
        if (true) {
          return connection($list);
        } else if (false) {
          return $list.single();
        } else {
          return $list;
        }
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: ThirdPartyVulnerability_applications_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: ThirdPartyVulnerability_applications_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: ThirdPartyVulnerability_applications_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: ThirdPartyVulnerability_applications_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: ThirdPartyVulnerability_applications_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ApplicationsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        },
        only: {
          autoApplyAfterParentPlan: true,
          applyPlan($parent, $connection, fieldArgs) {
            const $union = $connection.getSubplan();
            $union.limitToTypes(fieldArgs.getRaw().eval());
          }
        }
      }
    },
    owners($parent) {
      const $record = undefined ? $parent.get("result") : $parent;
      for (let i = 0, l = paths10.length; i < l; i++) {
        const path = paths10[i];
        const firstLayer = path.layers[0];
        const member = members13[i];
        member.match = firstLayer.localAttributes.reduce((memo, col, idx) => {
          memo[firstLayer.remoteAttributes[idx]] = {
            step: $record.get(col)
          };
          return memo;
        }, Object.create(null));
      }
      const $list = pgUnionAll({
        attributes: attributes23,
        resourceByTypeName: resourceByTypeName13,
        members: members13,
        name: "owners"
      });
      if (true) {
        return connection($list);
      } else if (false) {
        return $list.single();
      } else {
        return $list;
      }
    }
  },
  ZeroImplementationsConnection: {
    __assertStep: ConnectionStep,
    nodes: ZeroImplementationsConnection_nodesPlan,
    edges: ZeroImplementationsConnection_edgesPlan,
    pageInfo: ZeroImplementationsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ZeroImplementationsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ZeroImplementationsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ZeroImplementationCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_8.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_8.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  OrganizationsConnection: {
    __assertStep: ConnectionStep,
    nodes: OrganizationsConnection_nodesPlan,
    edges: OrganizationsConnection_edgesPlan,
    pageInfo: OrganizationsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  OrganizationsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  OrganizationsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques5[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_organizations_organizations.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques5[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_organizations_organizations.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ORGANIZATION_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "organization_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ORGANIZATION_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "organization_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  OrganizationCondition: {
    organizationId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "organization_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "organization_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.organization_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PeopleConnection: {
    __assertStep: ConnectionStep,
    nodes: PeopleConnection_nodesPlan,
    edges: PeopleConnection_edgesPlan,
    pageInfo: PeopleConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PeopleEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PeopleOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques6[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_people_people.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques6[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_people_people.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    USERNAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "username",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    USERNAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "username",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  PersonCondition: {
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes5.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    username: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "username",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "username",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes5.username.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PrioritiesConnection: {
    __assertStep: ConnectionStep,
    nodes: PrioritiesConnection_nodesPlan,
    edges: PrioritiesConnection_edgesPlan,
    pageInfo: PrioritiesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PrioritiesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  RelationalChecklistsConnection: {
    __assertStep: ConnectionStep,
    nodes: RelationalChecklistsConnection_nodesPlan,
    edges: RelationalChecklistsConnection_edgesPlan,
    pageInfo: RelationalChecklistsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  RelationalChecklistsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  RelationalChecklistsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques8[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalChecklists_relationalChecklists.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques8[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalChecklists_relationalChecklists.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    TITLE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "title",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TITLE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "title",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  RelationalChecklistCondition: {
    title: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "title",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "title",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.title.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    type: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rootTopicId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.root_topic_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.author_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    position: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.position.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.created_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.updated_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isExplicitlyArchived: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.is_explicitly_archived.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    archivedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes7.archived_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  RelationalTopicsConnection: {
    __assertStep: ConnectionStep,
    nodes: RelationalTopicsConnection_nodesPlan,
    edges: RelationalTopicsConnection_edgesPlan,
    pageInfo: RelationalTopicsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  RelationalTopicsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  RelationalTopicsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques10[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalTopics_relationalTopics.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques10[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalTopics_relationalTopics.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    TITLE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "title",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TITLE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "title",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  RelationalTopicCondition: {
    title: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "title",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "title",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.title.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    type: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rootTopicId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.root_topic_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.author_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    position: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.position.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.created_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.updated_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isExplicitlyArchived: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.is_explicitly_archived.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    archivedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes9.archived_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  RelationalChecklistItemsConnection: {
    __assertStep: ConnectionStep,
    nodes: RelationalChecklistItemsConnection_nodesPlan,
    edges: RelationalChecklistItemsConnection_edgesPlan,
    pageInfo: RelationalChecklistItemsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  RelationalChecklistItemsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  RelationalChecklistItemsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques12[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalChecklistItems_relationalChecklistItems.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques12[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalChecklistItems_relationalChecklistItems.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    DESCRIPTION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "description",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DESCRIPTION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "description",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NOTE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "note",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NOTE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "note",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  RelationalChecklistItemCondition: {
    description: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "description",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "description",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.description.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    note: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "note",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "note",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.note.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    type: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rootTopicId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.root_topic_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.author_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    position: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.position.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.created_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.updated_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isExplicitlyArchived: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.is_explicitly_archived.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    archivedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes11.archived_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  RelationalDividersConnection: {
    __assertStep: ConnectionStep,
    nodes: RelationalDividersConnection_nodesPlan,
    edges: RelationalDividersConnection_edgesPlan,
    pageInfo: RelationalDividersConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  RelationalDividersEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  RelationalDividersOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques13[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalDividers_relationalDividers.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques13[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalDividers_relationalDividers.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    TITLE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "title",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TITLE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "title",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COLOR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "color",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COLOR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "color",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  RelationalDividerCondition: {
    title: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "title",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "title",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.title.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    color: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "color",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "color",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.color.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    type: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rootTopicId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.root_topic_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.author_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    position: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.position.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.created_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.updated_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isExplicitlyArchived: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.is_explicitly_archived.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    archivedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12.archived_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  RelationalPostsConnection: {
    __assertStep: ConnectionStep,
    nodes: RelationalPostsConnection_nodesPlan,
    edges: RelationalPostsConnection_edgesPlan,
    pageInfo: RelationalPostsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  RelationalPostsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  RelationalPostsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques17[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalPosts_relationalPosts.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques17[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_relationalPosts_relationalPosts.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    TITLE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "title",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TITLE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "title",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DESCRIPTION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "description",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DESCRIPTION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "description",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NOTE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "note",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NOTE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "note",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PARENT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "parent_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROOT_TOPIC_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "root_topic_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POSITION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "position",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    IS_EXPLICITLY_ARCHIVED_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "is_explicitly_archived",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ARCHIVED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "archived_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  RelationalPostCondition: {
    title: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "title",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "title",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.title.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "description",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "description",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.description.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    note: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "note",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "note",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.note.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    type: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "parent_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.parent_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rootTopicId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "root_topic_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.root_topic_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.author_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    position: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "position",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.position.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.created_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "updated_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.updated_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isExplicitlyArchived: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "is_explicitly_archived",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.is_explicitly_archived.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    archivedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "archived_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.archived_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  FirstPartyVulnerabilitiesConnection: {
    __assertStep: ConnectionStep,
    nodes: FirstPartyVulnerabilitiesConnection_nodesPlan,
    edges: FirstPartyVulnerabilitiesConnection_edgesPlan,
    pageInfo: FirstPartyVulnerabilitiesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  FirstPartyVulnerabilitiesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  FirstPartyVulnerabilitiesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques18[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_firstPartyVulnerabilities_firstPartyVulnerabilities.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques18[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_firstPartyVulnerabilities_firstPartyVulnerabilities.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CVSS_SCORE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cvss_score",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CVSS_SCORE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cvss_score",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TEAM_NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "team_name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TEAM_NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "team_name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  FirstPartyVulnerabilityCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_2.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_2.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cvssScore: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "cvss_score",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "cvss_score",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_2.cvss_score.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    teamName: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "team_name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "team_name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_2.team_name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ThirdPartyVulnerabilitiesConnection: {
    __assertStep: ConnectionStep,
    nodes: ThirdPartyVulnerabilitiesConnection_nodesPlan,
    edges: ThirdPartyVulnerabilitiesConnection_edgesPlan,
    pageInfo: ThirdPartyVulnerabilitiesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ThirdPartyVulnerabilitiesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ThirdPartyVulnerabilitiesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques19[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_thirdPartyVulnerabilities_thirdPartyVulnerabilities.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques19[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_thirdPartyVulnerabilities_thirdPartyVulnerabilities.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CVSS_SCORE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cvss_score",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CVSS_SCORE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cvss_score",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    VENDOR_NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "vendor_name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    VENDOR_NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "vendor_name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ThirdPartyVulnerabilityCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_3.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_3.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cvssScore: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "cvss_score",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "cvss_score",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_3.cvss_score.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    vendorName: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "vendor_name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "vendor_name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_3.vendor_name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  Mutation: {
    __assertStep: __ValueStep,
    customDeleteRelationalItem: {
      plan($root, args, _info) {
        const selectArgs = makeArgs3(args, ["input"]);
        const $result = resource_custom_delete_relational_itemPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_customDeleteRelationalItem_input_applyPlan
        }
      }
    },
    createOrganization: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(otherSource_organizationsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createOrganization_input_applyPlan
        }
      }
    },
    createPerson: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(otherSource_peoplePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createPerson_input_applyPlan
        }
      }
    },
    createRelationalItemRelationCompositePk: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(pgResource_relational_item_relation_composite_pksPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createRelationalItemRelationCompositePk_input_applyPlan
        }
      }
    },
    createSingleTableItemRelationCompositePk: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(otherSource_single_table_item_relation_composite_pksPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createSingleTableItemRelationCompositePk_input_applyPlan
        }
      }
    },
    createRelationalItemRelation: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(pgResource_relational_item_relationsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createRelationalItemRelation_input_applyPlan
        }
      }
    },
    createSingleTableItemRelation: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(otherSource_single_table_item_relationsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createSingleTableItemRelation_input_applyPlan
        }
      }
    },
    createLogEntry: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(otherSource_log_entriesPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createLogEntry_input_applyPlan
        }
      }
    },
    createFirstPartyVulnerability: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(paths_0_resource_first_party_vulnerabilitiesPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createFirstPartyVulnerability_input_applyPlan
        }
      }
    },
    createThirdPartyVulnerability: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(paths_1_resource_third_party_vulnerabilitiesPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createThirdPartyVulnerability_input_applyPlan
        }
      }
    },
    createAwsApplication: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(otherSource_aws_applicationsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createAwsApplication_input_applyPlan
        }
      }
    },
    createGcpApplication: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(otherSource_gcp_applicationsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createGcpApplication_input_applyPlan
        }
      }
    },
    updateOrganization: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_organizationsPgResource, specFromArgs(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateOrganization_input_applyPlan
        }
      }
    },
    updateOrganizationByOrganizationId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_organizationsPgResource, {
            organization_id: args.get(['input', "organizationId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateOrganizationByOrganizationId_input_applyPlan
        }
      }
    },
    updateOrganizationByName: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_organizationsPgResource, {
            name: args.get(['input', "name"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateOrganizationByName_input_applyPlan
        }
      }
    },
    updatePerson: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_peoplePgResource, specFromArgs2(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePerson_input_applyPlan
        }
      }
    },
    updatePersonByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_peoplePgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePersonByPersonId_input_applyPlan
        }
      }
    },
    updatePersonByUsername: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_peoplePgResource, {
            username: args.get(['input', "username"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePersonByUsername_input_applyPlan
        }
      }
    },
    updateRelationalItemRelationCompositePk: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(pgResource_relational_item_relation_composite_pksPgResource, specFromArgs3(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateRelationalItemRelationCompositePk_input_applyPlan
        }
      }
    },
    updateRelationalItemRelationCompositePkByParentIdAndChildId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(pgResource_relational_item_relation_composite_pksPgResource, {
            parent_id: args.get(['input', "parentId"]),
            child_id: args.get(['input', "childId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateRelationalItemRelationCompositePkByParentIdAndChildId_input_applyPlan
        }
      }
    },
    updateSingleTableItemRelationCompositePk: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_single_table_item_relation_composite_pksPgResource, specFromArgs4(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateSingleTableItemRelationCompositePk_input_applyPlan
        }
      }
    },
    updateSingleTableItemRelationCompositePkByParentIdAndChildId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_single_table_item_relation_composite_pksPgResource, {
            parent_id: args.get(['input', "parentId"]),
            child_id: args.get(['input', "childId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateSingleTableItemRelationCompositePkByParentIdAndChildId_input_applyPlan
        }
      }
    },
    updateRelationalItemRelation: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(pgResource_relational_item_relationsPgResource, specFromArgs5(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateRelationalItemRelation_input_applyPlan
        }
      }
    },
    updateRelationalItemRelationById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(pgResource_relational_item_relationsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateRelationalItemRelationById_input_applyPlan
        }
      }
    },
    updateRelationalItemRelationByParentIdAndChildId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(pgResource_relational_item_relationsPgResource, {
            parent_id: args.get(['input', "parentId"]),
            child_id: args.get(['input', "childId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateRelationalItemRelationByParentIdAndChildId_input_applyPlan
        }
      }
    },
    updateSingleTableItemRelation: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_single_table_item_relationsPgResource, specFromArgs6(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateSingleTableItemRelation_input_applyPlan
        }
      }
    },
    updateSingleTableItemRelationById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_single_table_item_relationsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateSingleTableItemRelationById_input_applyPlan
        }
      }
    },
    updateSingleTableItemRelationByParentIdAndChildId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_single_table_item_relationsPgResource, {
            parent_id: args.get(['input', "parentId"]),
            child_id: args.get(['input', "childId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateSingleTableItemRelationByParentIdAndChildId_input_applyPlan
        }
      }
    },
    updateLogEntry: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_log_entriesPgResource, specFromArgs7(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateLogEntry_input_applyPlan
        }
      }
    },
    updateLogEntryById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_log_entriesPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateLogEntryById_input_applyPlan
        }
      }
    },
    updateFirstPartyVulnerability: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(paths_0_resource_first_party_vulnerabilitiesPgResource, specFromArgs8(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateFirstPartyVulnerability_input_applyPlan
        }
      }
    },
    updateFirstPartyVulnerabilityById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(paths_0_resource_first_party_vulnerabilitiesPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateFirstPartyVulnerabilityById_input_applyPlan
        }
      }
    },
    updateThirdPartyVulnerability: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(paths_1_resource_third_party_vulnerabilitiesPgResource, specFromArgs9(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateThirdPartyVulnerability_input_applyPlan
        }
      }
    },
    updateThirdPartyVulnerabilityById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(paths_1_resource_third_party_vulnerabilitiesPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateThirdPartyVulnerabilityById_input_applyPlan
        }
      }
    },
    updateAwsApplication: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_aws_applicationsPgResource, specFromArgs10(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateAwsApplication_input_applyPlan
        }
      }
    },
    updateAwsApplicationById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_aws_applicationsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateAwsApplicationById_input_applyPlan
        }
      }
    },
    updateGcpApplication: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_gcp_applicationsPgResource, specFromArgs11(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateGcpApplication_input_applyPlan
        }
      }
    },
    updateGcpApplicationById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(otherSource_gcp_applicationsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateGcpApplicationById_input_applyPlan
        }
      }
    },
    deleteOrganization: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_organizationsPgResource, specFromArgs12(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteOrganization_input_applyPlan
        }
      }
    },
    deleteOrganizationByOrganizationId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_organizationsPgResource, {
            organization_id: args.get(['input', "organizationId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteOrganizationByOrganizationId_input_applyPlan
        }
      }
    },
    deleteOrganizationByName: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_organizationsPgResource, {
            name: args.get(['input', "name"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteOrganizationByName_input_applyPlan
        }
      }
    },
    deletePerson: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_peoplePgResource, specFromArgs13(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePerson_input_applyPlan
        }
      }
    },
    deletePersonByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_peoplePgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePersonByPersonId_input_applyPlan
        }
      }
    },
    deletePersonByUsername: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_peoplePgResource, {
            username: args.get(['input', "username"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePersonByUsername_input_applyPlan
        }
      }
    },
    deleteRelationalItemRelationCompositePk: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(pgResource_relational_item_relation_composite_pksPgResource, specFromArgs14(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteRelationalItemRelationCompositePk_input_applyPlan
        }
      }
    },
    deleteRelationalItemRelationCompositePkByParentIdAndChildId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(pgResource_relational_item_relation_composite_pksPgResource, {
            parent_id: args.get(['input', "parentId"]),
            child_id: args.get(['input', "childId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteRelationalItemRelationCompositePkByParentIdAndChildId_input_applyPlan
        }
      }
    },
    deleteSingleTableItemRelationCompositePk: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_single_table_item_relation_composite_pksPgResource, specFromArgs15(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteSingleTableItemRelationCompositePk_input_applyPlan
        }
      }
    },
    deleteSingleTableItemRelationCompositePkByParentIdAndChildId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_single_table_item_relation_composite_pksPgResource, {
            parent_id: args.get(['input', "parentId"]),
            child_id: args.get(['input', "childId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteSingleTableItemRelationCompositePkByParentIdAndChildId_input_applyPlan
        }
      }
    },
    deleteRelationalItemRelation: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(pgResource_relational_item_relationsPgResource, specFromArgs16(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteRelationalItemRelation_input_applyPlan
        }
      }
    },
    deleteRelationalItemRelationById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(pgResource_relational_item_relationsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteRelationalItemRelationById_input_applyPlan
        }
      }
    },
    deleteRelationalItemRelationByParentIdAndChildId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(pgResource_relational_item_relationsPgResource, {
            parent_id: args.get(['input', "parentId"]),
            child_id: args.get(['input', "childId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteRelationalItemRelationByParentIdAndChildId_input_applyPlan
        }
      }
    },
    deleteSingleTableItemRelation: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_single_table_item_relationsPgResource, specFromArgs17(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteSingleTableItemRelation_input_applyPlan
        }
      }
    },
    deleteSingleTableItemRelationById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_single_table_item_relationsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteSingleTableItemRelationById_input_applyPlan
        }
      }
    },
    deleteSingleTableItemRelationByParentIdAndChildId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_single_table_item_relationsPgResource, {
            parent_id: args.get(['input', "parentId"]),
            child_id: args.get(['input', "childId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteSingleTableItemRelationByParentIdAndChildId_input_applyPlan
        }
      }
    },
    deleteLogEntry: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_log_entriesPgResource, specFromArgs18(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteLogEntry_input_applyPlan
        }
      }
    },
    deleteLogEntryById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_log_entriesPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteLogEntryById_input_applyPlan
        }
      }
    },
    deleteFirstPartyVulnerability: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(paths_0_resource_first_party_vulnerabilitiesPgResource, specFromArgs19(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteFirstPartyVulnerability_input_applyPlan
        }
      }
    },
    deleteFirstPartyVulnerabilityById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(paths_0_resource_first_party_vulnerabilitiesPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteFirstPartyVulnerabilityById_input_applyPlan
        }
      }
    },
    deleteThirdPartyVulnerability: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(paths_1_resource_third_party_vulnerabilitiesPgResource, specFromArgs20(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteThirdPartyVulnerability_input_applyPlan
        }
      }
    },
    deleteThirdPartyVulnerabilityById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(paths_1_resource_third_party_vulnerabilitiesPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteThirdPartyVulnerabilityById_input_applyPlan
        }
      }
    },
    deleteAwsApplication: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_aws_applicationsPgResource, specFromArgs21(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteAwsApplication_input_applyPlan
        }
      }
    },
    deleteAwsApplicationById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_aws_applicationsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteAwsApplicationById_input_applyPlan
        }
      }
    },
    deleteGcpApplication: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_gcp_applicationsPgResource, specFromArgs22(args))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteGcpApplication_input_applyPlan
        }
      }
    },
    deleteGcpApplicationById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(otherSource_gcp_applicationsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteGcpApplicationById_input_applyPlan
        }
      }
    }
  },
  CustomDeleteRelationalItemPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CustomDeleteRelationalItemPayload_clientMutationIdPlan,
    boolean($object) {
      return $object.get("result");
    },
    query: CustomDeleteRelationalItemPayload_queryPlan
  },
  CustomDeleteRelationalItemInput: {
    clientMutationId: {
      applyPlan: CustomDeleteRelationalItemInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    nodeId: undefined
  },
  CreateOrganizationPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateOrganizationPayload_clientMutationIdPlan,
    organization: CreateOrganizationPayload_organizationPlan,
    query: CreateOrganizationPayload_queryPlan,
    organizationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques5[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_organizationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("OrganizationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateOrganizationInput: {
    clientMutationId: {
      applyPlan: CreateOrganizationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    organization: {
      applyPlan: CreateOrganizationInput_organization_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  OrganizationInput: {
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreatePersonPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreatePersonPayload_clientMutationIdPlan,
    person: CreatePersonPayload_personPlan,
    query: CreatePersonPayload_queryPlan,
    personEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques6[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_peoplePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreatePersonInput: {
    clientMutationId: {
      applyPlan: CreatePersonInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    person: {
      applyPlan: CreatePersonInput_person_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PersonInput: {
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    username: {
      applyPlan($insert, val) {
        $insert.set("username", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateRelationalItemRelationCompositePkPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateRelationalItemRelationCompositePkPayload_clientMutationIdPlan,
    relationalItemRelationCompositePk: CreateRelationalItemRelationCompositePkPayload_relationalItemRelationCompositePkPlan,
    query: CreateRelationalItemRelationCompositePkPayload_queryPlan,
    relationalItemRelationCompositePkEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques9[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return pgResource_relational_item_relation_composite_pksPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    relationalItemByChildId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    relationalItemByParentId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  CreateRelationalItemRelationCompositePkInput: {
    clientMutationId: {
      applyPlan: CreateRelationalItemRelationCompositePkInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    relationalItemRelationCompositePk: {
      applyPlan: CreateRelationalItemRelationCompositePkInput_relationalItemRelationCompositePk_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  RelationalItemRelationCompositePkInput: {
    parentId: {
      applyPlan($insert, val) {
        $insert.set("parent_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($insert, val) {
        $insert.set("child_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateSingleTableItemRelationCompositePkPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateSingleTableItemRelationCompositePkPayload_clientMutationIdPlan,
    singleTableItemRelationCompositePk: CreateSingleTableItemRelationCompositePkPayload_singleTableItemRelationCompositePkPlan,
    query: CreateSingleTableItemRelationCompositePkPayload_queryPlan,
    singleTableItemRelationCompositePkEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques11[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_single_table_item_relation_composite_pksPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    singleTableItemByChildId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  CreateSingleTableItemRelationCompositePkInput: {
    clientMutationId: {
      applyPlan: CreateSingleTableItemRelationCompositePkInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    singleTableItemRelationCompositePk: {
      applyPlan: CreateSingleTableItemRelationCompositePkInput_singleTableItemRelationCompositePk_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SingleTableItemRelationCompositePkInput: {
    parentId: {
      applyPlan($insert, val) {
        $insert.set("parent_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($insert, val) {
        $insert.set("child_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateRelationalItemRelationPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateRelationalItemRelationPayload_clientMutationIdPlan,
    relationalItemRelation: CreateRelationalItemRelationPayload_relationalItemRelationPlan,
    query: CreateRelationalItemRelationPayload_queryPlan,
    relationalItemRelationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques14[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return pgResource_relational_item_relationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    relationalItemByChildId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    relationalItemByParentId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  CreateRelationalItemRelationInput: {
    clientMutationId: {
      applyPlan: CreateRelationalItemRelationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    relationalItemRelation: {
      applyPlan: CreateRelationalItemRelationInput_relationalItemRelation_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  RelationalItemRelationInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($insert, val) {
        $insert.set("parent_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($insert, val) {
        $insert.set("child_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateSingleTableItemRelationPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateSingleTableItemRelationPayload_clientMutationIdPlan,
    singleTableItemRelation: CreateSingleTableItemRelationPayload_singleTableItemRelationPlan,
    query: CreateSingleTableItemRelationPayload_queryPlan,
    singleTableItemRelationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques15[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_single_table_item_relationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    singleTableItemByChildId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  CreateSingleTableItemRelationInput: {
    clientMutationId: {
      applyPlan: CreateSingleTableItemRelationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    singleTableItemRelation: {
      applyPlan: CreateSingleTableItemRelationInput_singleTableItemRelation_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SingleTableItemRelationInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($insert, val) {
        $insert.set("parent_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($insert, val) {
        $insert.set("child_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateLogEntryPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateLogEntryPayload_clientMutationIdPlan,
    logEntry: CreateLogEntryPayload_logEntryPlan,
    query: CreateLogEntryPayload_queryPlan,
    logEntryEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques16[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_log_entriesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("LogEntriesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("result").get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("result").get("person_id")
      });
    }
  },
  CreateLogEntryInput: {
    clientMutationId: {
      applyPlan: CreateLogEntryInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    logEntry: {
      applyPlan: CreateLogEntryInput_logEntry_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  LogEntryInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    text: {
      applyPlan($insert, val) {
        $insert.set("text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateFirstPartyVulnerabilityPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateFirstPartyVulnerabilityPayload_clientMutationIdPlan,
    firstPartyVulnerability: CreateFirstPartyVulnerabilityPayload_firstPartyVulnerabilityPlan,
    query: CreateFirstPartyVulnerabilityPayload_queryPlan,
    firstPartyVulnerabilityEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques18[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return paths_0_resource_first_party_vulnerabilitiesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("FirstPartyVulnerabilitiesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateFirstPartyVulnerabilityInput: {
    clientMutationId: {
      applyPlan: CreateFirstPartyVulnerabilityInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    firstPartyVulnerability: {
      applyPlan: CreateFirstPartyVulnerabilityInput_firstPartyVulnerability_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  FirstPartyVulnerabilityInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cvssScore: {
      applyPlan($insert, val) {
        $insert.set("cvss_score", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    teamName: {
      applyPlan($insert, val) {
        $insert.set("team_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateThirdPartyVulnerabilityPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateThirdPartyVulnerabilityPayload_clientMutationIdPlan,
    thirdPartyVulnerability: CreateThirdPartyVulnerabilityPayload_thirdPartyVulnerabilityPlan,
    query: CreateThirdPartyVulnerabilityPayload_queryPlan,
    thirdPartyVulnerabilityEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques19[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return paths_1_resource_third_party_vulnerabilitiesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ThirdPartyVulnerabilitiesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateThirdPartyVulnerabilityInput: {
    clientMutationId: {
      applyPlan: CreateThirdPartyVulnerabilityInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    thirdPartyVulnerability: {
      applyPlan: CreateThirdPartyVulnerabilityInput_thirdPartyVulnerability_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ThirdPartyVulnerabilityInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cvssScore: {
      applyPlan($insert, val) {
        $insert.set("cvss_score", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    vendorName: {
      applyPlan($insert, val) {
        $insert.set("vendor_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateAwsApplicationPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateAwsApplicationPayload_clientMutationIdPlan,
    awsApplication: CreateAwsApplicationPayload_awsApplicationPlan,
    query: CreateAwsApplicationPayload_queryPlan,
    awsApplicationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques20[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_aws_applicationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("AwsApplicationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("result").get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("result").get("person_id")
      });
    }
  },
  CreateAwsApplicationInput: {
    clientMutationId: {
      applyPlan: CreateAwsApplicationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    awsApplication: {
      applyPlan: CreateAwsApplicationInput_awsApplication_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  AwsApplicationInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastDeployed: {
      applyPlan($insert, val) {
        $insert.set("last_deployed", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    awsId: {
      applyPlan($insert, val) {
        $insert.set("aws_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateGcpApplicationPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateGcpApplicationPayload_clientMutationIdPlan,
    gcpApplication: CreateGcpApplicationPayload_gcpApplicationPlan,
    query: CreateGcpApplicationPayload_queryPlan,
    gcpApplicationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_gcp_applicationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("GcpApplicationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("result").get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("result").get("person_id")
      });
    }
  },
  CreateGcpApplicationInput: {
    clientMutationId: {
      applyPlan: CreateGcpApplicationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    gcpApplication: {
      applyPlan: CreateGcpApplicationInput_gcpApplication_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  GcpApplicationInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastDeployed: {
      applyPlan($insert, val) {
        $insert.set("last_deployed", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    gcpId: {
      applyPlan($insert, val) {
        $insert.set("gcp_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateOrganizationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateOrganizationPayload_clientMutationIdPlan,
    organization: UpdateOrganizationPayload_organizationPlan,
    query: UpdateOrganizationPayload_queryPlan,
    organizationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques5[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_organizationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("OrganizationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateOrganizationInput: {
    clientMutationId: {
      applyPlan: UpdateOrganizationInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    organizationPatch: {
      applyPlan: UpdateOrganizationInput_organizationPatch_applyPlan
    }
  },
  OrganizationPatch: {
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateOrganizationByOrganizationIdInput: {
    clientMutationId: {
      applyPlan: UpdateOrganizationByOrganizationIdInput_clientMutationId_applyPlan
    },
    organizationId: undefined,
    organizationPatch: {
      applyPlan: UpdateOrganizationByOrganizationIdInput_organizationPatch_applyPlan
    }
  },
  UpdateOrganizationByNameInput: {
    clientMutationId: {
      applyPlan: UpdateOrganizationByNameInput_clientMutationId_applyPlan
    },
    name: undefined,
    organizationPatch: {
      applyPlan: UpdateOrganizationByNameInput_organizationPatch_applyPlan
    }
  },
  UpdatePersonPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdatePersonPayload_clientMutationIdPlan,
    person: UpdatePersonPayload_personPlan,
    query: UpdatePersonPayload_queryPlan,
    personEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques6[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_peoplePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdatePersonInput: {
    clientMutationId: {
      applyPlan: UpdatePersonInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    personPatch: {
      applyPlan: UpdatePersonInput_personPatch_applyPlan
    }
  },
  PersonPatch: {
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    username: {
      applyPlan($insert, val) {
        $insert.set("username", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePersonByPersonIdInput: {
    clientMutationId: {
      applyPlan: UpdatePersonByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined,
    personPatch: {
      applyPlan: UpdatePersonByPersonIdInput_personPatch_applyPlan
    }
  },
  UpdatePersonByUsernameInput: {
    clientMutationId: {
      applyPlan: UpdatePersonByUsernameInput_clientMutationId_applyPlan
    },
    username: undefined,
    personPatch: {
      applyPlan: UpdatePersonByUsernameInput_personPatch_applyPlan
    }
  },
  UpdateRelationalItemRelationCompositePkPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateRelationalItemRelationCompositePkPayload_clientMutationIdPlan,
    relationalItemRelationCompositePk: UpdateRelationalItemRelationCompositePkPayload_relationalItemRelationCompositePkPlan,
    query: UpdateRelationalItemRelationCompositePkPayload_queryPlan,
    relationalItemRelationCompositePkEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques9[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return pgResource_relational_item_relation_composite_pksPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    relationalItemByChildId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    relationalItemByParentId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  UpdateRelationalItemRelationCompositePkInput: {
    clientMutationId: {
      applyPlan: UpdateRelationalItemRelationCompositePkInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    relationalItemRelationCompositePkPatch: {
      applyPlan: UpdateRelationalItemRelationCompositePkInput_relationalItemRelationCompositePkPatch_applyPlan
    }
  },
  RelationalItemRelationCompositePkPatch: {
    parentId: {
      applyPlan($insert, val) {
        $insert.set("parent_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($insert, val) {
        $insert.set("child_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateRelationalItemRelationCompositePkByParentIdAndChildIdInput: {
    clientMutationId: {
      applyPlan: UpdateRelationalItemRelationCompositePkByParentIdAndChildIdInput_clientMutationId_applyPlan
    },
    parentId: undefined,
    childId: undefined,
    relationalItemRelationCompositePkPatch: {
      applyPlan: UpdateRelationalItemRelationCompositePkByParentIdAndChildIdInput_relationalItemRelationCompositePkPatch_applyPlan
    }
  },
  UpdateSingleTableItemRelationCompositePkPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateSingleTableItemRelationCompositePkPayload_clientMutationIdPlan,
    singleTableItemRelationCompositePk: UpdateSingleTableItemRelationCompositePkPayload_singleTableItemRelationCompositePkPlan,
    query: UpdateSingleTableItemRelationCompositePkPayload_queryPlan,
    singleTableItemRelationCompositePkEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques11[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_single_table_item_relation_composite_pksPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    singleTableItemByChildId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  UpdateSingleTableItemRelationCompositePkInput: {
    clientMutationId: {
      applyPlan: UpdateSingleTableItemRelationCompositePkInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    singleTableItemRelationCompositePkPatch: {
      applyPlan: UpdateSingleTableItemRelationCompositePkInput_singleTableItemRelationCompositePkPatch_applyPlan
    }
  },
  SingleTableItemRelationCompositePkPatch: {
    parentId: {
      applyPlan($insert, val) {
        $insert.set("parent_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($insert, val) {
        $insert.set("child_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateSingleTableItemRelationCompositePkByParentIdAndChildIdInput: {
    clientMutationId: {
      applyPlan: UpdateSingleTableItemRelationCompositePkByParentIdAndChildIdInput_clientMutationId_applyPlan
    },
    parentId: undefined,
    childId: undefined,
    singleTableItemRelationCompositePkPatch: {
      applyPlan: UpdateSingleTableItemRelationCompositePkByParentIdAndChildIdInput_singleTableItemRelationCompositePkPatch_applyPlan
    }
  },
  UpdateRelationalItemRelationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateRelationalItemRelationPayload_clientMutationIdPlan,
    relationalItemRelation: UpdateRelationalItemRelationPayload_relationalItemRelationPlan,
    query: UpdateRelationalItemRelationPayload_queryPlan,
    relationalItemRelationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques14[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return pgResource_relational_item_relationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    relationalItemByChildId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    relationalItemByParentId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  UpdateRelationalItemRelationInput: {
    clientMutationId: {
      applyPlan: UpdateRelationalItemRelationInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    relationalItemRelationPatch: {
      applyPlan: UpdateRelationalItemRelationInput_relationalItemRelationPatch_applyPlan
    }
  },
  RelationalItemRelationPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($insert, val) {
        $insert.set("parent_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($insert, val) {
        $insert.set("child_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateRelationalItemRelationByIdInput: {
    clientMutationId: {
      applyPlan: UpdateRelationalItemRelationByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    relationalItemRelationPatch: {
      applyPlan: UpdateRelationalItemRelationByIdInput_relationalItemRelationPatch_applyPlan
    }
  },
  UpdateRelationalItemRelationByParentIdAndChildIdInput: {
    clientMutationId: {
      applyPlan: UpdateRelationalItemRelationByParentIdAndChildIdInput_clientMutationId_applyPlan
    },
    parentId: undefined,
    childId: undefined,
    relationalItemRelationPatch: {
      applyPlan: UpdateRelationalItemRelationByParentIdAndChildIdInput_relationalItemRelationPatch_applyPlan
    }
  },
  UpdateSingleTableItemRelationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateSingleTableItemRelationPayload_clientMutationIdPlan,
    singleTableItemRelation: UpdateSingleTableItemRelationPayload_singleTableItemRelationPlan,
    query: UpdateSingleTableItemRelationPayload_queryPlan,
    singleTableItemRelationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques15[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_single_table_item_relationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    singleTableItemByChildId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  UpdateSingleTableItemRelationInput: {
    clientMutationId: {
      applyPlan: UpdateSingleTableItemRelationInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    singleTableItemRelationPatch: {
      applyPlan: UpdateSingleTableItemRelationInput_singleTableItemRelationPatch_applyPlan
    }
  },
  SingleTableItemRelationPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    parentId: {
      applyPlan($insert, val) {
        $insert.set("parent_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    childId: {
      applyPlan($insert, val) {
        $insert.set("child_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateSingleTableItemRelationByIdInput: {
    clientMutationId: {
      applyPlan: UpdateSingleTableItemRelationByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    singleTableItemRelationPatch: {
      applyPlan: UpdateSingleTableItemRelationByIdInput_singleTableItemRelationPatch_applyPlan
    }
  },
  UpdateSingleTableItemRelationByParentIdAndChildIdInput: {
    clientMutationId: {
      applyPlan: UpdateSingleTableItemRelationByParentIdAndChildIdInput_clientMutationId_applyPlan
    },
    parentId: undefined,
    childId: undefined,
    singleTableItemRelationPatch: {
      applyPlan: UpdateSingleTableItemRelationByParentIdAndChildIdInput_singleTableItemRelationPatch_applyPlan
    }
  },
  UpdateLogEntryPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateLogEntryPayload_clientMutationIdPlan,
    logEntry: UpdateLogEntryPayload_logEntryPlan,
    query: UpdateLogEntryPayload_queryPlan,
    logEntryEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques16[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_log_entriesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("LogEntriesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("result").get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("result").get("person_id")
      });
    }
  },
  UpdateLogEntryInput: {
    clientMutationId: {
      applyPlan: UpdateLogEntryInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    logEntryPatch: {
      applyPlan: UpdateLogEntryInput_logEntryPatch_applyPlan
    }
  },
  LogEntryPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    text: {
      applyPlan($insert, val) {
        $insert.set("text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateLogEntryByIdInput: {
    clientMutationId: {
      applyPlan: UpdateLogEntryByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    logEntryPatch: {
      applyPlan: UpdateLogEntryByIdInput_logEntryPatch_applyPlan
    }
  },
  UpdateFirstPartyVulnerabilityPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateFirstPartyVulnerabilityPayload_clientMutationIdPlan,
    firstPartyVulnerability: UpdateFirstPartyVulnerabilityPayload_firstPartyVulnerabilityPlan,
    query: UpdateFirstPartyVulnerabilityPayload_queryPlan,
    firstPartyVulnerabilityEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques18[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return paths_0_resource_first_party_vulnerabilitiesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("FirstPartyVulnerabilitiesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateFirstPartyVulnerabilityInput: {
    clientMutationId: {
      applyPlan: UpdateFirstPartyVulnerabilityInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    firstPartyVulnerabilityPatch: {
      applyPlan: UpdateFirstPartyVulnerabilityInput_firstPartyVulnerabilityPatch_applyPlan
    }
  },
  FirstPartyVulnerabilityPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cvssScore: {
      applyPlan($insert, val) {
        $insert.set("cvss_score", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    teamName: {
      applyPlan($insert, val) {
        $insert.set("team_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateFirstPartyVulnerabilityByIdInput: {
    clientMutationId: {
      applyPlan: UpdateFirstPartyVulnerabilityByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    firstPartyVulnerabilityPatch: {
      applyPlan: UpdateFirstPartyVulnerabilityByIdInput_firstPartyVulnerabilityPatch_applyPlan
    }
  },
  UpdateThirdPartyVulnerabilityPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateThirdPartyVulnerabilityPayload_clientMutationIdPlan,
    thirdPartyVulnerability: UpdateThirdPartyVulnerabilityPayload_thirdPartyVulnerabilityPlan,
    query: UpdateThirdPartyVulnerabilityPayload_queryPlan,
    thirdPartyVulnerabilityEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques19[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return paths_1_resource_third_party_vulnerabilitiesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ThirdPartyVulnerabilitiesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateThirdPartyVulnerabilityInput: {
    clientMutationId: {
      applyPlan: UpdateThirdPartyVulnerabilityInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    thirdPartyVulnerabilityPatch: {
      applyPlan: UpdateThirdPartyVulnerabilityInput_thirdPartyVulnerabilityPatch_applyPlan
    }
  },
  ThirdPartyVulnerabilityPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cvssScore: {
      applyPlan($insert, val) {
        $insert.set("cvss_score", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    vendorName: {
      applyPlan($insert, val) {
        $insert.set("vendor_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateThirdPartyVulnerabilityByIdInput: {
    clientMutationId: {
      applyPlan: UpdateThirdPartyVulnerabilityByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    thirdPartyVulnerabilityPatch: {
      applyPlan: UpdateThirdPartyVulnerabilityByIdInput_thirdPartyVulnerabilityPatch_applyPlan
    }
  },
  UpdateAwsApplicationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateAwsApplicationPayload_clientMutationIdPlan,
    awsApplication: UpdateAwsApplicationPayload_awsApplicationPlan,
    query: UpdateAwsApplicationPayload_queryPlan,
    awsApplicationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques20[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_aws_applicationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("AwsApplicationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("result").get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("result").get("person_id")
      });
    }
  },
  UpdateAwsApplicationInput: {
    clientMutationId: {
      applyPlan: UpdateAwsApplicationInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    awsApplicationPatch: {
      applyPlan: UpdateAwsApplicationInput_awsApplicationPatch_applyPlan
    }
  },
  AwsApplicationPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastDeployed: {
      applyPlan($insert, val) {
        $insert.set("last_deployed", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    awsId: {
      applyPlan($insert, val) {
        $insert.set("aws_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateAwsApplicationByIdInput: {
    clientMutationId: {
      applyPlan: UpdateAwsApplicationByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    awsApplicationPatch: {
      applyPlan: UpdateAwsApplicationByIdInput_awsApplicationPatch_applyPlan
    }
  },
  UpdateGcpApplicationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateGcpApplicationPayload_clientMutationIdPlan,
    gcpApplication: UpdateGcpApplicationPayload_gcpApplicationPlan,
    query: UpdateGcpApplicationPayload_queryPlan,
    gcpApplicationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_gcp_applicationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("GcpApplicationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("result").get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("result").get("person_id")
      });
    }
  },
  UpdateGcpApplicationInput: {
    clientMutationId: {
      applyPlan: UpdateGcpApplicationInput_clientMutationId_applyPlan
    },
    nodeId: undefined,
    gcpApplicationPatch: {
      applyPlan: UpdateGcpApplicationInput_gcpApplicationPatch_applyPlan
    }
  },
  GcpApplicationPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastDeployed: {
      applyPlan($insert, val) {
        $insert.set("last_deployed", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    gcpId: {
      applyPlan($insert, val) {
        $insert.set("gcp_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateGcpApplicationByIdInput: {
    clientMutationId: {
      applyPlan: UpdateGcpApplicationByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    gcpApplicationPatch: {
      applyPlan: UpdateGcpApplicationByIdInput_gcpApplicationPatch_applyPlan
    }
  },
  DeleteOrganizationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteOrganizationPayload_clientMutationIdPlan,
    organization: DeleteOrganizationPayload_organizationPlan,
    deletedOrganizationId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = handler4.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteOrganizationPayload_queryPlan,
    organizationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques5[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_organizationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("OrganizationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteOrganizationInput: {
    clientMutationId: {
      applyPlan: DeleteOrganizationInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteOrganizationByOrganizationIdInput: {
    clientMutationId: {
      applyPlan: DeleteOrganizationByOrganizationIdInput_clientMutationId_applyPlan
    },
    organizationId: undefined
  },
  DeleteOrganizationByNameInput: {
    clientMutationId: {
      applyPlan: DeleteOrganizationByNameInput_clientMutationId_applyPlan
    },
    name: undefined
  },
  DeletePersonPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeletePersonPayload_clientMutationIdPlan,
    person: DeletePersonPayload_personPlan,
    deletedPersonId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = handler2.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeletePersonPayload_queryPlan,
    personEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques6[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_peoplePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeletePersonInput: {
    clientMutationId: {
      applyPlan: DeletePersonInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeletePersonByPersonIdInput: {
    clientMutationId: {
      applyPlan: DeletePersonByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined
  },
  DeletePersonByUsernameInput: {
    clientMutationId: {
      applyPlan: DeletePersonByUsernameInput_clientMutationId_applyPlan
    },
    username: undefined
  },
  DeleteRelationalItemRelationCompositePkPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteRelationalItemRelationCompositePkPayload_clientMutationIdPlan,
    relationalItemRelationCompositePk: DeleteRelationalItemRelationCompositePkPayload_relationalItemRelationCompositePkPlan,
    deletedRelationalItemRelationCompositePkId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = handler8.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteRelationalItemRelationCompositePkPayload_queryPlan,
    relationalItemRelationCompositePkEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques9[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return pgResource_relational_item_relation_composite_pksPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationCompositePksOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    relationalItemByChildId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    relationalItemByParentId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  DeleteRelationalItemRelationCompositePkInput: {
    clientMutationId: {
      applyPlan: DeleteRelationalItemRelationCompositePkInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteRelationalItemRelationCompositePkByParentIdAndChildIdInput: {
    clientMutationId: {
      applyPlan: DeleteRelationalItemRelationCompositePkByParentIdAndChildIdInput_clientMutationId_applyPlan
    },
    parentId: undefined,
    childId: undefined
  },
  DeleteSingleTableItemRelationCompositePkPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteSingleTableItemRelationCompositePkPayload_clientMutationIdPlan,
    singleTableItemRelationCompositePk: DeleteSingleTableItemRelationCompositePkPayload_singleTableItemRelationCompositePkPlan,
    deletedSingleTableItemRelationCompositePkId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = handler10.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteSingleTableItemRelationCompositePkPayload_queryPlan,
    singleTableItemRelationCompositePkEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques11[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_single_table_item_relation_composite_pksPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationCompositePksOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    singleTableItemByChildId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  DeleteSingleTableItemRelationCompositePkInput: {
    clientMutationId: {
      applyPlan: DeleteSingleTableItemRelationCompositePkInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteSingleTableItemRelationCompositePkByParentIdAndChildIdInput: {
    clientMutationId: {
      applyPlan: DeleteSingleTableItemRelationCompositePkByParentIdAndChildIdInput_clientMutationId_applyPlan
    },
    parentId: undefined,
    childId: undefined
  },
  DeleteRelationalItemRelationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteRelationalItemRelationPayload_clientMutationIdPlan,
    relationalItemRelation: DeleteRelationalItemRelationPayload_relationalItemRelationPlan,
    deletedRelationalItemRelationId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = handler7.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteRelationalItemRelationPayload_queryPlan,
    relationalItemRelationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques14[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return pgResource_relational_item_relationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("RelationalItemRelationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    relationalItemByChildId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    relationalItemByParentId($record) {
      return otherSource_relational_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  DeleteRelationalItemRelationInput: {
    clientMutationId: {
      applyPlan: DeleteRelationalItemRelationInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteRelationalItemRelationByIdInput: {
    clientMutationId: {
      applyPlan: DeleteRelationalItemRelationByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteRelationalItemRelationByParentIdAndChildIdInput: {
    clientMutationId: {
      applyPlan: DeleteRelationalItemRelationByParentIdAndChildIdInput_clientMutationId_applyPlan
    },
    parentId: undefined,
    childId: undefined
  },
  DeleteSingleTableItemRelationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteSingleTableItemRelationPayload_clientMutationIdPlan,
    singleTableItemRelation: DeleteSingleTableItemRelationPayload_singleTableItemRelationPlan,
    deletedSingleTableItemRelationId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = handler9.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteSingleTableItemRelationPayload_queryPlan,
    singleTableItemRelationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques15[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_single_table_item_relationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SingleTableItemRelationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    singleTableItemByChildId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("child_id")
      });
    },
    singleTableItemByParentId($record) {
      return resource_single_table_itemsPgResource.get({
        id: $record.get("result").get("parent_id")
      });
    }
  },
  DeleteSingleTableItemRelationInput: {
    clientMutationId: {
      applyPlan: DeleteSingleTableItemRelationInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteSingleTableItemRelationByIdInput: {
    clientMutationId: {
      applyPlan: DeleteSingleTableItemRelationByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteSingleTableItemRelationByParentIdAndChildIdInput: {
    clientMutationId: {
      applyPlan: DeleteSingleTableItemRelationByParentIdAndChildIdInput_clientMutationId_applyPlan
    },
    parentId: undefined,
    childId: undefined
  },
  DeleteLogEntryPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteLogEntryPayload_clientMutationIdPlan,
    logEntry: DeleteLogEntryPayload_logEntryPlan,
    deletedLogEntryId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = handler3.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteLogEntryPayload_queryPlan,
    logEntryEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques16[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_log_entriesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("LogEntriesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("result").get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("result").get("person_id")
      });
    }
  },
  DeleteLogEntryInput: {
    clientMutationId: {
      applyPlan: DeleteLogEntryInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteLogEntryByIdInput: {
    clientMutationId: {
      applyPlan: DeleteLogEntryByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteFirstPartyVulnerabilityPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteFirstPartyVulnerabilityPayload_clientMutationIdPlan,
    firstPartyVulnerability: DeleteFirstPartyVulnerabilityPayload_firstPartyVulnerabilityPlan,
    deletedFirstPartyVulnerabilityId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = nodeIdHandlerByTypeName.FirstPartyVulnerability.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteFirstPartyVulnerabilityPayload_queryPlan,
    firstPartyVulnerabilityEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques18[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return paths_0_resource_first_party_vulnerabilitiesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("FirstPartyVulnerabilitiesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteFirstPartyVulnerabilityInput: {
    clientMutationId: {
      applyPlan: DeleteFirstPartyVulnerabilityInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteFirstPartyVulnerabilityByIdInput: {
    clientMutationId: {
      applyPlan: DeleteFirstPartyVulnerabilityByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteThirdPartyVulnerabilityPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteThirdPartyVulnerabilityPayload_clientMutationIdPlan,
    thirdPartyVulnerability: DeleteThirdPartyVulnerabilityPayload_thirdPartyVulnerabilityPlan,
    deletedThirdPartyVulnerabilityId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = nodeIdHandlerByTypeName.ThirdPartyVulnerability.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteThirdPartyVulnerabilityPayload_queryPlan,
    thirdPartyVulnerabilityEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques19[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return paths_1_resource_third_party_vulnerabilitiesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ThirdPartyVulnerabilitiesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteThirdPartyVulnerabilityInput: {
    clientMutationId: {
      applyPlan: DeleteThirdPartyVulnerabilityInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteThirdPartyVulnerabilityByIdInput: {
    clientMutationId: {
      applyPlan: DeleteThirdPartyVulnerabilityByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteAwsApplicationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteAwsApplicationPayload_clientMutationIdPlan,
    awsApplication: DeleteAwsApplicationPayload_awsApplicationPlan,
    deletedAwsApplicationId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = handler5.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteAwsApplicationPayload_queryPlan,
    awsApplicationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques20[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_aws_applicationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("AwsApplicationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("result").get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("result").get("person_id")
      });
    }
  },
  DeleteAwsApplicationInput: {
    clientMutationId: {
      applyPlan: DeleteAwsApplicationInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteAwsApplicationByIdInput: {
    clientMutationId: {
      applyPlan: DeleteAwsApplicationByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteGcpApplicationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteGcpApplicationPayload_clientMutationIdPlan,
    gcpApplication: DeleteGcpApplicationPayload_gcpApplicationPlan,
    deletedGcpApplicationId($object) {
      const $record = $object.getStepForKey("result");
      const specifier = handler6.plan($record);
      return lambda(specifier, handler4.codec.encode);
    },
    query: DeleteGcpApplicationPayload_queryPlan,
    gcpApplicationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return otherSource_gcp_applicationsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("GcpApplicationsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    organizationByOrganizationId($record) {
      return otherSource_organizationsPgResource.get({
        organization_id: $record.get("result").get("organization_id")
      });
    },
    personByPersonId($record) {
      return otherSource_peoplePgResource.get({
        person_id: $record.get("result").get("person_id")
      });
    }
  },
  DeleteGcpApplicationInput: {
    clientMutationId: {
      applyPlan: DeleteGcpApplicationInput_clientMutationId_applyPlan
    },
    nodeId: undefined
  },
  DeleteGcpApplicationByIdInput: {
    clientMutationId: {
      applyPlan: DeleteGcpApplicationByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  }
};
export const schema = makeGrafastSchema({
  typeDefs: typeDefs,
  plans: plans
});
