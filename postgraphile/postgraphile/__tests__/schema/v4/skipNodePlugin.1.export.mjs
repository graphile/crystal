import { PgDeleteSingleStep, PgExecutor, PgResource, PgSelectSingleStep, PgSelectStep, PgUnionAllStep, TYPES, assertPgClassSingleStep, domainOfCodec, enumCodec, listOfCodec, makeRegistry, pgClassExpression, pgDeleteSingle, pgInsertSingle, pgSelectFromRecord, pgSelectFromRecords, pgSelectSingleFromRecord, pgUpdateSingle, rangeOfCodec, recordCodec, sqlFromArgDigests } from "@dataplan/pg";
import { ConnectionStep, EdgeStep, ObjectStep, SafeError, __ValueStep, access, assertEdgeCapableStep, assertExecutableStep, assertPageInfoCapableStep, connection, constant, context, first, getEnumValueConfig, makeGrafastSchema, object, rootValue, stepAMayDependOnStepB } from "grafast";
import { sql } from "pg-sql2";
import { inspect } from "util";
function Query_queryPlan() {
  return rootValue();
}
const executor_mainPgExecutor = new PgExecutor({
  name: "main",
  context() {
    const ctx = context();
    return object({
      pgSettings: "pgSettings" != null ? ctx.get("pgSettings") : constant(null),
      withPgClient: ctx.get("withPgClient")
    });
  }
});
const registryConfig_pgCodecs_FuncOutOutRecord_FuncOutOutRecord = recordCodec({
  name: "FuncOutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: Object.assign(Object.create(null), {
    first_out: {
      notNull: false,
      codec: TYPES.int,
      extensions: {
        argIndex: 0,
        argName: "first_out"
      }
    },
    second_out: {
      notNull: false,
      codec: TYPES.text,
      extensions: {
        argIndex: 1,
        argName: "second_out"
      }
    }
  }),
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes2 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_FuncOutOutSetofRecord_FuncOutOutSetofRecord = recordCodec({
  name: "FuncOutOutSetofRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes2,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes3 = Object.assign(Object.create(null), {
  column1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: undefined
    }
  },
  column2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: undefined
    }
  }
});
const registryConfig_pgCodecs_FuncOutOutUnnamedRecord_FuncOutOutUnnamedRecord = recordCodec({
  name: "FuncOutOutUnnamedRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes3,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes4 = Object.assign(Object.create(null), {
  first_out: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: "first_out"
    }
  },
  second_out: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "second_out"
    }
  }
});
const registryConfig_pgCodecs_MutationOutOutRecord_MutationOutOutRecord = recordCodec({
  name: "MutationOutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes4,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes5 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_MutationOutOutSetofRecord_MutationOutOutSetofRecord = recordCodec({
  name: "MutationOutOutSetofRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes5,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes6 = Object.assign(Object.create(null), {
  column1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: undefined
    }
  },
  column2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: undefined
    }
  }
});
const registryConfig_pgCodecs_MutationOutOutUnnamedRecord_MutationOutOutUnnamedRecord = recordCodec({
  name: "MutationOutOutUnnamedRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes6,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes7 = Object.assign(Object.create(null), {
  id: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: "id"
    }
  },
  total_duration: {
    notNull: false,
    codec: TYPES.interval,
    extensions: {
      argIndex: 1,
      argName: "total_duration"
    }
  }
});
const registryConfig_pgCodecs_SearchTestSummariesRecord_SearchTestSummariesRecord = recordCodec({
  name: "SearchTestSummariesRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes7,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes8 = Object.assign(Object.create(null), {
  column1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: ""
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o2"
    }
  },
  column3: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: ""
    }
  }
});
const registryConfig_pgCodecs_FuncOutUnnamedOutOutUnnamedRecord_FuncOutUnnamedOutOutUnnamedRecord = recordCodec({
  name: "FuncOutUnnamedOutOutUnnamedRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes8,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes9 = Object.assign(Object.create(null), {
  col1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "col1"
    }
  },
  col2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "col2"
    }
  }
});
const registryConfig_pgCodecs_FuncReturnsTableMultiColRecord_FuncReturnsTableMultiColRecord = recordCodec({
  name: "FuncReturnsTableMultiColRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes9,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes10 = Object.assign(Object.create(null), {
  column1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 0,
      argName: ""
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o2"
    }
  },
  column3: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: ""
    }
  }
});
const registryConfig_pgCodecs_MutationOutUnnamedOutOutUnnamedRecord_MutationOutUnnamedOutOutUnnamedRecord = recordCodec({
  name: "MutationOutUnnamedOutOutUnnamedRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes10,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes11 = Object.assign(Object.create(null), {
  col1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "col1"
    }
  },
  col2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "col2"
    }
  }
});
const registryConfig_pgCodecs_MutationReturnsTableMultiColRecord_MutationReturnsTableMultiColRecord = recordCodec({
  name: "MutationReturnsTableMultiColRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes11,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const sqlIdent = sql.identifier(...["b", "guid"]);
const registryConfig_pgCodecs_guid_guid = domainOfCodec(TYPES.varchar, "guid", sqlIdent, {
  description: undefined,
  extensions: {
    oid: "1467949",
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "guid"
    },
    tags: Object.create(null)
  },
  notNull: false
});
const extensions2 = {
  oid: "1187",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_interval"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_intervalArray_intervalArray = listOfCodec(TYPES.interval, {
  extensions: extensions2,
  typeDelim: ",",
  description: undefined,
  name: "intervalArray"
});
const extensions3 = {
  oid: "1009",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_text"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_textArray_textArray = listOfCodec(TYPES.text, {
  extensions: extensions3,
  typeDelim: ",",
  description: undefined,
  name: "textArray"
});
const attributes12 = Object.assign(Object.create(null), {
  "?column?": {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions4 = {
  oid: "1468027",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "non_updatable_view"
  },
  tags: Object.create(null)
};
const parts2 = ["a", "non_updatable_view"];
const sqlIdent2 = sql.identifier(...parts2);
const spec_nonUpdatableView = {
  name: "nonUpdatableView",
  identifier: sqlIdent2,
  attributes: attributes12,
  description: undefined,
  extensions: extensions4,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_nonUpdatableView_nonUpdatableView = recordCodec(spec_nonUpdatableView);
const attributes13 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions5 = {
  oid: "1468240",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "inputs"
  },
  tags: Object.create(null)
};
const parts3 = ["a", "inputs"];
const sqlIdent3 = sql.identifier(...parts3);
const spec_inputs = {
  name: "inputs",
  identifier: sqlIdent3,
  attributes: attributes13,
  description: "Should output as Input",
  extensions: extensions5,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_inputs_inputs = recordCodec(spec_inputs);
const attributes14 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions6 = {
  oid: "1468247",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "patchs"
  },
  tags: Object.create(null)
};
const parts4 = ["a", "patchs"];
const sqlIdent4 = sql.identifier(...parts4);
const spec_patchs = {
  name: "patchs",
  identifier: sqlIdent4,
  attributes: attributes14,
  description: "Should output as Patch",
  extensions: extensions6,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_patchs_patchs = recordCodec(spec_patchs);
const attributes15 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions7 = {
  oid: "1468254",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reserved"
  },
  tags: Object.create(null)
};
const parts5 = ["a", "reserved"];
const sqlIdent5 = sql.identifier(...parts5);
const spec_reserved = {
  name: "reserved",
  identifier: sqlIdent5,
  attributes: attributes15,
  description: undefined,
  extensions: extensions7,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_reserved_reserved = recordCodec(spec_reserved);
const attributes16 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions8 = {
  oid: "1468268",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reservedPatchs"
  },
  tags: Object.create(null)
};
const parts6 = ["a", "reservedPatchs"];
const sqlIdent6 = sql.identifier(...parts6);
const spec_reservedPatchs = {
  name: "reservedPatchs",
  identifier: sqlIdent6,
  attributes: attributes16,
  description: "`reservedPatchs` table should get renamed to ReservedPatchRecord to prevent clashes with ReservedPatch from `reserved` table",
  extensions: extensions8,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_reservedPatchs_reservedPatchs = recordCodec(spec_reservedPatchs);
const attributes17 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions9 = {
  oid: "1468261",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reserved_input"
  },
  tags: Object.create(null)
};
const parts7 = ["a", "reserved_input"];
const sqlIdent7 = sql.identifier(...parts7);
const spec_reservedInput = {
  name: "reservedInput",
  identifier: sqlIdent7,
  attributes: attributes17,
  description: "`reserved_input` table should get renamed to ReservedInputRecord to prevent clashes with ReservedInput from `reserved` table",
  extensions: extensions9,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_reservedInput_reservedInput = recordCodec(spec_reservedInput);
const attributes18 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  null_value: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions10 = {
  oid: "1468217",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "default_value"
  },
  tags: Object.create(null)
};
const parts8 = ["a", "default_value"];
const sqlIdent8 = sql.identifier(...parts8);
const spec_defaultValue = {
  name: "defaultValue",
  identifier: sqlIdent8,
  attributes: attributes18,
  description: undefined,
  extensions: extensions10,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_defaultValue_defaultValue = recordCodec(spec_defaultValue);
const attributes19 = Object.assign(Object.create(null), {
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  compound_key_1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  compound_key_2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions11 = {
  oid: "1468046",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "foreign_key"
  },
  tags: Object.create(null)
};
const parts9 = ["a", "foreign_key"];
const sqlIdent9 = sql.identifier(...parts9);
const spec_foreignKey = {
  name: "foreignKey",
  identifier: sqlIdent9,
  attributes: attributes19,
  description: undefined,
  extensions: extensions11,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_foreignKey_foreignKey = recordCodec(spec_foreignKey);
const attributes20 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  str: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions12 = {
  oid: "1467856",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "no_primary_key"
  },
  tags: Object.create(null)
};
const parts10 = ["a", "no_primary_key"];
const sqlIdent10 = sql.identifier(...parts10);
const spec_noPrimaryKey = {
  name: "noPrimaryKey",
  identifier: sqlIdent10,
  attributes: attributes20,
  description: undefined,
  extensions: extensions12,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_noPrimaryKey_noPrimaryKey = recordCodec(spec_noPrimaryKey);
const attributes21 = Object.assign(Object.create(null), {
  testviewid: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions13 = {
  oid: "1468233",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "testview"
  },
  tags: Object.create(null)
};
const parts11 = ["a", "testview"];
const sqlIdent11 = sql.identifier(...parts11);
const spec_testview = {
  name: "testview",
  identifier: sqlIdent11,
  attributes: attributes21,
  description: undefined,
  extensions: extensions13,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_testview_testview = recordCodec(spec_testview);
const attributes22 = Object.assign(Object.create(null), {
  compound_key_1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  compound_key_2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions14 = {
  oid: "1468064",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "unique_foreign_key"
  },
  tags: Object.assign(Object.create(null), {
    omit: "create,update,delete,all,order,filter",
    behavior: ["-insert -update -delete -query:resource:list -query:resource:connection -order -orderBy -filter -filterBy"]
  })
};
const parts12 = ["a", "unique_foreign_key"];
const sqlIdent12 = sql.identifier(...parts12);
const spec_uniqueForeignKey = {
  name: "uniqueForeignKey",
  identifier: sqlIdent12,
  attributes: attributes22,
  description: undefined,
  extensions: extensions14,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey = recordCodec(spec_uniqueForeignKey);
const attributes23 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  json_data: {
    description: undefined,
    codec: TYPES.jsonb,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions15 = {
  oid: "1468276",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "my_table"
  },
  tags: Object.create(null)
};
const parts13 = ["c", "my_table"];
const sqlIdent13 = sql.identifier(...parts13);
const spec_myTable = {
  name: "myTable",
  identifier: sqlIdent13,
  attributes: attributes23,
  description: undefined,
  extensions: extensions15,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_myTable_myTable = recordCodec(spec_myTable);
const attributes24 = Object.assign(Object.create(null), {
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  sekrit: {
    description: "A secret held by the associated Person",
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {
        name: "secret"
      }
    }
  }
});
const extensions16 = {
  oid: "1467877",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_secret"
  },
  tags: Object.assign(Object.create(null), {
    deprecated: "This is deprecated (comment on table c.person_secret)."
  })
};
const parts14 = ["c", "person_secret"];
const sqlIdent14 = sql.identifier(...parts14);
const spec_personSecret = {
  name: "personSecret",
  identifier: sqlIdent14,
  attributes: attributes24,
  description: "Tracks the person's secret",
  extensions: extensions16,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_personSecret_personSecret = recordCodec(spec_personSecret);
const attributes25 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  col1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions17 = {
  oid: "1468227",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "view_table"
  },
  tags: Object.create(null)
};
const parts15 = ["a", "view_table"];
const sqlIdent15 = sql.identifier(...parts15);
const spec_viewTable = {
  name: "viewTable",
  identifier: sqlIdent15,
  attributes: attributes25,
  description: undefined,
  extensions: extensions17,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_viewTable_viewTable = recordCodec(spec_viewTable);
const attributes26 = Object.assign(Object.create(null), {
  person_id_2: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  person_id_1: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  extra: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions18 = {
  oid: "1468031",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_key"
  },
  tags: Object.create(null)
};
const parts16 = ["c", "compound_key"];
const sqlIdent16 = sql.identifier(...parts16);
const spec_compoundKey = {
  name: "compoundKey",
  identifier: sqlIdent16,
  attributes: attributes26,
  description: undefined,
  extensions: extensions18,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_compoundKey_compoundKey = recordCodec(spec_compoundKey);
const attributes27 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  col1: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col2: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col3: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions19 = {
  oid: "1468203",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "similar_table_1"
  },
  tags: Object.create(null)
};
const parts17 = ["a", "similar_table_1"];
const sqlIdent17 = sql.identifier(...parts17);
const spec_similarTable1 = {
  name: "similarTable1",
  identifier: sqlIdent17,
  attributes: attributes27,
  description: undefined,
  extensions: extensions19,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_similarTable1_similarTable1 = recordCodec(spec_similarTable1);
const attributes28 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  col3: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col4: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  col5: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions20 = {
  oid: "1468210",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "similar_table_2"
  },
  tags: Object.create(null)
};
const parts18 = ["a", "similar_table_2"];
const sqlIdent18 = sql.identifier(...parts18);
const spec_similarTable2 = {
  name: "similarTable2",
  identifier: sqlIdent18,
  attributes: attributes28,
  description: undefined,
  extensions: extensions20,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_similarTable2_similarTable2 = recordCodec(spec_similarTable2);
const attributes_object_Object_ = Object.assign(Object.create(null), {
  x: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  name: {
    description: undefined,
    codec: TYPES.varchar,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  description: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  constant: {
    description: "This is constantly 2",
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions21 = {
  oid: "1468023",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "updatable_view"
  },
  tags: Object.assign(Object.create(null), {
    uniqueKey: "x",
    unique: "x|@behavior -single -update -delete"
  })
};
const parts19 = ["b", "updatable_view"];
const sqlIdent19 = sql.identifier(...parts19);
const spec_updatableView = {
  name: "updatableView",
  identifier: sqlIdent19,
  attributes: attributes_object_Object_,
  description: "YOYOYO!!",
  extensions: extensions21,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_updatableView_updatableView = recordCodec(spec_updatableView);
const attributes29 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  nullable_text: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullable_int: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  non_null_text: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions22 = {
  oid: "1468294",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "null_test_record"
  },
  tags: Object.create(null)
};
const parts20 = ["c", "null_test_record"];
const sqlIdent20 = sql.identifier(...parts20);
const spec_nullTestRecord = {
  name: "nullTestRecord",
  identifier: sqlIdent20,
  attributes: attributes29,
  description: undefined,
  extensions: extensions22,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_nullTestRecord_nullTestRecord = recordCodec(spec_nullTestRecord);
const extensions23 = {
  oid: "2951",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_uuid"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_uuidArray_uuidArray = listOfCodec(TYPES.uuid, {
  extensions: extensions23,
  typeDelim: ",",
  description: undefined,
  name: "uuidArray"
});
const attributes30 = Object.assign(Object.create(null), {
  not_null_has_default: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  wont_cast_easy: {
    description: undefined,
    codec: TYPES.int2,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  row_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions24 = {
  oid: "1468079",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "edge_case"
  },
  tags: Object.create(null)
};
const parts21 = ["c", "edge_case"];
const sqlIdent21 = sql.identifier(...parts21);
const spec_edgeCase = {
  name: "edgeCase",
  identifier: sqlIdent21,
  attributes: attributes30,
  description: undefined,
  extensions: extensions24,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_edgeCase_edgeCase = recordCodec(spec_edgeCase);
const attributes31 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  person_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  length_in_metres: {
    description: undefined,
    codec: TYPES.float,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  mood: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions25 = {
  oid: "1467890",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "left_arm"
  },
  tags: Object.create(null)
};
const parts22 = ["c", "left_arm"];
const sqlIdent22 = sql.identifier(...parts22);
const spec_leftArm = {
  name: "leftArm",
  identifier: sqlIdent22,
  attributes: attributes31,
  description: "Tracks metadata about the left arms of various people",
  extensions: extensions25,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_leftArm_leftArm = recordCodec(spec_leftArm);
const attributes32 = Object.assign(Object.create(null), {
  role: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  exp: {
    description: undefined,
    codec: TYPES.bigint,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  a: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  b: {
    description: undefined,
    codec: TYPES.numeric,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  c: {
    description: undefined,
    codec: TYPES.bigint,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions26 = {
  oid: "1468192",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "jwt_token"
  },
  tags: Object.create(null)
};
const parts23 = ["b", "jwt_token"];
const sqlIdent23 = sql.identifier(...parts23);
const spec_jwtToken = {
  name: "jwtToken",
  identifier: sqlIdent23,
  attributes: attributes32,
  description: undefined,
  extensions: extensions26,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_jwtToken_jwtToken = recordCodec(spec_jwtToken);
const extensions27 = {
  oid: "1468283",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "not_null_timestamp"
  },
  tags: Object.create(null)
};
const parts24 = ["c", "not_null_timestamp"];
const sqlIdent24 = sql.identifier(...parts24);
const attributes_ts_codec_notNullTimestamp = domainOfCodec(TYPES.timestamptz, "notNullTimestamp", sqlIdent24, {
  description: undefined,
  extensions: extensions27,
  notNull: true
});
const attributes33 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  ts: {
    description: undefined,
    codec: attributes_ts_codec_notNullTimestamp,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions28 = {
  oid: "1468287",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "issue756"
  },
  tags: Object.create(null)
};
const parts25 = ["c", "issue756"];
const sqlIdent25 = sql.identifier(...parts25);
const spec_issue756 = {
  name: "issue756",
  identifier: sqlIdent25,
  attributes: attributes33,
  description: undefined,
  extensions: extensions28,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_issue756_issue756 = recordCodec(spec_issue756);
const attributes34 = Object.assign(Object.create(null), {
  jwt: {
    description: undefined,
    codec: registryConfig_pgCodecs_jwtToken_jwtToken,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  admin: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions29 = {
  oid: "1468198",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "auth_payload"
  },
  tags: Object.assign(Object.create(null), {
    foreignKey: "(id) references c.person"
  })
};
const parts26 = ["b", "auth_payload"];
const sqlIdent26 = sql.identifier(...parts26);
const spec_authPayload = {
  name: "authPayload",
  identifier: sqlIdent26,
  attributes: attributes34,
  description: undefined,
  extensions: extensions29,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_authPayload_authPayload = recordCodec(spec_authPayload);
const extensions30 = {
  oid: "1467980",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "color"
  },
  tags: Object.create(null)
};
const parts27 = ["b", "color"];
const sqlIdent27 = sql.identifier(...parts27);
const attributes_c_codec_color = enumCodec({
  name: "color",
  identifier: sqlIdent27,
  values: ["red", "green", "blue"],
  description: undefined,
  extensions: extensions30
});
const enumLabels2 = ["FOO_BAR", "BAR_FOO", "BAZ_QUX", "0_BAR"];
const extensions31 = {
  oid: "1467988",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "enum_caps"
  },
  tags: Object.create(null)
};
const parts28 = ["b", "enum_caps"];
const sqlIdent28 = sql.identifier(...parts28);
const attributes_e_codec_enumCaps = enumCodec({
  name: "enumCaps",
  identifier: sqlIdent28,
  values: enumLabels2,
  description: undefined,
  extensions: extensions31
});
const enumLabels3 = ["", "one", "two"];
const extensions32 = {
  oid: "1467998",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "enum_with_empty_string"
  },
  tags: Object.create(null)
};
const parts29 = ["b", "enum_with_empty_string"];
const sqlIdent29 = sql.identifier(...parts29);
const attributes_f_codec_enumWithEmptyString = enumCodec({
  name: "enumWithEmptyString",
  identifier: sqlIdent29,
  values: enumLabels3,
  description: undefined,
  extensions: extensions32
});
const attributes36 = Object.assign(Object.create(null), {
  a: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  b: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  c: {
    description: undefined,
    codec: attributes_c_codec_color,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  d: {
    description: undefined,
    codec: TYPES.uuid,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  e: {
    description: undefined,
    codec: attributes_e_codec_enumCaps,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  f: {
    description: undefined,
    codec: attributes_f_codec_enumWithEmptyString,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  g: {
    description: undefined,
    codec: TYPES.interval,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  foo_bar: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions33 = {
  oid: "1468007",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_type"
  },
  tags: Object.create(null)
};
const parts30 = ["c", "compound_type"];
const sqlIdent30 = sql.identifier(...parts30);
const spec_compoundType = {
  name: "compoundType",
  identifier: sqlIdent30,
  attributes: attributes36,
  description: "Awesome feature!",
  extensions: extensions33,
  executor: executor_mainPgExecutor
};
const attributes_o2_codec_compoundType = recordCodec(spec_compoundType);
const attributes35 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: attributes_o2_codec_compoundType,
    extensions: {
      argIndex: 2,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_FuncOutOutCompoundTypeRecord_FuncOutOutCompoundTypeRecord = recordCodec({
  name: "FuncOutOutCompoundTypeRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes35,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes37 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: attributes_o2_codec_compoundType,
    extensions: {
      argIndex: 2,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_MutationOutOutCompoundTypeRecord_MutationOutOutCompoundTypeRecord = recordCodec({
  name: "MutationOutOutCompoundTypeRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes37,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const extensions34 = {
  oid: "1467907",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "_an_enum"
  },
  tags: Object.create(null)
};
const enumLabels4 = ["awaiting", "rejected", "published", "*", "**", "***", "foo*", "foo*_", "_foo*", "*bar", "*bar_", "_*bar_", "*baz*", "_*baz*_", "%", ">=", "~~", "$"];
const extensions35 = {
  oid: "1467908",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "an_enum"
  },
  tags: Object.create(null)
};
const parts31 = ["a", "an_enum"];
const sqlIdent31 = sql.identifier(...parts31);
const innerCodec_anEnum = enumCodec({
  name: "anEnum",
  identifier: sqlIdent31,
  values: enumLabels4,
  description: undefined,
  extensions: extensions35
});
const attributes_enums_codec_anEnumArray = listOfCodec(innerCodec_anEnum, {
  extensions: extensions34,
  typeDelim: ",",
  description: undefined,
  name: "anEnumArray"
});
const extensions36 = {
  oid: "1467946",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "_comptype"
  },
  tags: Object.create(null)
};
const attributes40 = Object.assign(Object.create(null), {
  schedule: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  is_optimised: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions37 = {
  oid: "1467947",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "comptype"
  },
  tags: Object.create(null)
};
const parts32 = ["a", "comptype"];
const sqlIdent32 = sql.identifier(...parts32);
const spec_comptype = {
  name: "comptype",
  identifier: sqlIdent32,
  attributes: attributes40,
  description: undefined,
  extensions: extensions37,
  executor: executor_mainPgExecutor
};
const innerCodec_comptype = recordCodec(spec_comptype);
const attributes_comptypes_codec_comptypeArray = listOfCodec(innerCodec_comptype, {
  extensions: extensions36,
  typeDelim: ",",
  description: undefined,
  name: "comptypeArray"
});
const attributes39 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  headline: {
    description: undefined,
    codec: TYPES.text,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  body: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  author_id: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  enums: {
    description: undefined,
    codec: attributes_enums_codec_anEnumArray,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  comptypes: {
    description: undefined,
    codec: attributes_comptypes_codec_comptypeArray,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions38 = {
  oid: "1467955",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post"
  },
  tags: Object.create(null)
};
const parts33 = ["a", "post"];
const sqlIdent33 = sql.identifier(...parts33);
const spec_post = {
  name: "post",
  identifier: sqlIdent33,
  attributes: attributes39,
  description: undefined,
  extensions: extensions38,
  executor: executor_mainPgExecutor
};
const attributes_post_codec_post = recordCodec(spec_post);
const attributes38 = Object.assign(Object.create(null), {
  txt: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "txt"
    }
  },
  left_arm: {
    notNull: false,
    codec: registryConfig_pgCodecs_leftArm_leftArm,
    extensions: {
      argIndex: 3,
      argName: "left_arm"
    }
  },
  post: {
    notNull: false,
    codec: attributes_post_codec_post,
    extensions: {
      argIndex: 4,
      argName: "post"
    }
  }
});
const registryConfig_pgCodecs_QueryOutputTwoRowsRecord_QueryOutputTwoRowsRecord = recordCodec({
  name: "QueryOutputTwoRowsRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes38,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes41 = Object.assign(Object.create(null), {
  o1: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "o1"
    }
  },
  o2: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "o2"
    }
  }
});
const registryConfig_pgCodecs_PersonComputedOutOutRecord_PersonComputedOutOutRecord = recordCodec({
  name: "PersonComputedOutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes41,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes42 = Object.assign(Object.create(null), {
  ino: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 1,
      argName: "ino"
    }
  },
  o: {
    notNull: false,
    codec: TYPES.text,
    extensions: {
      argIndex: 2,
      argName: "o"
    }
  }
});
const registryConfig_pgCodecs_PersonComputedInoutOutRecord_PersonComputedInoutOutRecord = recordCodec({
  name: "PersonComputedInoutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes42,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const extensions39 = {
  oid: "1467852",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "email"
  },
  tags: Object.create(null)
};
const parts34 = ["b", "email"];
const sqlIdent34 = sql.identifier(...parts34);
const attributes_email_codec_email = domainOfCodec(TYPES.text, "email", sqlIdent34, {
  description: undefined,
  extensions: extensions39,
  notNull: false
});
const extensions40 = {
  oid: "1467847",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "not_null_url"
  },
  tags: Object.create(null)
};
const parts35 = ["b", "not_null_url"];
const sqlIdent35 = sql.identifier(...parts35);
const attributes_url_codec_notNullUrl = domainOfCodec(TYPES.varchar, "notNullUrl", sqlIdent35, {
  description: undefined,
  extensions: extensions40,
  notNull: true
});
const attributes45 = Object.assign(Object.create(null), {
  url: {
    description: undefined,
    codec: attributes_url_codec_notNullUrl,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions41 = {
  oid: "1467850",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "wrapped_url"
  },
  tags: Object.create(null)
};
const parts36 = ["b", "wrapped_url"];
const sqlIdent36 = sql.identifier(...parts36);
const spec_wrappedUrl = {
  name: "wrappedUrl",
  identifier: sqlIdent36,
  attributes: attributes45,
  description: undefined,
  extensions: extensions41,
  executor: executor_mainPgExecutor
};
const attributes_site_codec_wrappedUrl = recordCodec(spec_wrappedUrl);
const attributes44 = Object.assign(Object.create(null), {
  id: {
    description: "The primary unique identifier for the person",
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  person_full_name: {
    description: "The person\u2019s name",
    codec: TYPES.varchar,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {
        name: "name"
      }
    }
  },
  aliases: {
    description: undefined,
    codec: registryConfig_pgCodecs_textArray_textArray,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  about: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  email: {
    description: undefined,
    codec: attributes_email_codec_email,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  site: {
    description: undefined,
    codec: attributes_site_codec_wrappedUrl,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {
        deprecated: "Don\u2019t use me"
      }
    }
  },
  config: {
    description: undefined,
    codec: TYPES.hstore,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  last_login_from_ip: {
    description: undefined,
    codec: TYPES.inet,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  last_login_from_subnet: {
    description: undefined,
    codec: TYPES.cidr,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  user_mac: {
    description: undefined,
    codec: TYPES.macaddr,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  created_at: {
    description: undefined,
    codec: TYPES.timestamp,
    notNull: false,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  }
});
const extensions42 = {
  oid: "1467864",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person"
  },
  tags: Object.create(null)
};
const parts37 = ["c", "person"];
const sqlIdent37 = sql.identifier(...parts37);
const spec_person = {
  name: "person",
  identifier: sqlIdent37,
  attributes: attributes44,
  description: "Person test comment",
  extensions: extensions42,
  executor: executor_mainPgExecutor
};
const attributes_person_codec_person = recordCodec(spec_person);
const attributes43 = Object.assign(Object.create(null), {
  person: {
    notNull: false,
    codec: attributes_person_codec_person,
    extensions: {
      argIndex: 0,
      argName: "person"
    }
  },
  o: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 1,
      argName: "o"
    }
  }
});
const registryConfig_pgCodecs_PersonComputedFirstArgInoutOutRecord_PersonComputedFirstArgInoutOutRecord = recordCodec({
  name: "PersonComputedFirstArgInoutOutRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes43,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes46 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_compoundType,
    extensions: {
      argIndex: 3,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_person,
    extensions: {
      argIndex: 4,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_FuncOutComplexRecord_FuncOutComplexRecord = recordCodec({
  name: "FuncOutComplexRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes46,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes47 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_compoundType,
    extensions: {
      argIndex: 3,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_person,
    extensions: {
      argIndex: 4,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_FuncOutComplexSetofRecord_FuncOutComplexSetofRecord = recordCodec({
  name: "FuncOutComplexSetofRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes47,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes48 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_compoundType,
    extensions: {
      argIndex: 3,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_person,
    extensions: {
      argIndex: 4,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_MutationOutComplexRecord_MutationOutComplexRecord = recordCodec({
  name: "MutationOutComplexRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes48,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes49 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 2,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_compoundType,
    extensions: {
      argIndex: 3,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_person,
    extensions: {
      argIndex: 4,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_MutationOutComplexSetofRecord_MutationOutComplexSetofRecord = recordCodec({
  name: "MutationOutComplexSetofRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes49,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const attributes50 = Object.assign(Object.create(null), {
  x: {
    notNull: false,
    codec: TYPES.int,
    extensions: {
      argIndex: 3,
      argName: "x"
    }
  },
  y: {
    notNull: false,
    codec: attributes_o2_codec_compoundType,
    extensions: {
      argIndex: 4,
      argName: "y"
    }
  },
  z: {
    notNull: false,
    codec: attributes_person_codec_person,
    extensions: {
      argIndex: 5,
      argName: "z"
    }
  }
});
const registryConfig_pgCodecs_PersonComputedComplexRecord_PersonComputedComplexRecord = recordCodec({
  name: "PersonComputedComplexRecord",
  identifier: sql`ANONYMOUS_TYPE_DO_NOT_REFERENCE`,
  attributes: attributes50,
  description: undefined,
  extensions: {
    /* `The return type of our \`${name}\` ${
      pgProc.provolatile === "v" ? "mutation" : "query"
    }.`, */
  },
  executor: executor_mainPgExecutor,
  isAnonymous: true
});
const extensions43 = {
  oid: "1467979",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "_color"
  },
  tags: Object.create(null)
};
const attributes_enum_array_codec_colorArray = listOfCodec(attributes_c_codec_color, {
  extensions: extensions43,
  typeDelim: ",",
  description: undefined,
  name: "colorArray"
});
const extensions44 = {
  oid: "1468085",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "an_int"
  },
  tags: Object.create(null)
};
const parts38 = ["a", "an_int"];
const sqlIdent38 = sql.identifier(...parts38);
const attributes_domain_codec_anInt = domainOfCodec(TYPES.int, "anInt", sqlIdent38, {
  description: undefined,
  extensions: extensions44,
  notNull: false
});
const extensions45 = {
  oid: "1468087",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "another_int"
  },
  tags: Object.create(null)
};
const parts39 = ["b", "another_int"];
const sqlIdent39 = sql.identifier(...parts39);
const attributes_domain2_codec_anotherInt = domainOfCodec(attributes_domain_codec_anInt, "anotherInt", sqlIdent39, {
  description: undefined,
  extensions: extensions45,
  notNull: false
});
const extensions46 = {
  oid: "3906",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "numrange"
  },
  tags: Object.create(null)
};
const parts40 = ["pg_catalog", "numrange"];
const sqlIdent40 = sql.identifier(...parts40);
const attributes_nullable_range_codec_numrange = rangeOfCodec(TYPES.numeric, "numrange", sqlIdent40, {
  description: "range of numerics",
  extensions: extensions46
});
const extensions47 = {
  oid: "3912",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "daterange"
  },
  tags: Object.create(null)
};
const parts41 = ["pg_catalog", "daterange"];
const sqlIdent41 = sql.identifier(...parts41);
const attributes_daterange_codec_daterange = rangeOfCodec(TYPES.date, "daterange", sqlIdent41, {
  description: "range of dates",
  extensions: extensions47
});
const extensions48 = {
  oid: "1468091",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "an_int_range"
  },
  tags: Object.create(null)
};
const parts42 = ["a", "an_int_range"];
const sqlIdent42 = sql.identifier(...parts42);
const attributes_an_int_range_codec_anIntRange = rangeOfCodec(attributes_domain_codec_anInt, "anIntRange", sqlIdent42, {
  description: undefined,
  extensions: extensions48
});
const attributes52 = Object.assign(Object.create(null), {
  a: {
    description: undefined,
    codec: attributes_o2_codec_compoundType,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  b: {
    description: undefined,
    codec: attributes_o2_codec_compoundType,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  baz_buz: {
    description: undefined,
    codec: TYPES.int,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions49 = {
  oid: "1468010",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "nested_compound_type"
  },
  tags: Object.create(null)
};
const parts43 = ["b", "nested_compound_type"];
const sqlIdent43 = sql.identifier(...parts43);
const spec_nestedCompoundType = {
  name: "nestedCompoundType",
  identifier: sqlIdent43,
  attributes: attributes52,
  description: undefined,
  extensions: extensions49,
  executor: executor_mainPgExecutor
};
const attributes_nested_compound_type_codec_nestedCompoundType = recordCodec(spec_nestedCompoundType);
const extensions50 = {
  oid: "1468099",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "text_array_domain"
  },
  tags: Object.create(null)
};
const parts44 = ["c", "text_array_domain"];
const sqlIdent44 = sql.identifier(...parts44);
const attributes_text_array_domain_codec_textArrayDomain = domainOfCodec(registryConfig_pgCodecs_textArray_textArray, "textArrayDomain", sqlIdent44, {
  description: undefined,
  extensions: extensions50,
  notNull: false
});
const extensions51 = {
  oid: "1468101",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "int8_array_domain"
  },
  tags: Object.create(null)
};
const extensions52 = {
  oid: "1016",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_int8"
  },
  tags: Object.create(null)
};
const innerCodec_int8Array = listOfCodec(TYPES.bigint, {
  extensions: extensions52,
  typeDelim: ",",
  description: undefined,
  name: "int8Array"
});
const parts45 = ["c", "int8_array_domain"];
const sqlIdent45 = sql.identifier(...parts45);
const attributes_int8_array_domain_codec_int8ArrayDomain = domainOfCodec(innerCodec_int8Array, "int8ArrayDomain", sqlIdent45, {
  description: undefined,
  extensions: extensions51,
  notNull: false
});
const extensions53 = {
  oid: "1001",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_bytea"
  },
  tags: Object.create(null)
};
const attributes_bytea_array_codec_byteaArray = listOfCodec(TYPES.bytea, {
  extensions: extensions53,
  typeDelim: ",",
  description: undefined,
  name: "byteaArray"
});
const attributes_ltree_codec_ltree = {
  name: "ltree",
  sqlType: sql`ltree`,
  toPg(str) {
    return str;
  },
  fromPg(str) {
    return str;
  },
  executor: null,
  attributes: undefined
};
const attributes_ltree_array_codec_ltree_ = listOfCodec(attributes_ltree_codec_ltree);
const attributes51 = Object.assign(Object.create(null), {
  id: {
    description: undefined,
    codec: TYPES.int,
    notNull: true,
    hasDefault: true,
    extensions: {
      tags: {}
    }
  },
  smallint: {
    description: undefined,
    codec: TYPES.int2,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  bigint: {
    description: undefined,
    codec: TYPES.bigint,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  numeric: {
    description: undefined,
    codec: TYPES.numeric,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  decimal: {
    description: undefined,
    codec: TYPES.numeric,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  boolean: {
    description: undefined,
    codec: TYPES.boolean,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  varchar: {
    description: undefined,
    codec: TYPES.varchar,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  enum: {
    description: undefined,
    codec: attributes_c_codec_color,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  enum_array: {
    description: undefined,
    codec: attributes_enum_array_codec_colorArray,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  domain: {
    description: undefined,
    codec: attributes_domain_codec_anInt,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  domain2: {
    description: undefined,
    codec: attributes_domain2_codec_anotherInt,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  text_array: {
    description: undefined,
    codec: registryConfig_pgCodecs_textArray_textArray,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  json: {
    description: undefined,
    codec: TYPES.json,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  jsonb: {
    description: undefined,
    codec: TYPES.jsonb,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullable_range: {
    description: undefined,
    codec: attributes_nullable_range_codec_numrange,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  numrange: {
    description: undefined,
    codec: attributes_nullable_range_codec_numrange,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  daterange: {
    description: undefined,
    codec: attributes_daterange_codec_daterange,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  an_int_range: {
    description: undefined,
    codec: attributes_an_int_range_codec_anIntRange,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  timestamp: {
    description: undefined,
    codec: TYPES.timestamp,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  timestamptz: {
    description: undefined,
    codec: TYPES.timestamptz,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  date: {
    description: undefined,
    codec: TYPES.date,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  time: {
    description: undefined,
    codec: TYPES.time,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  timetz: {
    description: undefined,
    codec: TYPES.timetz,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  interval: {
    description: undefined,
    codec: TYPES.interval,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  interval_array: {
    description: undefined,
    codec: registryConfig_pgCodecs_intervalArray_intervalArray,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  money: {
    description: undefined,
    codec: TYPES.money,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  compound_type: {
    description: undefined,
    codec: attributes_o2_codec_compoundType,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nested_compound_type: {
    description: undefined,
    codec: attributes_nested_compound_type_codec_nestedCompoundType,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullable_compound_type: {
    description: undefined,
    codec: attributes_o2_codec_compoundType,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullable_nested_compound_type: {
    description: undefined,
    codec: attributes_nested_compound_type_codec_nestedCompoundType,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  point: {
    description: undefined,
    codec: TYPES.point,
    notNull: true,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  nullablePoint: {
    description: undefined,
    codec: TYPES.point,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  inet: {
    description: undefined,
    codec: TYPES.inet,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  cidr: {
    description: undefined,
    codec: TYPES.cidr,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  macaddr: {
    description: undefined,
    codec: TYPES.macaddr,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regproc: {
    description: undefined,
    codec: TYPES.regproc,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regprocedure: {
    description: undefined,
    codec: TYPES.regprocedure,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regoper: {
    description: undefined,
    codec: TYPES.regoper,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regoperator: {
    description: undefined,
    codec: TYPES.regoperator,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regclass: {
    description: undefined,
    codec: TYPES.regclass,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regtype: {
    description: undefined,
    codec: TYPES.regtype,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regconfig: {
    description: undefined,
    codec: TYPES.regconfig,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  regdictionary: {
    description: undefined,
    codec: TYPES.regdictionary,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  text_array_domain: {
    description: undefined,
    codec: attributes_text_array_domain_codec_textArrayDomain,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  int8_array_domain: {
    description: undefined,
    codec: attributes_int8_array_domain_codec_int8ArrayDomain,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  bytea: {
    description: undefined,
    codec: TYPES.bytea,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  bytea_array: {
    description: undefined,
    codec: attributes_bytea_array_codec_byteaArray,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  ltree: {
    description: undefined,
    codec: attributes_ltree_codec_ltree,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  ltree_array: {
    description: undefined,
    codec: attributes_ltree_array_codec_ltree_,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions54 = {
  oid: "1468105",
  isTableLike: true,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "types"
  },
  tags: Object.assign(Object.create(null), {
    foreignKey: ["(smallint) references a.post", "(id) references a.post"]
  })
};
const parts46 = ["b", "types"];
const sqlIdent46 = sql.identifier(...parts46);
const spec_types = {
  name: "types",
  identifier: sqlIdent46,
  attributes: attributes51,
  description: undefined,
  extensions: extensions54,
  executor: executor_mainPgExecutor
};
const registryConfig_pgCodecs_types_types = recordCodec(spec_types);
const extensions55 = {
  oid: "1468006",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "_compound_type"
  },
  tags: Object.create(null)
};
const extensions56 = {
  oid: "1468191",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "_jwt_token"
  },
  tags: Object.create(null)
};
const extensions57 = {
  oid: "1468104",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "_types"
  },
  tags: Object.create(null)
};
const extensions58 = {
  oid: "1007",
  pg: {
    serviceName: "main",
    schemaName: "pg_catalog",
    name: "_int4"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_int4Array_int4Array = listOfCodec(TYPES.int, {
  extensions: extensions58,
  typeDelim: ",",
  description: undefined,
  name: "int4Array"
});
const extensions59 = {
  oid: "1468014",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "floatrange"
  },
  tags: Object.create(null)
};
const parts47 = ["c", "floatrange"];
const sqlIdent47 = sql.identifier(...parts47);
const registryConfig_pgCodecs_floatrange_floatrange = rangeOfCodec(TYPES.float, "floatrange", sqlIdent47, {
  description: undefined,
  extensions: extensions59
});
const extensions60 = {
  oid: "1467954",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "_post"
  },
  tags: Object.create(null)
};
const registryConfig_pgCodecs_postArray_postArray = listOfCodec(attributes_post_codec_post, {
  extensions: extensions60,
  typeDelim: ",",
  description: undefined,
  name: "postArray"
});
const attributes53 = Object.assign(Object.create(null), {
  row_name: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_1: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_2: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions61 = {
  oid: "1467395",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "tablefunc_crosstab_2"
  },
  tags: Object.create(null)
};
const parts48 = ["a", "tablefunc_crosstab_2"];
const sqlIdent48 = sql.identifier(...parts48);
const spec_tablefuncCrosstab2 = {
  name: "tablefuncCrosstab2",
  identifier: sqlIdent48,
  attributes: attributes53,
  description: undefined,
  extensions: extensions61,
  executor: executor_mainPgExecutor
};
const attributes54 = Object.assign(Object.create(null), {
  row_name: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_1: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_2: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_3: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions62 = {
  oid: "1467398",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "tablefunc_crosstab_3"
  },
  tags: Object.create(null)
};
const parts49 = ["a", "tablefunc_crosstab_3"];
const sqlIdent49 = sql.identifier(...parts49);
const spec_tablefuncCrosstab3 = {
  name: "tablefuncCrosstab3",
  identifier: sqlIdent49,
  attributes: attributes54,
  description: undefined,
  extensions: extensions62,
  executor: executor_mainPgExecutor
};
const attributes55 = Object.assign(Object.create(null), {
  row_name: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_1: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_2: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_3: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  },
  category_4: {
    description: undefined,
    codec: TYPES.text,
    notNull: false,
    hasDefault: false,
    extensions: {
      tags: {}
    }
  }
});
const extensions63 = {
  oid: "1467401",
  isTableLike: false,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "tablefunc_crosstab_4"
  },
  tags: Object.create(null)
};
const parts50 = ["a", "tablefunc_crosstab_4"];
const sqlIdent50 = sql.identifier(...parts50);
const spec_tablefuncCrosstab4 = {
  name: "tablefuncCrosstab4",
  identifier: sqlIdent50,
  attributes: attributes55,
  description: undefined,
  extensions: extensions63,
  executor: executor_mainPgExecutor
};
const extensions64 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "current_user_id"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts51 = ["c", "current_user_id"];
const sqlIdent51 = sql.identifier(...parts51);
const extensions65 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts52 = ["c", "func_out"];
const sqlIdent52 = sql.identifier(...parts52);
const fromCallback2 = (...args) => sql`${sqlIdent52}(${sqlFromArgDigests(args)})`;
const parameters2 = [];
const extensions66 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_setof"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts53 = ["c", "func_out_setof"];
const sqlIdent53 = sql.identifier(...parts53);
const fromCallback3 = (...args) => sql`${sqlIdent53}(${sqlFromArgDigests(args)})`;
const parameters3 = [];
const extensions67 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_unnamed"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts54 = ["c", "func_out_unnamed"];
const sqlIdent54 = sql.identifier(...parts54);
const fromCallback4 = (...args) => sql`${sqlIdent54}(${sqlFromArgDigests(args)})`;
const parameters4 = [];
const extensions68 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts55 = ["c", "mutation_out"];
const sqlIdent55 = sql.identifier(...parts55);
const fromCallback5 = (...args) => sql`${sqlIdent55}(${sqlFromArgDigests(args)})`;
const parameters5 = [];
const extensions69 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_setof"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts56 = ["c", "mutation_out_setof"];
const sqlIdent56 = sql.identifier(...parts56);
const fromCallback6 = (...args) => sql`${sqlIdent56}(${sqlFromArgDigests(args)})`;
const parameters6 = [];
const extensions70 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_unnamed"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts57 = ["c", "mutation_out_unnamed"];
const sqlIdent57 = sql.identifier(...parts57);
const fromCallback7 = (...args) => sql`${sqlIdent57}(${sqlFromArgDigests(args)})`;
const parameters7 = [];
const extensions71 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "no_args_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts58 = ["c", "no_args_mutation"];
const sqlIdent58 = sql.identifier(...parts58);
const fromCallback8 = (...args) => sql`${sqlIdent58}(${sqlFromArgDigests(args)})`;
const parameters8 = [];
const extensions72 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "no_args_query"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts59 = ["c", "no_args_query"];
const sqlIdent59 = sql.identifier(...parts59);
const fromCallback9 = (...args) => sql`${sqlIdent59}(${sqlFromArgDigests(args)})`;
const parameters9 = [];
const extensions73 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "return_void_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts60 = ["a", "return_void_mutation"];
const sqlIdent60 = sql.identifier(...parts60);
const fromCallback10 = (...args) => sql`${sqlIdent60}(${sqlFromArgDigests(args)})`;
const parameters10 = [];
const extensions74 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "mutation_interval_set"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts61 = ["a", "mutation_interval_set"];
const sqlIdent61 = sql.identifier(...parts61);
const fromCallback11 = (...args) => sql`${sqlIdent61}(${sqlFromArgDigests(args)})`;
const parameters11 = [];
const extensions75 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "query_interval_set"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts62 = ["a", "query_interval_set"];
const sqlIdent62 = sql.identifier(...parts62);
const fromCallback12 = (...args) => sql`${sqlIdent62}(${sqlFromArgDigests(args)})`;
const parameters12 = [];
const extensions76 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "static_big_integer"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts63 = ["a", "static_big_integer"];
const sqlIdent63 = sql.identifier(...parts63);
const fromCallback13 = (...args) => sql`${sqlIdent63}(${sqlFromArgDigests(args)})`;
const parameters13 = [];
const extensions77 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_in_out"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts64 = ["c", "func_in_out"];
const sqlIdent64 = sql.identifier(...parts64);
const fromCallback14 = (...args) => sql`${sqlIdent64}(${sqlFromArgDigests(args)})`;
const parameters14 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions78 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_returns_table_one_col"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "col1"
};
const parts65 = ["c", "func_returns_table_one_col"];
const sqlIdent65 = sql.identifier(...parts65);
const fromCallback15 = (...args) => sql`${sqlIdent65}(${sqlFromArgDigests(args)})`;
const parameters15 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions79 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_in_out"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "o"
};
const parts66 = ["c", "mutation_in_out"];
const sqlIdent66 = sql.identifier(...parts66);
const fromCallback16 = (...args) => sql`${sqlIdent66}(${sqlFromArgDigests(args)})`;
const parameters16 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions80 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_returns_table_one_col"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "col1"
};
const parts67 = ["c", "mutation_returns_table_one_col"];
const sqlIdent67 = sql.identifier(...parts67);
const fromCallback17 = (...args) => sql`${sqlIdent67}(${sqlFromArgDigests(args)})`;
const parameters17 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions81 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "assert_something"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts68 = ["a", "assert_something"];
const sqlIdent68 = sql.identifier(...parts68);
const fromCallback18 = (...args) => sql`${sqlIdent68}(${sqlFromArgDigests(args)})`;
const parameters18 = [{
  name: "in_arg",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions82 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "assert_something_nx"
  },
  tags: {
    omit: "execute",
    behavior: ["queryField -mutationField -typeField", "-filter -order", "-queryField -mutationField -typeField"]
  }
};
const parts69 = ["a", "assert_something_nx"];
const sqlIdent69 = sql.identifier(...parts69);
const fromCallback19 = (...args) => sql`${sqlIdent69}(${sqlFromArgDigests(args)})`;
const parameters19 = [{
  name: "in_arg",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions83 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "json_identity"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts70 = ["c", "json_identity"];
const sqlIdent70 = sql.identifier(...parts70);
const fromCallback20 = (...args) => sql`${sqlIdent70}(${sqlFromArgDigests(args)})`;
const parameters20 = [{
  name: "json",
  required: true,
  notNull: false,
  codec: TYPES.json
}];
const extensions84 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "json_identity_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts71 = ["c", "json_identity_mutation"];
const sqlIdent71 = sql.identifier(...parts71);
const fromCallback21 = (...args) => sql`${sqlIdent71}(${sqlFromArgDigests(args)})`;
const parameters21 = [{
  name: "json",
  required: true,
  notNull: false,
  codec: TYPES.json
}];
const extensions85 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "jsonb_identity"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts72 = ["c", "jsonb_identity"];
const sqlIdent72 = sql.identifier(...parts72);
const fromCallback22 = (...args) => sql`${sqlIdent72}(${sqlFromArgDigests(args)})`;
const parameters22 = [{
  name: "json",
  required: true,
  notNull: false,
  codec: TYPES.jsonb
}];
const extensions86 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "jsonb_identity_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts73 = ["c", "jsonb_identity_mutation"];
const sqlIdent73 = sql.identifier(...parts73);
const fromCallback23 = (...args) => sql`${sqlIdent73}(${sqlFromArgDigests(args)})`;
const parameters23 = [{
  name: "json",
  required: true,
  notNull: false,
  codec: TYPES.jsonb
}];
const extensions87 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "jsonb_identity_mutation_plpgsql"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts74 = ["c", "jsonb_identity_mutation_plpgsql"];
const sqlIdent74 = sql.identifier(...parts74);
const fromCallback24 = (...args) => sql`${sqlIdent74}(${sqlFromArgDigests(args)})`;
const parameters24 = [{
  name: "_the_json",
  required: true,
  notNull: true,
  codec: TYPES.jsonb
}];
const extensions88 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "jsonb_identity_mutation_plpgsql_with_default"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts75 = ["c", "jsonb_identity_mutation_plpgsql_with_default"];
const sqlIdent75 = sql.identifier(...parts75);
const fromCallback25 = (...args) => sql`${sqlIdent75}(${sqlFromArgDigests(args)})`;
const parameters25 = [{
  name: "_the_json",
  required: false,
  notNull: true,
  codec: TYPES.jsonb
}];
const extensions89 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_1_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts76 = ["a", "add_1_mutation"];
const sqlIdent76 = sql.identifier(...parts76);
const fromCallback26 = (...args) => sql`${sqlIdent76}(${sqlFromArgDigests(args)})`;
const parameters26 = [{
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions90 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_1_query"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts77 = ["a", "add_1_query"];
const sqlIdent77 = sql.identifier(...parts77);
const fromCallback27 = (...args) => sql`${sqlIdent77}(${sqlFromArgDigests(args)})`;
const parameters27 = [{
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions91 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_2_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts78 = ["a", "add_2_mutation"];
const sqlIdent78 = sql.identifier(...parts78);
const fromCallback28 = (...args) => sql`${sqlIdent78}(${sqlFromArgDigests(args)})`;
const parameters28 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions92 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_2_query"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts79 = ["a", "add_2_query"];
const sqlIdent79 = sql.identifier(...parts79);
const fromCallback29 = (...args) => sql`${sqlIdent79}(${sqlFromArgDigests(args)})`;
const parameters29 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions93 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_3_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts80 = ["a", "add_3_mutation"];
const sqlIdent80 = sql.identifier(...parts80);
const fromCallback30 = (...args) => sql`${sqlIdent80}(${sqlFromArgDigests(args)})`;
const parameters30 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions94 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_3_query"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts81 = ["a", "add_3_query"];
const sqlIdent81 = sql.identifier(...parts81);
const fromCallback31 = (...args) => sql`${sqlIdent81}(${sqlFromArgDigests(args)})`;
const parameters31 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions95 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_4_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts82 = ["a", "add_4_mutation"];
const sqlIdent82 = sql.identifier(...parts82);
const fromCallback32 = (...args) => sql`${sqlIdent82}(${sqlFromArgDigests(args)})`;
const parameters32 = [{
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: false,
  codec: TYPES.int
}];
const extensions96 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_4_mutation_error"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts83 = ["a", "add_4_mutation_error"];
const sqlIdent83 = sql.identifier(...parts83);
const fromCallback33 = (...args) => sql`${sqlIdent83}(${sqlFromArgDigests(args)})`;
const parameters33 = [{
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: false,
  codec: TYPES.int
}];
const extensions97 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "add_4_query"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts84 = ["a", "add_4_query"];
const sqlIdent84 = sql.identifier(...parts84);
const fromCallback34 = (...args) => sql`${sqlIdent84}(${sqlFromArgDigests(args)})`;
const parameters34 = [{
  name: "",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: false,
  codec: TYPES.int
}];
const extensions98 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "mult_1"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts85 = ["b", "mult_1"];
const sqlIdent85 = sql.identifier(...parts85);
const fromCallback35 = (...args) => sql`${sqlIdent85}(${sqlFromArgDigests(args)})`;
const parameters35 = [{
  name: null,
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions99 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "mult_2"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts86 = ["b", "mult_2"];
const sqlIdent86 = sql.identifier(...parts86);
const fromCallback36 = (...args) => sql`${sqlIdent86}(${sqlFromArgDigests(args)})`;
const parameters36 = [{
  name: null,
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions100 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "mult_3"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts87 = ["b", "mult_3"];
const sqlIdent87 = sql.identifier(...parts87);
const fromCallback37 = (...args) => sql`${sqlIdent87}(${sqlFromArgDigests(args)})`;
const parameters37 = [{
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions101 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "mult_4"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts88 = ["b", "mult_4"];
const sqlIdent88 = sql.identifier(...parts88);
const fromCallback38 = (...args) => sql`${sqlIdent88}(${sqlFromArgDigests(args)})`;
const parameters38 = [{
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: null,
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions102 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_in_inout"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "ino"
};
const parts89 = ["c", "func_in_inout"];
const sqlIdent89 = sql.identifier(...parts89);
const fromCallback39 = (...args) => sql`${sqlIdent89}(${sqlFromArgDigests(args)})`;
const parameters39 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "ino",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions103 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_out"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts90 = ["c", "func_out_out"];
const sqlIdent90 = sql.identifier(...parts90);
const fromCallback40 = (...args) => sql`${sqlIdent90}(${sqlFromArgDigests(args)})`;
const parameters40 = [];
const extensions104 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_out_setof"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts91 = ["c", "func_out_out_setof"];
const sqlIdent91 = sql.identifier(...parts91);
const fromCallback41 = (...args) => sql`${sqlIdent91}(${sqlFromArgDigests(args)})`;
const parameters41 = [];
const extensions105 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_out_unnamed"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts92 = ["c", "func_out_out_unnamed"];
const sqlIdent92 = sql.identifier(...parts92);
const fromCallback42 = (...args) => sql`${sqlIdent92}(${sqlFromArgDigests(args)})`;
const parameters42 = [];
const extensions106 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_in_inout"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  },
  singleOutputParameterName: "ino"
};
const parts93 = ["c", "mutation_in_inout"];
const sqlIdent93 = sql.identifier(...parts93);
const fromCallback43 = (...args) => sql`${sqlIdent93}(${sqlFromArgDigests(args)})`;
const parameters43 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "ino",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions107 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_out"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts94 = ["c", "mutation_out_out"];
const sqlIdent94 = sql.identifier(...parts94);
const fromCallback44 = (...args) => sql`${sqlIdent94}(${sqlFromArgDigests(args)})`;
const parameters44 = [];
const extensions108 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_out_setof"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts95 = ["c", "mutation_out_out_setof"];
const sqlIdent95 = sql.identifier(...parts95);
const fromCallback45 = (...args) => sql`${sqlIdent95}(${sqlFromArgDigests(args)})`;
const parameters45 = [];
const extensions109 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_out_unnamed"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts96 = ["c", "mutation_out_out_unnamed"];
const sqlIdent96 = sql.identifier(...parts96);
const fromCallback46 = (...args) => sql`${sqlIdent96}(${sqlFromArgDigests(args)})`;
const parameters46 = [];
const extensions110 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "search_test_summaries"
  },
  tags: {
    simpleCollections: "only",
    behavior: ["queryField -mutationField -typeField", "-filter -order", "+list -connection"]
  }
};
const parts97 = ["c", "search_test_summaries"];
const sqlIdent97 = sql.identifier(...parts97);
const fromCallback47 = (...args) => sql`${sqlIdent97}(${sqlFromArgDigests(args)})`;
const parameters47 = [];
const extensions111 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_1"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts98 = ["a", "optional_missing_middle_1"];
const sqlIdent98 = sql.identifier(...parts98);
const fromCallback48 = (...args) => sql`${sqlIdent98}(${sqlFromArgDigests(args)})`;
const parameters48 = [{
  name: "",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "c",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions112 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_2"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts99 = ["a", "optional_missing_middle_2"];
const sqlIdent99 = sql.identifier(...parts99);
const fromCallback49 = (...args) => sql`${sqlIdent99}(${sqlFromArgDigests(args)})`;
const parameters49 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "c",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions113 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_3"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts100 = ["a", "optional_missing_middle_3"];
const sqlIdent100 = sql.identifier(...parts100);
const fromCallback50 = (...args) => sql`${sqlIdent100}(${sqlFromArgDigests(args)})`;
const parameters50 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "c",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions114 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_4"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts101 = ["a", "optional_missing_middle_4"];
const sqlIdent101 = sql.identifier(...parts101);
const fromCallback51 = (...args) => sql`${sqlIdent101}(${sqlFromArgDigests(args)})`;
const parameters51 = [{
  name: "",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "b",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions115 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "optional_missing_middle_5"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts102 = ["a", "optional_missing_middle_5"];
const sqlIdent102 = sql.identifier(...parts102);
const fromCallback52 = (...args) => sql`${sqlIdent102}(${sqlFromArgDigests(args)})`;
const parameters52 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.int
}, {
  name: "",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions116 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_unnamed_out_out_unnamed"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts103 = ["c", "func_out_unnamed_out_out_unnamed"];
const sqlIdent103 = sql.identifier(...parts103);
const fromCallback53 = (...args) => sql`${sqlIdent103}(${sqlFromArgDigests(args)})`;
const parameters53 = [];
const extensions117 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_returns_table_multi_col"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts104 = ["c", "func_returns_table_multi_col"];
const sqlIdent104 = sql.identifier(...parts104);
const fromCallback54 = (...args) => sql`${sqlIdent104}(${sqlFromArgDigests(args)})`;
const parameters54 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions118 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "int_set_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts105 = ["c", "int_set_mutation"];
const sqlIdent105 = sql.identifier(...parts105);
const fromCallback55 = (...args) => sql`${sqlIdent105}(${sqlFromArgDigests(args)})`;
const parameters55 = [{
  name: "x",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "y",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "z",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions119 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "int_set_query"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts106 = ["c", "int_set_query"];
const sqlIdent106 = sql.identifier(...parts106);
const fromCallback56 = (...args) => sql`${sqlIdent106}(${sqlFromArgDigests(args)})`;
const parameters56 = [{
  name: "x",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "y",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "z",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions120 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_unnamed_out_out_unnamed"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts107 = ["c", "mutation_out_unnamed_out_out_unnamed"];
const sqlIdent107 = sql.identifier(...parts107);
const fromCallback57 = (...args) => sql`${sqlIdent107}(${sqlFromArgDigests(args)})`;
const parameters57 = [];
const extensions121 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_returns_table_multi_col"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts108 = ["c", "mutation_returns_table_multi_col"];
const sqlIdent108 = sql.identifier(...parts108);
const fromCallback58 = (...args) => sql`${sqlIdent108}(${sqlFromArgDigests(args)})`;
const parameters58 = [{
  name: "i",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions122 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "guid_fn"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts109 = ["b", "guid_fn"];
const sqlIdent109 = sql.identifier(...parts109);
const fromCallback59 = (...args) => sql`${sqlIdent109}(${sqlFromArgDigests(args)})`;
const parameters59 = [{
  name: "g",
  required: true,
  notNull: false,
  codec: registryConfig_pgCodecs_guid_guid
}];
const extensions123 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "mutation_interval_array"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts110 = ["a", "mutation_interval_array"];
const sqlIdent110 = sql.identifier(...parts110);
const fromCallback60 = (...args) => sql`${sqlIdent110}(${sqlFromArgDigests(args)})`;
const parameters60 = [];
const extensions124 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "query_interval_array"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts111 = ["a", "query_interval_array"];
const sqlIdent111 = sql.identifier(...parts111);
const fromCallback61 = (...args) => sql`${sqlIdent111}(${sqlFromArgDigests(args)})`;
const parameters61 = [];
const extensions125 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "mutation_text_array"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts112 = ["a", "mutation_text_array"];
const sqlIdent112 = sql.identifier(...parts112);
const fromCallback62 = (...args) => sql`${sqlIdent112}(${sqlFromArgDigests(args)})`;
const parameters62 = [];
const extensions126 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "query_text_array"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts113 = ["a", "query_text_array"];
const sqlIdent113 = sql.identifier(...parts113);
const fromCallback63 = (...args) => sql`${sqlIdent113}(${sqlFromArgDigests(args)})`;
const parameters63 = [];
const extensions127 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "non_updatable_view"
  },
  tags: {
    behavior: ["-insert", "-update", "-delete"]
  }
};
const extensions128 = {
  description: "Should output as Input",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "inputs"
  },
  tags: {}
};
const uniques2 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions129 = {
  description: "Should output as Patch",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "patchs"
  },
  tags: {}
};
const uniques3 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions130 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reserved"
  },
  tags: {}
};
const uniques4 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions131 = {
  description: "`reservedPatchs` table should get renamed to ReservedPatchRecord to prevent clashes with ReservedPatch from `reserved` table",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reservedPatchs"
  },
  tags: {}
};
const uniques5 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions132 = {
  description: "`reserved_input` table should get renamed to ReservedInputRecord to prevent clashes with ReservedInput from `reserved` table",
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "reserved_input"
  },
  tags: {}
};
const uniques6 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions133 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "default_value"
  },
  tags: {}
};
const uniques7 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions134 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "foreign_key"
  },
  tags: {}
};
const uniques8 = [];
const registryConfig_pgResources_foreign_key_foreign_key = {
  executor: executor_mainPgExecutor,
  name: "foreign_key",
  identifier: "main.a.foreign_key",
  from: registryConfig_pgCodecs_foreignKey_foreignKey.sqlType,
  codec: registryConfig_pgCodecs_foreignKey_foreignKey,
  uniques: uniques8,
  isVirtual: false,
  description: undefined,
  extensions: extensions134
};
const extensions135 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "no_primary_key"
  },
  tags: {}
};
const uniques9 = [{
  isPrimary: false,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions136 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "testview"
  },
  tags: {}
};
const uniques10 = [];
const extensions137 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "unique_foreign_key"
  },
  tags: {
    omit: "create,update,delete,all,order,filter",
    behavior: extensions14.tags.behavior
  }
};
const uniques11 = [{
  isPrimary: false,
  attributes: ["compound_key_1", "compound_key_2"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_unique_foreign_key_unique_foreign_key = {
  executor: executor_mainPgExecutor,
  name: "unique_foreign_key",
  identifier: "main.a.unique_foreign_key",
  from: registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey.sqlType,
  codec: registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey,
  uniques: uniques11,
  isVirtual: false,
  description: undefined,
  extensions: extensions137
};
const extensions138 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "my_table"
  },
  tags: {}
};
const uniques12 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions139 = {
  description: "Tracks the person's secret",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_secret"
  },
  tags: {
    deprecated: "This is deprecated (comment on table c.person_secret)."
  }
};
const uniques13 = [{
  isPrimary: true,
  attributes: ["person_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_person_secret_person_secret = {
  executor: executor_mainPgExecutor,
  name: "person_secret",
  identifier: "main.c.person_secret",
  from: registryConfig_pgCodecs_personSecret_personSecret.sqlType,
  codec: registryConfig_pgCodecs_personSecret_personSecret,
  uniques: uniques13,
  isVirtual: false,
  description: "Tracks the person's secret",
  extensions: extensions139
};
const extensions140 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "view_table"
  },
  tags: {}
};
const uniques14 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions141 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_key"
  },
  tags: {}
};
const uniques15 = [{
  isPrimary: true,
  attributes: ["person_id_1", "person_id_2"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_compound_key_compound_key = {
  executor: executor_mainPgExecutor,
  name: "compound_key",
  identifier: "main.c.compound_key",
  from: registryConfig_pgCodecs_compoundKey_compoundKey.sqlType,
  codec: registryConfig_pgCodecs_compoundKey_compoundKey,
  uniques: uniques15,
  isVirtual: false,
  description: undefined,
  extensions: extensions141
};
const extensions142 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "similar_table_1"
  },
  tags: {}
};
const uniques16 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions143 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "similar_table_2"
  },
  tags: {}
};
const uniques17 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions144 = {
  description: "YOYOYO!!",
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "updatable_view"
  },
  tags: {
    uniqueKey: "x",
    unique: "x|@behavior -single -update -delete"
  }
};
const uniques18 = [{
  isPrimary: false,
  attributes: ["x"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: "-single -update -delete"
    })
  }
}];
const extensions145 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "null_test_record"
  },
  tags: {}
};
const uniques19 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const extensions146 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "edge_case_computed"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts114 = ["c", "edge_case_computed"];
const sqlIdent114 = sql.identifier(...parts114);
const fromCallback64 = (...args) => sql`${sqlIdent114}(${sqlFromArgDigests(args)})`;
const parameters64 = [{
  name: "edge_case",
  required: true,
  notNull: false,
  codec: registryConfig_pgCodecs_edgeCase_edgeCase
}];
const parts115 = ["c", "return_table_without_grants"];
const sqlIdent115 = sql.identifier(...parts115);
const options_return_table_without_grants = {
  name: "return_table_without_grants",
  identifier: "main.c.return_table_without_grants()",
  from(...args) {
    return sql`${sqlIdent115}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "return_table_without_grants"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const extensions147 = {
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "list_bde_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts116 = ["b", "list_bde_mutation"];
const sqlIdent116 = sql.identifier(...parts116);
const fromCallback65 = (...args) => sql`${sqlIdent116}(${sqlFromArgDigests(args)})`;
const parameters65 = [{
  name: "b",
  required: true,
  notNull: false,
  codec: registryConfig_pgCodecs_textArray_textArray
}, {
  name: "d",
  required: true,
  notNull: false,
  codec: TYPES.text
}, {
  name: "e",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions148 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "edge_case"
  },
  tags: {}
};
const uniques20 = [];
const extensions149 = {
  description: "Tracks metadata about the left arms of various people",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "left_arm"
  },
  tags: {}
};
const uniques21 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["person_id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_left_arm_left_arm = {
  executor: executor_mainPgExecutor,
  name: "left_arm",
  identifier: "main.c.left_arm",
  from: registryConfig_pgCodecs_leftArm_leftArm.sqlType,
  codec: registryConfig_pgCodecs_leftArm_leftArm,
  uniques: uniques21,
  isVirtual: false,
  description: "Tracks metadata about the left arms of various people",
  extensions: extensions149
};
const parts117 = ["b", "authenticate_fail"];
const sqlIdent117 = sql.identifier(...parts117);
const options_authenticate_fail = {
  name: "authenticate_fail",
  identifier: "main.b.authenticate_fail()",
  from(...args) {
    return sql`${sqlIdent117}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "authenticate_fail"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const extensions150 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "jwt_token"
  },
  tags: {
    behavior: ["-insert", "-update", "-delete"]
  }
};
const uniques22 = [];
const resourceConfig_jwt_token = {
  executor: executor_mainPgExecutor,
  name: "jwt_token",
  identifier: "main.b.jwt_token",
  from: registryConfig_pgCodecs_jwtToken_jwtToken.sqlType,
  codec: registryConfig_pgCodecs_jwtToken_jwtToken,
  uniques: uniques22,
  isVirtual: true,
  description: undefined,
  extensions: extensions150
};
const parts118 = ["b", "authenticate"];
const sqlIdent118 = sql.identifier(...parts118);
const options_authenticate = {
  name: "authenticate",
  identifier: "main.b.authenticate(int4,numeric,int8)",
  from(...args) {
    return sql`${sqlIdent118}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "a",
    required: true,
    notNull: false,
    codec: TYPES.int
  }, {
    name: "b",
    required: true,
    notNull: false,
    codec: TYPES.numeric
  }, {
    name: "c",
    required: true,
    notNull: false,
    codec: TYPES.bigint
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "authenticate"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const extensions151 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "issue756"
  },
  tags: {}
};
const uniques23 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_issue756_issue756 = {
  executor: executor_mainPgExecutor,
  name: "issue756",
  identifier: "main.c.issue756",
  from: registryConfig_pgCodecs_issue756_issue756.sqlType,
  codec: registryConfig_pgCodecs_issue756_issue756,
  uniques: uniques23,
  isVirtual: false,
  description: undefined,
  extensions: extensions151
};
const parts119 = ["c", "left_arm_identity"];
const sqlIdent119 = sql.identifier(...parts119);
const options_left_arm_identity = {
  name: "left_arm_identity",
  identifier: "main.c.left_arm_identity(c.left_arm)",
  from(...args) {
    return sql`${sqlIdent119}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "left_arm",
    required: true,
    notNull: false,
    codec: registryConfig_pgCodecs_leftArm_leftArm,
    extensions: {
      variant: "base"
    }
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "left_arm_identity"
    },
    tags: {
      arg0variant: "base",
      resultFieldName: "leftArm",
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts120 = ["c", "issue756_mutation"];
const sqlIdent120 = sql.identifier(...parts120);
const options_issue756_mutation = {
  name: "issue756_mutation",
  identifier: "main.c.issue756_mutation()",
  from(...args) {
    return sql`${sqlIdent120}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "issue756_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts121 = ["c", "issue756_set_mutation"];
const sqlIdent121 = sql.identifier(...parts121);
const options_issue756_set_mutation = {
  name: "issue756_set_mutation",
  identifier: "main.c.issue756_set_mutation()",
  from(...args) {
    return sql`${sqlIdent121}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "issue756_set_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts122 = ["b", "authenticate_many"];
const sqlIdent122 = sql.identifier(...parts122);
const options_authenticate_many = {
  name: "authenticate_many",
  identifier: "main.b.authenticate_many(int4,numeric,int8)",
  from(...args) {
    return sql`${sqlIdent122}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "a",
    required: true,
    notNull: false,
    codec: TYPES.int
  }, {
    name: "b",
    required: true,
    notNull: false,
    codec: TYPES.numeric
  }, {
    name: "c",
    required: true,
    notNull: false,
    codec: TYPES.bigint
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "authenticate_many"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts123 = ["b", "authenticate_payload"];
const sqlIdent123 = sql.identifier(...parts123);
const options_authenticate_payload = {
  name: "authenticate_payload",
  identifier: "main.b.authenticate_payload(int4,numeric,int8)",
  from(...args) {
    return sql`${sqlIdent123}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "a",
    required: true,
    notNull: false,
    codec: TYPES.int
  }, {
    name: "b",
    required: true,
    notNull: false,
    codec: TYPES.numeric
  }, {
    name: "c",
    required: true,
    notNull: false,
    codec: TYPES.bigint
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "authenticate_payload"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const extensions152 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "auth_payload"
  },
  tags: {
    foreignKey: "(id) references c.person",
    behavior: ["-insert", "-update", "-delete"]
  }
};
const uniques24 = [];
const resourceConfig_auth_payload = {
  executor: executor_mainPgExecutor,
  name: "auth_payload",
  identifier: "main.b.auth_payload",
  from: registryConfig_pgCodecs_authPayload_authPayload.sqlType,
  codec: registryConfig_pgCodecs_authPayload_authPayload,
  uniques: uniques24,
  isVirtual: true,
  description: undefined,
  extensions: extensions152
};
const extensions153 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "types_mutation"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts124 = ["c", "types_mutation"];
const sqlIdent124 = sql.identifier(...parts124);
const fromCallback66 = (...args) => sql`${sqlIdent124}(${sqlFromArgDigests(args)})`;
const parameters66 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.bigint
}, {
  name: "b",
  required: true,
  notNull: true,
  codec: TYPES.boolean
}, {
  name: "c",
  required: true,
  notNull: true,
  codec: TYPES.varchar
}, {
  name: "d",
  required: true,
  notNull: true,
  codec: registryConfig_pgCodecs_int4Array_int4Array
}, {
  name: "e",
  required: true,
  notNull: true,
  codec: TYPES.json
}, {
  name: "f",
  required: true,
  notNull: true,
  codec: registryConfig_pgCodecs_floatrange_floatrange
}];
const extensions154 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "types_query"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts125 = ["c", "types_query"];
const sqlIdent125 = sql.identifier(...parts125);
const fromCallback67 = (...args) => sql`${sqlIdent125}(${sqlFromArgDigests(args)})`;
const parameters67 = [{
  name: "a",
  required: true,
  notNull: true,
  codec: TYPES.bigint
}, {
  name: "b",
  required: true,
  notNull: true,
  codec: TYPES.boolean
}, {
  name: "c",
  required: true,
  notNull: true,
  codec: TYPES.varchar
}, {
  name: "d",
  required: true,
  notNull: true,
  codec: registryConfig_pgCodecs_int4Array_int4Array
}, {
  name: "e",
  required: true,
  notNull: true,
  codec: TYPES.json
}, {
  name: "f",
  required: true,
  notNull: true,
  codec: registryConfig_pgCodecs_floatrange_floatrange
}];
const extensions155 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_type_computed_field"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts126 = ["c", "compound_type_computed_field"];
const sqlIdent126 = sql.identifier(...parts126);
const fromCallback68 = (...args) => sql`${sqlIdent126}(${sqlFromArgDigests(args)})`;
const parameters68 = [{
  name: "compound_type",
  required: true,
  notNull: false,
  codec: attributes_o2_codec_compoundType
}];
const extensions156 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_interval_set"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts127 = ["a", "post_computed_interval_set"];
const sqlIdent127 = sql.identifier(...parts127);
const fromCallback69 = (...args) => sql`${sqlIdent127}(${sqlFromArgDigests(args)})`;
const parameters69 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}];
const extensions157 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_interval_array"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts128 = ["a", "post_computed_interval_array"];
const sqlIdent128 = sql.identifier(...parts128);
const fromCallback70 = (...args) => sql`${sqlIdent128}(${sqlFromArgDigests(args)})`;
const parameters70 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}];
const extensions158 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_text_array"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts129 = ["a", "post_computed_text_array"];
const sqlIdent129 = sql.identifier(...parts129);
const fromCallback71 = (...args) => sql`${sqlIdent129}(${sqlFromArgDigests(args)})`;
const parameters71 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}];
const extensions159 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_with_optional_arg"
  },
  tags: {
    sortable: true,
    filterable: true,
    behavior: ["-queryField -mutationField typeField", "-filter -order", "filter filterBy", "orderBy order"]
  }
};
const parts130 = ["a", "post_computed_with_optional_arg"];
const sqlIdent130 = sql.identifier(...parts130);
const fromCallback72 = (...args) => sql`${sqlIdent130}(${sqlFromArgDigests(args)})`;
const parameters72 = [{
  name: "post",
  required: true,
  notNull: true,
  codec: attributes_post_codec_post
}, {
  name: "i",
  required: false,
  notNull: true,
  codec: TYPES.int
}];
const extensions160 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_computed_with_required_arg"
  },
  tags: {
    sortable: true,
    filterable: true,
    behavior: ["-queryField -mutationField typeField", "-filter -order", "filter filterBy", "orderBy order"]
  }
};
const parts131 = ["a", "post_computed_with_required_arg"];
const sqlIdent131 = sql.identifier(...parts131);
const fromCallback73 = (...args) => sql`${sqlIdent131}(${sqlFromArgDigests(args)})`;
const parameters73 = [{
  name: "post",
  required: true,
  notNull: true,
  codec: attributes_post_codec_post
}, {
  name: "i",
  required: true,
  notNull: true,
  codec: TYPES.int
}];
const extensions161 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_out_compound_type"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts132 = ["c", "func_out_out_compound_type"];
const sqlIdent132 = sql.identifier(...parts132);
const fromCallback74 = (...args) => sql`${sqlIdent132}(${sqlFromArgDigests(args)})`;
const parameters74 = [{
  name: "i1",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions162 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_out_compound_type"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts133 = ["c", "mutation_out_out_compound_type"];
const sqlIdent133 = sql.identifier(...parts133);
const fromCallback75 = (...args) => sql`${sqlIdent133}(${sqlFromArgDigests(args)})`;
const parameters75 = [{
  name: "i1",
  required: true,
  notNull: false,
  codec: TYPES.int
}];
const extensions163 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_headline_trimmed"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts134 = ["a", "post_headline_trimmed"];
const sqlIdent134 = sql.identifier(...parts134);
const fromCallback76 = (...args) => sql`${sqlIdent134}(${sqlFromArgDigests(args)})`;
const parameters76 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}, {
  name: "length",
  required: false,
  notNull: false,
  codec: TYPES.int
}, {
  name: "omission",
  required: false,
  notNull: false,
  codec: TYPES.text
}];
const extensions164 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_headline_trimmed_no_defaults"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts135 = ["a", "post_headline_trimmed_no_defaults"];
const sqlIdent135 = sql.identifier(...parts135);
const fromCallback77 = (...args) => sql`${sqlIdent135}(${sqlFromArgDigests(args)})`;
const parameters77 = [{
  name: "post",
  required: true,
  notNull: false,
  codec: attributes_post_codec_post
}, {
  name: "length",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "omission",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions165 = {
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post_headline_trimmed_strict"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts136 = ["a", "post_headline_trimmed_strict"];
const sqlIdent136 = sql.identifier(...parts136);
const fromCallback78 = (...args) => sql`${sqlIdent136}(${sqlFromArgDigests(args)})`;
const parameters78 = [{
  name: "post",
  required: true,
  notNull: true,
  codec: attributes_post_codec_post
}, {
  name: "length",
  required: false,
  notNull: true,
  codec: TYPES.int
}, {
  name: "omission",
  required: false,
  notNull: true,
  codec: TYPES.text
}];
const extensions166 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "query_output_two_rows"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts137 = ["c", "query_output_two_rows"];
const sqlIdent137 = sql.identifier(...parts137);
const fromCallback79 = (...args) => sql`${sqlIdent137}(${sqlFromArgDigests(args)})`;
const parameters79 = [{
  name: "left_arm_id",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "post_id",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "txt",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions167 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "a",
    name: "post"
  },
  tags: {}
};
const uniques25 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_post_post = {
  executor: executor_mainPgExecutor,
  name: "post",
  identifier: "main.a.post",
  from: attributes_post_codec_post.sqlType,
  codec: attributes_post_codec_post,
  uniques: uniques25,
  isVirtual: false,
  description: undefined,
  extensions: extensions167
};
const parts138 = ["c", "compound_type_set_query"];
const sqlIdent138 = sql.identifier(...parts138);
const options_compound_type_set_query = {
  name: "compound_type_set_query",
  identifier: "main.c.compound_type_set_query()",
  from(...args) {
    return sql`${sqlIdent138}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "compound_type_set_query"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const extensions168 = {
  description: "Awesome feature!",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "compound_type"
  },
  tags: {
    behavior: ["-insert", "-update", "-delete"]
  }
};
const uniques26 = [];
const resourceConfig_compound_type = {
  executor: executor_mainPgExecutor,
  name: "compound_type",
  identifier: "main.c.compound_type",
  from: attributes_o2_codec_compoundType.sqlType,
  codec: attributes_o2_codec_compoundType,
  uniques: uniques26,
  isVirtual: true,
  description: "Awesome feature!",
  extensions: extensions168
};
const parts139 = ["b", "compound_type_mutation"];
const sqlIdent139 = sql.identifier(...parts139);
const options_compound_type_mutation = {
  name: "compound_type_mutation",
  identifier: "main.b.compound_type_mutation(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent139}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_compoundType
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts140 = ["b", "compound_type_query"];
const sqlIdent140 = sql.identifier(...parts140);
const options_compound_type_query = {
  name: "compound_type_query",
  identifier: "main.b.compound_type_query(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent140}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_compoundType
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_query"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts141 = ["b", "compound_type_set_mutation"];
const sqlIdent141 = sql.identifier(...parts141);
const options_compound_type_set_mutation = {
  name: "compound_type_set_mutation",
  identifier: "main.b.compound_type_set_mutation(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent141}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_compoundType
  }],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_set_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts142 = ["c", "table_mutation"];
const sqlIdent142 = sql.identifier(...parts142);
const options_table_mutation = {
  name: "table_mutation",
  identifier: "main.c.table_mutation(int4)",
  from(...args) {
    return sql`${sqlIdent142}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts143 = ["c", "table_query"];
const sqlIdent143 = sql.identifier(...parts143);
const options_table_query = {
  name: "table_query",
  identifier: "main.c.table_query(int4)",
  from(...args) {
    return sql`${sqlIdent143}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_query"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts144 = ["a", "post_with_suffix"];
const sqlIdent144 = sql.identifier(...parts144);
const options_post_with_suffix = {
  name: "post_with_suffix",
  identifier: "main.a.post_with_suffix(a.post,text)",
  from(...args) {
    return sql`${sqlIdent144}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "post",
    required: true,
    notNull: false,
    codec: attributes_post_codec_post
  }, {
    name: "suffix",
    required: true,
    notNull: false,
    codec: TYPES.text
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "post_with_suffix"
    },
    tags: {
      deprecated: "This is deprecated (comment on function a.post_with_suffix).",
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts145 = ["a", "mutation_compound_type_array"];
const sqlIdent145 = sql.identifier(...parts145);
const options_mutation_compound_type_array = {
  name: "mutation_compound_type_array",
  identifier: "main.a.mutation_compound_type_array(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent145}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_compoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "mutation_compound_type_array"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts146 = ["a", "query_compound_type_array"];
const sqlIdent146 = sql.identifier(...parts146);
const options_query_compound_type_array = {
  name: "query_compound_type_array",
  identifier: "main.a.query_compound_type_array(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent146}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_compoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "query_compound_type_array"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts147 = ["b", "compound_type_array_mutation"];
const sqlIdent147 = sql.identifier(...parts147);
const options_compound_type_array_mutation = {
  name: "compound_type_array_mutation",
  identifier: "main.b.compound_type_array_mutation(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent147}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_compoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_array_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts148 = ["b", "compound_type_array_query"];
const sqlIdent148 = sql.identifier(...parts148);
const options_compound_type_array_query = {
  name: "compound_type_array_query",
  identifier: "main.b.compound_type_array_query(c.compound_type)",
  from(...args) {
    return sql`${sqlIdent148}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_compoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "compound_type_array_query"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts149 = ["a", "post_computed_compound_type_array"];
const sqlIdent149 = sql.identifier(...parts149);
const options_post_computed_compound_type_array = {
  name: "post_computed_compound_type_array",
  identifier: "main.a.post_computed_compound_type_array(a.post,c.compound_type)",
  from(...args) {
    return sql`${sqlIdent149}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "post",
    required: true,
    notNull: false,
    codec: attributes_post_codec_post
  }, {
    name: "object",
    required: true,
    notNull: false,
    codec: attributes_o2_codec_compoundType
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "post_computed_compound_type_array"
    },
    tags: {
      behavior: ["-queryField -mutationField typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts150 = ["a", "post_many"];
const sqlIdent150 = sql.identifier(...parts150);
const options_post_many = {
  name: "post_many",
  identifier: "main.a.post_many(a._post)",
  from(...args) {
    return sql`${sqlIdent150}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "posts",
    required: true,
    notNull: false,
    codec: registryConfig_pgCodecs_postArray_postArray
  }],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "a",
      name: "post_many"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const extensions169 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_out"
  },
  tags: {
    notNull: true,
    sortable: true,
    filterable: true,
    behavior: ["-queryField -mutationField typeField", "-filter -order", "filter filterBy", "orderBy order"]
  },
  singleOutputParameterName: "o1"
};
const parts151 = ["c", "person_computed_out"];
const sqlIdent151 = sql.identifier(...parts151);
const fromCallback80 = (...args) => sql`${sqlIdent151}(${sqlFromArgDigests(args)})`;
const parameters80 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_person
}];
const extensions170 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_first_name"
  },
  tags: {
    sortable: true,
    behavior: ["-queryField -mutationField typeField", "-filter -order", "orderBy order"]
  }
};
const parts152 = ["c", "person_first_name"];
const sqlIdent152 = sql.identifier(...parts152);
const fromCallback81 = (...args) => sql`${sqlIdent152}(${sqlFromArgDigests(args)})`;
const parameters81 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_person
}];
const extensions171 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_out_out"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts153 = ["c", "person_computed_out_out"];
const sqlIdent153 = sql.identifier(...parts153);
const fromCallback82 = (...args) => sql`${sqlIdent153}(${sqlFromArgDigests(args)})`;
const parameters82 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_person
}];
const extensions172 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_inout"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  },
  singleOutputParameterName: "ino"
};
const parts154 = ["c", "person_computed_inout"];
const sqlIdent154 = sql.identifier(...parts154);
const fromCallback83 = (...args) => sql`${sqlIdent154}(${sqlFromArgDigests(args)})`;
const parameters83 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_person
}, {
  name: "ino",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions173 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_inout_out"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts155 = ["c", "person_computed_inout_out"];
const sqlIdent155 = sql.identifier(...parts155);
const fromCallback84 = (...args) => sql`${sqlIdent155}(${sqlFromArgDigests(args)})`;
const parameters84 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_person
}, {
  name: "ino",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions174 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_exists"
  },
  tags: {
    deprecated: "This is deprecated (comment on function c.person_exists).",
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts156 = ["c", "person_exists"];
const sqlIdent156 = sql.identifier(...parts156);
const fromCallback85 = (...args) => sql`${sqlIdent156}(${sqlFromArgDigests(args)})`;
const parameters85 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_person
}, {
  name: "email",
  required: true,
  notNull: false,
  codec: attributes_email_codec_email
}];
const extensions175 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_first_arg_inout_out"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts157 = ["c", "person_computed_first_arg_inout_out"];
const sqlIdent157 = sql.identifier(...parts157);
const fromCallback86 = (...args) => sql`${sqlIdent157}(${sqlFromArgDigests(args)})`;
const parameters86 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_person
}];
const extensions176 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_complex"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts158 = ["c", "func_out_complex"];
const sqlIdent158 = sql.identifier(...parts158);
const fromCallback87 = (...args) => sql`${sqlIdent158}(${sqlFromArgDigests(args)})`;
const parameters87 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions177 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "func_out_complex_setof"
  },
  tags: {
    behavior: ["queryField -mutationField -typeField", "-filter -order"]
  }
};
const parts159 = ["c", "func_out_complex_setof"];
const sqlIdent159 = sql.identifier(...parts159);
const fromCallback88 = (...args) => sql`${sqlIdent159}(${sqlFromArgDigests(args)})`;
const parameters88 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions178 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_complex"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts160 = ["c", "mutation_out_complex"];
const sqlIdent160 = sql.identifier(...parts160);
const fromCallback89 = (...args) => sql`${sqlIdent160}(${sqlFromArgDigests(args)})`;
const parameters89 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions179 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "mutation_out_complex_setof"
  },
  tags: {
    behavior: ["-queryField mutationField -typeField", "-filter -order"]
  }
};
const parts161 = ["c", "mutation_out_complex_setof"];
const sqlIdent161 = sql.identifier(...parts161);
const fromCallback90 = (...args) => sql`${sqlIdent161}(${sqlFromArgDigests(args)})`;
const parameters90 = [{
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const extensions180 = {
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person_computed_complex"
  },
  tags: {
    behavior: ["-queryField -mutationField typeField", "-filter -order"]
  }
};
const parts162 = ["c", "person_computed_complex"];
const sqlIdent162 = sql.identifier(...parts162);
const fromCallback91 = (...args) => sql`${sqlIdent162}(${sqlFromArgDigests(args)})`;
const parameters91 = [{
  name: "person",
  required: true,
  notNull: false,
  codec: attributes_person_codec_person
}, {
  name: "a",
  required: true,
  notNull: false,
  codec: TYPES.int
}, {
  name: "b",
  required: true,
  notNull: false,
  codec: TYPES.text
}];
const parts163 = ["c", "person_first_post"];
const sqlIdent163 = sql.identifier(...parts163);
const options_person_first_post = {
  name: "person_first_post",
  identifier: "main.c.person_first_post(c.person)",
  from(...args) {
    return sql`${sqlIdent163}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "person",
    required: true,
    notNull: false,
    codec: attributes_person_codec_person
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_first_post"
    },
    tags: {
      behavior: ["-queryField -mutationField typeField", "-filter -order"]
    }
  },
  description: "The first post by the person."
};
const extensions181 = {
  description: "Person test comment",
  pg: {
    serviceName: "main",
    schemaName: "c",
    name: "person"
  },
  tags: {}
};
const uniques27 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["email"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_person_person = {
  executor: executor_mainPgExecutor,
  name: "person",
  identifier: "main.c.person",
  from: attributes_person_codec_person.sqlType,
  codec: attributes_person_codec_person,
  uniques: uniques27,
  isVirtual: false,
  description: "Person test comment",
  extensions: extensions181
};
const parts164 = ["c", "badly_behaved_function"];
const sqlIdent164 = sql.identifier(...parts164);
const options_badly_behaved_function = {
  name: "badly_behaved_function",
  identifier: "main.c.badly_behaved_function()",
  from(...args) {
    return sql`${sqlIdent164}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "badly_behaved_function"
    },
    tags: {
      deprecated: "This is deprecated (comment on function c.badly_behaved_function).",
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts165 = ["c", "func_out_table"];
const sqlIdent165 = sql.identifier(...parts165);
const options_func_out_table = {
  name: "func_out_table",
  identifier: "main.c.func_out_table(c.person)",
  from(...args) {
    return sql`${sqlIdent165}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "func_out_table"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts166 = ["c", "func_out_table_setof"];
const sqlIdent166 = sql.identifier(...parts166);
const options_func_out_table_setof = {
  name: "func_out_table_setof",
  identifier: "main.c.func_out_table_setof(c.person)",
  from(...args) {
    return sql`${sqlIdent166}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "func_out_table_setof"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts167 = ["c", "mutation_out_table"];
const sqlIdent167 = sql.identifier(...parts167);
const options_mutation_out_table = {
  name: "mutation_out_table",
  identifier: "main.c.mutation_out_table(c.person)",
  from(...args) {
    return sql`${sqlIdent167}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "mutation_out_table"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts168 = ["c", "mutation_out_table_setof"];
const sqlIdent168 = sql.identifier(...parts168);
const options_mutation_out_table_setof = {
  name: "mutation_out_table_setof",
  identifier: "main.c.mutation_out_table_setof(c.person)",
  from(...args) {
    return sql`${sqlIdent168}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "mutation_out_table_setof"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts169 = ["c", "table_set_mutation"];
const sqlIdent169 = sql.identifier(...parts169);
const options_table_set_mutation = {
  name: "table_set_mutation",
  identifier: "main.c.table_set_mutation()",
  from(...args) {
    return sql`${sqlIdent169}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_set_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts170 = ["c", "table_set_query"];
const sqlIdent170 = sql.identifier(...parts170);
const options_table_set_query = {
  name: "table_set_query",
  identifier: "main.c.table_set_query()",
  from(...args) {
    return sql`${sqlIdent170}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_set_query"
    },
    tags: {
      sortable: true,
      filterable: true,
      behavior: ["queryField -mutationField -typeField", "-filter -order", "filter filterBy", "orderBy order"]
    }
  },
  description: undefined
};
const parts171 = ["c", "table_set_query_plpgsql"];
const sqlIdent171 = sql.identifier(...parts171);
const options_table_set_query_plpgsql = {
  name: "table_set_query_plpgsql",
  identifier: "main.c.table_set_query_plpgsql()",
  from(...args) {
    return sql`${sqlIdent171}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "table_set_query_plpgsql"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts172 = ["c", "person_computed_first_arg_inout"];
const sqlIdent172 = sql.identifier(...parts172);
const options_person_computed_first_arg_inout = {
  name: "person_computed_first_arg_inout",
  identifier: "main.c.person_computed_first_arg_inout(c.person)",
  from(...args) {
    return sql`${sqlIdent172}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "person",
    required: true,
    notNull: false,
    codec: attributes_person_codec_person
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_computed_first_arg_inout"
    },
    tags: {
      behavior: ["-queryField -mutationField typeField", "-filter -order"]
    },
    singleOutputParameterName: "person"
  },
  description: undefined
};
const parts173 = ["c", "person_friends"];
const sqlIdent173 = sql.identifier(...parts173);
const options_person_friends = {
  name: "person_friends",
  identifier: "main.c.person_friends(c.person)",
  from(...args) {
    return sql`${sqlIdent173}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "person",
    required: true,
    notNull: false,
    codec: attributes_person_codec_person
  }],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_friends"
    },
    tags: {
      sortable: true,
      behavior: ["-queryField -mutationField typeField", "-filter -order", "orderBy order"]
    }
  },
  description: undefined
};
const extensions182 = {
  description: undefined,
  pg: {
    serviceName: "main",
    schemaName: "b",
    name: "types"
  },
  tags: {
    foreignKey: extensions54.tags.foreignKey
  }
};
const uniques28 = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_types_types = {
  executor: executor_mainPgExecutor,
  name: "types",
  identifier: "main.b.types",
  from: registryConfig_pgCodecs_types_types.sqlType,
  codec: registryConfig_pgCodecs_types_types,
  uniques: uniques28,
  isVirtual: false,
  description: undefined,
  extensions: extensions182
};
const parts174 = ["b", "type_function_connection"];
const sqlIdent174 = sql.identifier(...parts174);
const options_type_function_connection = {
  name: "type_function_connection",
  identifier: "main.b.type_function_connection()",
  from(...args) {
    return sql`${sqlIdent174}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_connection"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts175 = ["b", "type_function_connection_mutation"];
const sqlIdent175 = sql.identifier(...parts175);
const options_type_function_connection_mutation = {
  name: "type_function_connection_mutation",
  identifier: "main.b.type_function_connection_mutation()",
  from(...args) {
    return sql`${sqlIdent175}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: false,
  returnsSetof: true,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_connection_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts176 = ["b", "type_function"];
const sqlIdent176 = sql.identifier(...parts176);
const options_type_function = {
  name: "type_function",
  identifier: "main.b.type_function(int4)",
  from(...args) {
    return sql`${sqlIdent176}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts177 = ["b", "type_function_mutation"];
const sqlIdent177 = sql.identifier(...parts177);
const options_type_function_mutation = {
  name: "type_function_mutation",
  identifier: "main.b.type_function_mutation(int4)",
  from(...args) {
    return sql`${sqlIdent177}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts178 = ["c", "person_type_function_connection"];
const sqlIdent178 = sql.identifier(...parts178);
const options_person_type_function_connection = {
  name: "person_type_function_connection",
  identifier: "main.c.person_type_function_connection(c.person)",
  from(...args) {
    return sql`${sqlIdent178}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "p",
    required: true,
    notNull: false,
    codec: attributes_person_codec_person
  }],
  returnsArray: false,
  returnsSetof: true,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_type_function_connection"
    },
    tags: {
      behavior: ["-queryField -mutationField typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts179 = ["c", "person_type_function"];
const sqlIdent179 = sql.identifier(...parts179);
const options_person_type_function = {
  name: "person_type_function",
  identifier: "main.c.person_type_function(c.person,int4)",
  from(...args) {
    return sql`${sqlIdent179}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "p",
    required: true,
    notNull: false,
    codec: attributes_person_codec_person
  }, {
    name: "id",
    required: true,
    notNull: false,
    codec: TYPES.int
  }],
  returnsArray: false,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_type_function"
    },
    tags: {
      behavior: ["-queryField -mutationField typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts180 = ["b", "type_function_list"];
const sqlIdent180 = sql.identifier(...parts180);
const options_type_function_list = {
  name: "type_function_list",
  identifier: "main.b.type_function_list()",
  from(...args) {
    return sql`${sqlIdent180}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_list"
    },
    tags: {
      behavior: ["queryField -mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts181 = ["b", "type_function_list_mutation"];
const sqlIdent181 = sql.identifier(...parts181);
const options_type_function_list_mutation = {
  name: "type_function_list_mutation",
  identifier: "main.b.type_function_list_mutation()",
  from(...args) {
    return sql`${sqlIdent181}(${sqlFromArgDigests(args)})`;
  },
  parameters: [],
  returnsArray: true,
  returnsSetof: false,
  isMutation: true,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "b",
      name: "type_function_list_mutation"
    },
    tags: {
      behavior: ["-queryField mutationField -typeField", "-filter -order"]
    }
  },
  description: undefined
};
const parts182 = ["c", "person_type_function_list"];
const sqlIdent182 = sql.identifier(...parts182);
const options_person_type_function_list = {
  name: "person_type_function_list",
  identifier: "main.c.person_type_function_list(c.person)",
  from(...args) {
    return sql`${sqlIdent182}(${sqlFromArgDigests(args)})`;
  },
  parameters: [{
    name: "p",
    required: true,
    notNull: false,
    codec: attributes_person_codec_person
  }],
  returnsArray: true,
  returnsSetof: false,
  isMutation: false,
  extensions: {
    pg: {
      serviceName: "main",
      schemaName: "c",
      name: "person_type_function_list"
    },
    tags: {
      behavior: ["-queryField -mutationField typeField", "-filter -order"]
    }
  },
  description: undefined
};
const registry = makeRegistry({
  pgCodecs: Object.assign(Object.create(null), {
    int4: TYPES.int,
    void: TYPES.void,
    interval: TYPES.interval,
    int8: TYPES.bigint,
    json: TYPES.json,
    jsonb: TYPES.jsonb,
    FuncOutOutRecord: registryConfig_pgCodecs_FuncOutOutRecord_FuncOutOutRecord,
    text: TYPES.text,
    FuncOutOutSetofRecord: registryConfig_pgCodecs_FuncOutOutSetofRecord_FuncOutOutSetofRecord,
    FuncOutOutUnnamedRecord: registryConfig_pgCodecs_FuncOutOutUnnamedRecord_FuncOutOutUnnamedRecord,
    MutationOutOutRecord: registryConfig_pgCodecs_MutationOutOutRecord_MutationOutOutRecord,
    MutationOutOutSetofRecord: registryConfig_pgCodecs_MutationOutOutSetofRecord_MutationOutOutSetofRecord,
    MutationOutOutUnnamedRecord: registryConfig_pgCodecs_MutationOutOutUnnamedRecord_MutationOutOutUnnamedRecord,
    SearchTestSummariesRecord: registryConfig_pgCodecs_SearchTestSummariesRecord_SearchTestSummariesRecord,
    FuncOutUnnamedOutOutUnnamedRecord: registryConfig_pgCodecs_FuncOutUnnamedOutOutUnnamedRecord_FuncOutUnnamedOutOutUnnamedRecord,
    FuncReturnsTableMultiColRecord: registryConfig_pgCodecs_FuncReturnsTableMultiColRecord_FuncReturnsTableMultiColRecord,
    MutationOutUnnamedOutOutUnnamedRecord: registryConfig_pgCodecs_MutationOutUnnamedOutOutUnnamedRecord_MutationOutUnnamedOutOutUnnamedRecord,
    MutationReturnsTableMultiColRecord: registryConfig_pgCodecs_MutationReturnsTableMultiColRecord_MutationReturnsTableMultiColRecord,
    guid: registryConfig_pgCodecs_guid_guid,
    varchar: TYPES.varchar,
    intervalArray: registryConfig_pgCodecs_intervalArray_intervalArray,
    textArray: registryConfig_pgCodecs_textArray_textArray,
    nonUpdatableView: registryConfig_pgCodecs_nonUpdatableView_nonUpdatableView,
    inputs: registryConfig_pgCodecs_inputs_inputs,
    patchs: registryConfig_pgCodecs_patchs_patchs,
    reserved: registryConfig_pgCodecs_reserved_reserved,
    reservedPatchs: registryConfig_pgCodecs_reservedPatchs_reservedPatchs,
    reservedInput: registryConfig_pgCodecs_reservedInput_reservedInput,
    defaultValue: registryConfig_pgCodecs_defaultValue_defaultValue,
    foreignKey: registryConfig_pgCodecs_foreignKey_foreignKey,
    noPrimaryKey: registryConfig_pgCodecs_noPrimaryKey_noPrimaryKey,
    testview: registryConfig_pgCodecs_testview_testview,
    uniqueForeignKey: registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey,
    myTable: registryConfig_pgCodecs_myTable_myTable,
    personSecret: registryConfig_pgCodecs_personSecret_personSecret,
    viewTable: registryConfig_pgCodecs_viewTable_viewTable,
    compoundKey: registryConfig_pgCodecs_compoundKey_compoundKey,
    bool: TYPES.boolean,
    similarTable1: registryConfig_pgCodecs_similarTable1_similarTable1,
    similarTable2: registryConfig_pgCodecs_similarTable2_similarTable2,
    updatableView: registryConfig_pgCodecs_updatableView_updatableView,
    nullTestRecord: registryConfig_pgCodecs_nullTestRecord_nullTestRecord,
    uuidArray: registryConfig_pgCodecs_uuidArray_uuidArray,
    uuid: TYPES.uuid,
    edgeCase: registryConfig_pgCodecs_edgeCase_edgeCase,
    int2: TYPES.int2,
    leftArm: registryConfig_pgCodecs_leftArm_leftArm,
    float8: TYPES.float,
    jwtToken: registryConfig_pgCodecs_jwtToken_jwtToken,
    numeric: TYPES.numeric,
    issue756: registryConfig_pgCodecs_issue756_issue756,
    notNullTimestamp: attributes_ts_codec_notNullTimestamp,
    timestamptz: TYPES.timestamptz,
    authPayload: registryConfig_pgCodecs_authPayload_authPayload,
    FuncOutOutCompoundTypeRecord: registryConfig_pgCodecs_FuncOutOutCompoundTypeRecord_FuncOutOutCompoundTypeRecord,
    compoundType: attributes_o2_codec_compoundType,
    color: attributes_c_codec_color,
    enumCaps: attributes_e_codec_enumCaps,
    enumWithEmptyString: attributes_f_codec_enumWithEmptyString,
    MutationOutOutCompoundTypeRecord: registryConfig_pgCodecs_MutationOutOutCompoundTypeRecord_MutationOutOutCompoundTypeRecord,
    QueryOutputTwoRowsRecord: registryConfig_pgCodecs_QueryOutputTwoRowsRecord_QueryOutputTwoRowsRecord,
    post: attributes_post_codec_post,
    anEnumArray: attributes_enums_codec_anEnumArray,
    anEnum: innerCodec_anEnum,
    comptypeArray: attributes_comptypes_codec_comptypeArray,
    comptype: innerCodec_comptype,
    PersonComputedOutOutRecord: registryConfig_pgCodecs_PersonComputedOutOutRecord_PersonComputedOutOutRecord,
    PersonComputedInoutOutRecord: registryConfig_pgCodecs_PersonComputedInoutOutRecord_PersonComputedInoutOutRecord,
    PersonComputedFirstArgInoutOutRecord: registryConfig_pgCodecs_PersonComputedFirstArgInoutOutRecord_PersonComputedFirstArgInoutOutRecord,
    person: attributes_person_codec_person,
    email: attributes_email_codec_email,
    wrappedUrl: attributes_site_codec_wrappedUrl,
    notNullUrl: attributes_url_codec_notNullUrl,
    hstore: TYPES.hstore,
    inet: TYPES.inet,
    cidr: TYPES.cidr,
    macaddr: TYPES.macaddr,
    timestamp: TYPES.timestamp,
    FuncOutComplexRecord: registryConfig_pgCodecs_FuncOutComplexRecord_FuncOutComplexRecord,
    FuncOutComplexSetofRecord: registryConfig_pgCodecs_FuncOutComplexSetofRecord_FuncOutComplexSetofRecord,
    MutationOutComplexRecord: registryConfig_pgCodecs_MutationOutComplexRecord_MutationOutComplexRecord,
    MutationOutComplexSetofRecord: registryConfig_pgCodecs_MutationOutComplexSetofRecord_MutationOutComplexSetofRecord,
    PersonComputedComplexRecord: registryConfig_pgCodecs_PersonComputedComplexRecord_PersonComputedComplexRecord,
    types: registryConfig_pgCodecs_types_types,
    colorArray: attributes_enum_array_codec_colorArray,
    anInt: attributes_domain_codec_anInt,
    anotherInt: attributes_domain2_codec_anotherInt,
    numrange: attributes_nullable_range_codec_numrange,
    daterange: attributes_daterange_codec_daterange,
    date: TYPES.date,
    anIntRange: attributes_an_int_range_codec_anIntRange,
    time: TYPES.time,
    timetz: TYPES.timetz,
    money: TYPES.money,
    nestedCompoundType: attributes_nested_compound_type_codec_nestedCompoundType,
    point: TYPES.point,
    regproc: TYPES.regproc,
    regprocedure: TYPES.regprocedure,
    regoper: TYPES.regoper,
    regoperator: TYPES.regoperator,
    regclass: TYPES.regclass,
    regtype: TYPES.regtype,
    regconfig: TYPES.regconfig,
    regdictionary: TYPES.regdictionary,
    textArrayDomain: attributes_text_array_domain_codec_textArrayDomain,
    int8ArrayDomain: attributes_int8_array_domain_codec_int8ArrayDomain,
    bytea: TYPES.bytea,
    byteaArray: attributes_bytea_array_codec_byteaArray,
    ltree: attributes_ltree_codec_ltree,
    "ltree[]": attributes_ltree_array_codec_ltree_,
    bpchar: TYPES.bpchar,
    compoundTypeArray: listOfCodec(attributes_o2_codec_compoundType, {
      extensions: extensions55,
      typeDelim: ",",
      description: undefined,
      name: "compoundTypeArray"
    }),
    jwtTokenArray: listOfCodec(registryConfig_pgCodecs_jwtToken_jwtToken, {
      extensions: extensions56,
      typeDelim: ",",
      description: undefined,
      name: "jwtTokenArray"
    }),
    typesArray: listOfCodec(registryConfig_pgCodecs_types_types, {
      extensions: extensions57,
      typeDelim: ",",
      description: undefined,
      name: "typesArray"
    }),
    int4Array: registryConfig_pgCodecs_int4Array_int4Array,
    floatrange: registryConfig_pgCodecs_floatrange_floatrange,
    postArray: registryConfig_pgCodecs_postArray_postArray,
    int8Array: innerCodec_int8Array,
    tablefuncCrosstab2: recordCodec(spec_tablefuncCrosstab2),
    tablefuncCrosstab3: recordCodec(spec_tablefuncCrosstab3),
    tablefuncCrosstab4: recordCodec(spec_tablefuncCrosstab4)
  }),
  pgResources: Object.assign(Object.create(null), {
    current_user_id: {
      executor: executor_mainPgExecutor,
      name: "current_user_id",
      identifier: "main.c.current_user_id()",
      from(...args) {
        return sql`${sqlIdent51}(${sqlFromArgDigests(args)})`;
      },
      parameters: [],
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions64,
      description: undefined
    },
    func_out: {
      executor: executor_mainPgExecutor,
      name: "func_out",
      identifier: "main.c.func_out(int4)",
      from: fromCallback2,
      parameters: parameters2,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions65,
      description: undefined
    },
    func_out_setof: {
      executor: executor_mainPgExecutor,
      name: "func_out_setof",
      identifier: "main.c.func_out_setof(int4)",
      from: fromCallback3,
      parameters: parameters3,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions66,
      description: undefined
    },
    func_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "func_out_unnamed",
      identifier: "main.c.func_out_unnamed(int4)",
      from: fromCallback4,
      parameters: parameters4,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions67,
      description: undefined
    },
    mutation_out: {
      executor: executor_mainPgExecutor,
      name: "mutation_out",
      identifier: "main.c.mutation_out(int4)",
      from: fromCallback5,
      parameters: parameters5,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions68,
      description: undefined
    },
    mutation_out_setof: {
      executor: executor_mainPgExecutor,
      name: "mutation_out_setof",
      identifier: "main.c.mutation_out_setof(int4)",
      from: fromCallback6,
      parameters: parameters6,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions69,
      description: undefined
    },
    mutation_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "mutation_out_unnamed",
      identifier: "main.c.mutation_out_unnamed(int4)",
      from: fromCallback7,
      parameters: parameters7,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions70,
      description: undefined
    },
    no_args_mutation: {
      executor: executor_mainPgExecutor,
      name: "no_args_mutation",
      identifier: "main.c.no_args_mutation()",
      from: fromCallback8,
      parameters: parameters8,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions71,
      description: undefined
    },
    no_args_query: {
      executor: executor_mainPgExecutor,
      name: "no_args_query",
      identifier: "main.c.no_args_query()",
      from: fromCallback9,
      parameters: parameters9,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions72,
      description: undefined
    },
    return_void_mutation: {
      executor: executor_mainPgExecutor,
      name: "return_void_mutation",
      identifier: "main.a.return_void_mutation()",
      from: fromCallback10,
      parameters: parameters10,
      isUnique: !false,
      codec: TYPES.void,
      uniques: [],
      isMutation: true,
      extensions: extensions73,
      description: undefined
    },
    mutation_interval_set: {
      executor: executor_mainPgExecutor,
      name: "mutation_interval_set",
      identifier: "main.a.mutation_interval_set()",
      from: fromCallback11,
      parameters: parameters11,
      isUnique: !true,
      codec: TYPES.interval,
      uniques: [],
      isMutation: true,
      extensions: extensions74,
      description: undefined
    },
    query_interval_set: {
      executor: executor_mainPgExecutor,
      name: "query_interval_set",
      identifier: "main.a.query_interval_set()",
      from: fromCallback12,
      parameters: parameters12,
      isUnique: !true,
      codec: TYPES.interval,
      uniques: [],
      isMutation: false,
      extensions: extensions75,
      description: undefined
    },
    static_big_integer: {
      executor: executor_mainPgExecutor,
      name: "static_big_integer",
      identifier: "main.a.static_big_integer()",
      from: fromCallback13,
      parameters: parameters13,
      isUnique: !true,
      codec: TYPES.bigint,
      uniques: [],
      isMutation: false,
      extensions: extensions76,
      description: undefined
    },
    func_in_out: {
      executor: executor_mainPgExecutor,
      name: "func_in_out",
      identifier: "main.c.func_in_out(int4,int4)",
      from: fromCallback14,
      parameters: parameters14,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions77,
      description: undefined
    },
    func_returns_table_one_col: {
      executor: executor_mainPgExecutor,
      name: "func_returns_table_one_col",
      identifier: "main.c.func_returns_table_one_col(int4,int4)",
      from: fromCallback15,
      parameters: parameters15,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions78,
      description: undefined
    },
    mutation_in_out: {
      executor: executor_mainPgExecutor,
      name: "mutation_in_out",
      identifier: "main.c.mutation_in_out(int4,int4)",
      from: fromCallback16,
      parameters: parameters16,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions79,
      description: undefined
    },
    mutation_returns_table_one_col: {
      executor: executor_mainPgExecutor,
      name: "mutation_returns_table_one_col",
      identifier: "main.c.mutation_returns_table_one_col(int4,int4)",
      from: fromCallback17,
      parameters: parameters17,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions80,
      description: undefined
    },
    assert_something: {
      executor: executor_mainPgExecutor,
      name: "assert_something",
      identifier: "main.a.assert_something(text)",
      from: fromCallback18,
      parameters: parameters18,
      isUnique: !false,
      codec: TYPES.void,
      uniques: [],
      isMutation: false,
      extensions: extensions81,
      description: undefined
    },
    assert_something_nx: {
      executor: executor_mainPgExecutor,
      name: "assert_something_nx",
      identifier: "main.a.assert_something_nx(text)",
      from: fromCallback19,
      parameters: parameters19,
      isUnique: !false,
      codec: TYPES.void,
      uniques: [],
      isMutation: false,
      extensions: extensions82,
      description: undefined
    },
    json_identity: {
      executor: executor_mainPgExecutor,
      name: "json_identity",
      identifier: "main.c.json_identity(json)",
      from: fromCallback20,
      parameters: parameters20,
      isUnique: !false,
      codec: TYPES.json,
      uniques: [],
      isMutation: false,
      extensions: extensions83,
      description: undefined
    },
    json_identity_mutation: {
      executor: executor_mainPgExecutor,
      name: "json_identity_mutation",
      identifier: "main.c.json_identity_mutation(json)",
      from: fromCallback21,
      parameters: parameters21,
      isUnique: !false,
      codec: TYPES.json,
      uniques: [],
      isMutation: true,
      extensions: extensions84,
      description: undefined
    },
    jsonb_identity: {
      executor: executor_mainPgExecutor,
      name: "jsonb_identity",
      identifier: "main.c.jsonb_identity(jsonb)",
      from: fromCallback22,
      parameters: parameters22,
      isUnique: !false,
      codec: TYPES.jsonb,
      uniques: [],
      isMutation: false,
      extensions: extensions85,
      description: undefined
    },
    jsonb_identity_mutation: {
      executor: executor_mainPgExecutor,
      name: "jsonb_identity_mutation",
      identifier: "main.c.jsonb_identity_mutation(jsonb)",
      from: fromCallback23,
      parameters: parameters23,
      isUnique: !false,
      codec: TYPES.jsonb,
      uniques: [],
      isMutation: true,
      extensions: extensions86,
      description: undefined
    },
    jsonb_identity_mutation_plpgsql: {
      executor: executor_mainPgExecutor,
      name: "jsonb_identity_mutation_plpgsql",
      identifier: "main.c.jsonb_identity_mutation_plpgsql(jsonb)",
      from: fromCallback24,
      parameters: parameters24,
      isUnique: !false,
      codec: TYPES.jsonb,
      uniques: [],
      isMutation: true,
      extensions: extensions87,
      description: undefined
    },
    jsonb_identity_mutation_plpgsql_with_default: {
      executor: executor_mainPgExecutor,
      name: "jsonb_identity_mutation_plpgsql_with_default",
      identifier: "main.c.jsonb_identity_mutation_plpgsql_with_default(jsonb)",
      from: fromCallback25,
      parameters: parameters25,
      isUnique: !false,
      codec: TYPES.jsonb,
      uniques: [],
      isMutation: true,
      extensions: extensions88,
      description: undefined
    },
    add_1_mutation: {
      executor: executor_mainPgExecutor,
      name: "add_1_mutation",
      identifier: "main.a.add_1_mutation(int4,int4)",
      from: fromCallback26,
      parameters: parameters26,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions89,
      description: "lol, add some stuff 1 mutation"
    },
    add_1_query: {
      executor: executor_mainPgExecutor,
      name: "add_1_query",
      identifier: "main.a.add_1_query(int4,int4)",
      from: fromCallback27,
      parameters: parameters27,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions90,
      description: "lol, add some stuff 1 query"
    },
    add_2_mutation: {
      executor: executor_mainPgExecutor,
      name: "add_2_mutation",
      identifier: "main.a.add_2_mutation(int4,int4)",
      from: fromCallback28,
      parameters: parameters28,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions91,
      description: "lol, add some stuff 2 mutation"
    },
    add_2_query: {
      executor: executor_mainPgExecutor,
      name: "add_2_query",
      identifier: "main.a.add_2_query(int4,int4)",
      from: fromCallback29,
      parameters: parameters29,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions92,
      description: "lol, add some stuff 2 query"
    },
    add_3_mutation: {
      executor: executor_mainPgExecutor,
      name: "add_3_mutation",
      identifier: "main.a.add_3_mutation(int4,int4)",
      from: fromCallback30,
      parameters: parameters30,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions93,
      description: "lol, add some stuff 3 mutation"
    },
    add_3_query: {
      executor: executor_mainPgExecutor,
      name: "add_3_query",
      identifier: "main.a.add_3_query(int4,int4)",
      from: fromCallback31,
      parameters: parameters31,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions94,
      description: "lol, add some stuff 3 query"
    },
    add_4_mutation: {
      executor: executor_mainPgExecutor,
      name: "add_4_mutation",
      identifier: "main.a.add_4_mutation(int4,int4)",
      from: fromCallback32,
      parameters: parameters32,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions95,
      description: "lol, add some stuff 4 mutation"
    },
    add_4_mutation_error: {
      executor: executor_mainPgExecutor,
      name: "add_4_mutation_error",
      identifier: "main.a.add_4_mutation_error(int4,int4)",
      from: fromCallback33,
      parameters: parameters33,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions96,
      description: undefined
    },
    add_4_query: {
      executor: executor_mainPgExecutor,
      name: "add_4_query",
      identifier: "main.a.add_4_query(int4,int4)",
      from: fromCallback34,
      parameters: parameters34,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions97,
      description: "lol, add some stuff 4 query"
    },
    mult_1: {
      executor: executor_mainPgExecutor,
      name: "mult_1",
      identifier: "main.b.mult_1(int4,int4)",
      from: fromCallback35,
      parameters: parameters35,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions98,
      description: undefined
    },
    mult_2: {
      executor: executor_mainPgExecutor,
      name: "mult_2",
      identifier: "main.b.mult_2(int4,int4)",
      from: fromCallback36,
      parameters: parameters36,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions99,
      description: undefined
    },
    mult_3: {
      executor: executor_mainPgExecutor,
      name: "mult_3",
      identifier: "main.b.mult_3(int4,int4)",
      from: fromCallback37,
      parameters: parameters37,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions100,
      description: undefined
    },
    mult_4: {
      executor: executor_mainPgExecutor,
      name: "mult_4",
      identifier: "main.b.mult_4(int4,int4)",
      from: fromCallback38,
      parameters: parameters38,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions101,
      description: undefined
    },
    func_in_inout: {
      executor: executor_mainPgExecutor,
      name: "func_in_inout",
      identifier: "main.c.func_in_inout(int4,int4)",
      from: fromCallback39,
      parameters: parameters39,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions102,
      description: undefined
    },
    func_out_out: {
      executor: executor_mainPgExecutor,
      name: "func_out_out",
      identifier: "main.c.func_out_out(int4,text)",
      from: fromCallback40,
      parameters: parameters40,
      isUnique: !false,
      codec: registryConfig_pgCodecs_FuncOutOutRecord_FuncOutOutRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions103,
      description: undefined
    },
    func_out_out_setof: {
      executor: executor_mainPgExecutor,
      name: "func_out_out_setof",
      identifier: "main.c.func_out_out_setof(int4,text)",
      from: fromCallback41,
      parameters: parameters41,
      isUnique: !true,
      codec: registryConfig_pgCodecs_FuncOutOutSetofRecord_FuncOutOutSetofRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions104,
      description: undefined
    },
    func_out_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "func_out_out_unnamed",
      identifier: "main.c.func_out_out_unnamed(int4,text)",
      from: fromCallback42,
      parameters: parameters42,
      isUnique: !false,
      codec: registryConfig_pgCodecs_FuncOutOutUnnamedRecord_FuncOutOutUnnamedRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions105,
      description: undefined
    },
    mutation_in_inout: {
      executor: executor_mainPgExecutor,
      name: "mutation_in_inout",
      identifier: "main.c.mutation_in_inout(int4,int4)",
      from: fromCallback43,
      parameters: parameters43,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions106,
      description: undefined
    },
    mutation_out_out: {
      executor: executor_mainPgExecutor,
      name: "mutation_out_out",
      identifier: "main.c.mutation_out_out(int4,text)",
      from: fromCallback44,
      parameters: parameters44,
      isUnique: !false,
      codec: registryConfig_pgCodecs_MutationOutOutRecord_MutationOutOutRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions107,
      description: undefined
    },
    mutation_out_out_setof: {
      executor: executor_mainPgExecutor,
      name: "mutation_out_out_setof",
      identifier: "main.c.mutation_out_out_setof(int4,text)",
      from: fromCallback45,
      parameters: parameters45,
      isUnique: !true,
      codec: registryConfig_pgCodecs_MutationOutOutSetofRecord_MutationOutOutSetofRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions108,
      description: undefined
    },
    mutation_out_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "mutation_out_out_unnamed",
      identifier: "main.c.mutation_out_out_unnamed(int4,text)",
      from: fromCallback46,
      parameters: parameters46,
      isUnique: !false,
      codec: registryConfig_pgCodecs_MutationOutOutUnnamedRecord_MutationOutOutUnnamedRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions109,
      description: undefined
    },
    search_test_summaries: {
      executor: executor_mainPgExecutor,
      name: "search_test_summaries",
      identifier: "main.c.search_test_summaries(int4,interval)",
      from: fromCallback47,
      parameters: parameters47,
      isUnique: !true,
      codec: registryConfig_pgCodecs_SearchTestSummariesRecord_SearchTestSummariesRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions110,
      description: undefined
    },
    optional_missing_middle_1: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_1",
      identifier: "main.a.optional_missing_middle_1(int4,int4,int4)",
      from: fromCallback48,
      parameters: parameters48,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions111,
      description: undefined
    },
    optional_missing_middle_2: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_2",
      identifier: "main.a.optional_missing_middle_2(int4,int4,int4)",
      from: fromCallback49,
      parameters: parameters49,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions112,
      description: undefined
    },
    optional_missing_middle_3: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_3",
      identifier: "main.a.optional_missing_middle_3(int4,int4,int4)",
      from: fromCallback50,
      parameters: parameters50,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions113,
      description: undefined
    },
    optional_missing_middle_4: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_4",
      identifier: "main.a.optional_missing_middle_4(int4,int4,int4)",
      from: fromCallback51,
      parameters: parameters51,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions114,
      description: undefined
    },
    optional_missing_middle_5: {
      executor: executor_mainPgExecutor,
      name: "optional_missing_middle_5",
      identifier: "main.a.optional_missing_middle_5(int4,int4,int4)",
      from: fromCallback52,
      parameters: parameters52,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions115,
      description: undefined
    },
    func_out_unnamed_out_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "func_out_unnamed_out_out_unnamed",
      identifier: "main.c.func_out_unnamed_out_out_unnamed(int4,text,int4)",
      from: fromCallback53,
      parameters: parameters53,
      isUnique: !false,
      codec: registryConfig_pgCodecs_FuncOutUnnamedOutOutUnnamedRecord_FuncOutUnnamedOutOutUnnamedRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions116,
      description: undefined
    },
    func_returns_table_multi_col: {
      executor: executor_mainPgExecutor,
      name: "func_returns_table_multi_col",
      identifier: "main.c.func_returns_table_multi_col(int4,int4,text)",
      from: fromCallback54,
      parameters: parameters54,
      isUnique: !true,
      codec: registryConfig_pgCodecs_FuncReturnsTableMultiColRecord_FuncReturnsTableMultiColRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions117,
      description: undefined
    },
    int_set_mutation: {
      executor: executor_mainPgExecutor,
      name: "int_set_mutation",
      identifier: "main.c.int_set_mutation(int4,int4,int4)",
      from: fromCallback55,
      parameters: parameters55,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: true,
      extensions: extensions118,
      description: undefined
    },
    int_set_query: {
      executor: executor_mainPgExecutor,
      name: "int_set_query",
      identifier: "main.c.int_set_query(int4,int4,int4)",
      from: fromCallback56,
      parameters: parameters56,
      isUnique: !true,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions119,
      description: undefined
    },
    mutation_out_unnamed_out_out_unnamed: {
      executor: executor_mainPgExecutor,
      name: "mutation_out_unnamed_out_out_unnamed",
      identifier: "main.c.mutation_out_unnamed_out_out_unnamed(int4,text,int4)",
      from: fromCallback57,
      parameters: parameters57,
      isUnique: !false,
      codec: registryConfig_pgCodecs_MutationOutUnnamedOutOutUnnamedRecord_MutationOutUnnamedOutOutUnnamedRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions120,
      description: undefined
    },
    mutation_returns_table_multi_col: {
      executor: executor_mainPgExecutor,
      name: "mutation_returns_table_multi_col",
      identifier: "main.c.mutation_returns_table_multi_col(int4,int4,text)",
      from: fromCallback58,
      parameters: parameters58,
      isUnique: !true,
      codec: registryConfig_pgCodecs_MutationReturnsTableMultiColRecord_MutationReturnsTableMultiColRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions121,
      description: undefined
    },
    guid_fn: {
      executor: executor_mainPgExecutor,
      name: "guid_fn",
      identifier: "main.b.guid_fn(b.guid)",
      from: fromCallback59,
      parameters: parameters59,
      isUnique: !false,
      codec: registryConfig_pgCodecs_guid_guid,
      uniques: [],
      isMutation: true,
      extensions: extensions122,
      description: undefined
    },
    mutation_interval_array: {
      executor: executor_mainPgExecutor,
      name: "mutation_interval_array",
      identifier: "main.a.mutation_interval_array()",
      from: fromCallback60,
      parameters: parameters60,
      isUnique: !false,
      codec: registryConfig_pgCodecs_intervalArray_intervalArray,
      uniques: [],
      isMutation: true,
      extensions: extensions123,
      description: undefined
    },
    query_interval_array: {
      executor: executor_mainPgExecutor,
      name: "query_interval_array",
      identifier: "main.a.query_interval_array()",
      from: fromCallback61,
      parameters: parameters61,
      isUnique: !false,
      codec: registryConfig_pgCodecs_intervalArray_intervalArray,
      uniques: [],
      isMutation: false,
      extensions: extensions124,
      description: undefined
    },
    mutation_text_array: {
      executor: executor_mainPgExecutor,
      name: "mutation_text_array",
      identifier: "main.a.mutation_text_array()",
      from: fromCallback62,
      parameters: parameters62,
      isUnique: !false,
      codec: registryConfig_pgCodecs_textArray_textArray,
      uniques: [],
      isMutation: true,
      extensions: extensions125,
      description: undefined
    },
    query_text_array: {
      executor: executor_mainPgExecutor,
      name: "query_text_array",
      identifier: "main.a.query_text_array()",
      from: fromCallback63,
      parameters: parameters63,
      isUnique: !false,
      codec: registryConfig_pgCodecs_textArray_textArray,
      uniques: [],
      isMutation: false,
      extensions: extensions126,
      description: undefined
    },
    non_updatable_view: {
      executor: executor_mainPgExecutor,
      name: "non_updatable_view",
      identifier: "main.a.non_updatable_view",
      from: registryConfig_pgCodecs_nonUpdatableView_nonUpdatableView.sqlType,
      codec: registryConfig_pgCodecs_nonUpdatableView_nonUpdatableView,
      uniques: [],
      isVirtual: false,
      description: undefined,
      extensions: extensions127
    },
    inputs: {
      executor: executor_mainPgExecutor,
      name: "inputs",
      identifier: "main.a.inputs",
      from: registryConfig_pgCodecs_inputs_inputs.sqlType,
      codec: registryConfig_pgCodecs_inputs_inputs,
      uniques: uniques2,
      isVirtual: false,
      description: "Should output as Input",
      extensions: extensions128
    },
    patchs: {
      executor: executor_mainPgExecutor,
      name: "patchs",
      identifier: "main.a.patchs",
      from: registryConfig_pgCodecs_patchs_patchs.sqlType,
      codec: registryConfig_pgCodecs_patchs_patchs,
      uniques: uniques3,
      isVirtual: false,
      description: "Should output as Patch",
      extensions: extensions129
    },
    reserved: {
      executor: executor_mainPgExecutor,
      name: "reserved",
      identifier: "main.a.reserved",
      from: registryConfig_pgCodecs_reserved_reserved.sqlType,
      codec: registryConfig_pgCodecs_reserved_reserved,
      uniques: uniques4,
      isVirtual: false,
      description: undefined,
      extensions: extensions130
    },
    reservedPatchs: {
      executor: executor_mainPgExecutor,
      name: "reservedPatchs",
      identifier: "main.a.reservedPatchs",
      from: registryConfig_pgCodecs_reservedPatchs_reservedPatchs.sqlType,
      codec: registryConfig_pgCodecs_reservedPatchs_reservedPatchs,
      uniques: uniques5,
      isVirtual: false,
      description: "`reservedPatchs` table should get renamed to ReservedPatchRecord to prevent clashes with ReservedPatch from `reserved` table",
      extensions: extensions131
    },
    reserved_input: {
      executor: executor_mainPgExecutor,
      name: "reserved_input",
      identifier: "main.a.reserved_input",
      from: registryConfig_pgCodecs_reservedInput_reservedInput.sqlType,
      codec: registryConfig_pgCodecs_reservedInput_reservedInput,
      uniques: uniques6,
      isVirtual: false,
      description: "`reserved_input` table should get renamed to ReservedInputRecord to prevent clashes with ReservedInput from `reserved` table",
      extensions: extensions132
    },
    default_value: {
      executor: executor_mainPgExecutor,
      name: "default_value",
      identifier: "main.a.default_value",
      from: registryConfig_pgCodecs_defaultValue_defaultValue.sqlType,
      codec: registryConfig_pgCodecs_defaultValue_defaultValue,
      uniques: uniques7,
      isVirtual: false,
      description: undefined,
      extensions: extensions133
    },
    foreign_key: registryConfig_pgResources_foreign_key_foreign_key,
    no_primary_key: {
      executor: executor_mainPgExecutor,
      name: "no_primary_key",
      identifier: "main.a.no_primary_key",
      from: registryConfig_pgCodecs_noPrimaryKey_noPrimaryKey.sqlType,
      codec: registryConfig_pgCodecs_noPrimaryKey_noPrimaryKey,
      uniques: uniques9,
      isVirtual: false,
      description: undefined,
      extensions: extensions135
    },
    testview: {
      executor: executor_mainPgExecutor,
      name: "testview",
      identifier: "main.a.testview",
      from: registryConfig_pgCodecs_testview_testview.sqlType,
      codec: registryConfig_pgCodecs_testview_testview,
      uniques: uniques10,
      isVirtual: false,
      description: undefined,
      extensions: extensions136
    },
    unique_foreign_key: registryConfig_pgResources_unique_foreign_key_unique_foreign_key,
    my_table: {
      executor: executor_mainPgExecutor,
      name: "my_table",
      identifier: "main.c.my_table",
      from: registryConfig_pgCodecs_myTable_myTable.sqlType,
      codec: registryConfig_pgCodecs_myTable_myTable,
      uniques: uniques12,
      isVirtual: false,
      description: undefined,
      extensions: extensions138
    },
    person_secret: registryConfig_pgResources_person_secret_person_secret,
    view_table: {
      executor: executor_mainPgExecutor,
      name: "view_table",
      identifier: "main.a.view_table",
      from: registryConfig_pgCodecs_viewTable_viewTable.sqlType,
      codec: registryConfig_pgCodecs_viewTable_viewTable,
      uniques: uniques14,
      isVirtual: false,
      description: undefined,
      extensions: extensions140
    },
    compound_key: registryConfig_pgResources_compound_key_compound_key,
    similar_table_1: {
      executor: executor_mainPgExecutor,
      name: "similar_table_1",
      identifier: "main.a.similar_table_1",
      from: registryConfig_pgCodecs_similarTable1_similarTable1.sqlType,
      codec: registryConfig_pgCodecs_similarTable1_similarTable1,
      uniques: uniques16,
      isVirtual: false,
      description: undefined,
      extensions: extensions142
    },
    similar_table_2: {
      executor: executor_mainPgExecutor,
      name: "similar_table_2",
      identifier: "main.a.similar_table_2",
      from: registryConfig_pgCodecs_similarTable2_similarTable2.sqlType,
      codec: registryConfig_pgCodecs_similarTable2_similarTable2,
      uniques: uniques17,
      isVirtual: false,
      description: undefined,
      extensions: extensions143
    },
    updatable_view: {
      executor: executor_mainPgExecutor,
      name: "updatable_view",
      identifier: "main.b.updatable_view",
      from: registryConfig_pgCodecs_updatableView_updatableView.sqlType,
      codec: registryConfig_pgCodecs_updatableView_updatableView,
      uniques: uniques18,
      isVirtual: false,
      description: "YOYOYO!!",
      extensions: extensions144
    },
    null_test_record: {
      executor: executor_mainPgExecutor,
      name: "null_test_record",
      identifier: "main.c.null_test_record",
      from: registryConfig_pgCodecs_nullTestRecord_nullTestRecord.sqlType,
      codec: registryConfig_pgCodecs_nullTestRecord_nullTestRecord,
      uniques: uniques19,
      isVirtual: false,
      description: undefined,
      extensions: extensions145
    },
    edge_case_computed: {
      executor: executor_mainPgExecutor,
      name: "edge_case_computed",
      identifier: "main.c.edge_case_computed(c.edge_case)",
      from: fromCallback64,
      parameters: parameters64,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions146,
      description: undefined
    },
    return_table_without_grants: PgResource.functionResourceOptions(registryConfig_pgResources_compound_key_compound_key, options_return_table_without_grants),
    list_bde_mutation: {
      executor: executor_mainPgExecutor,
      name: "list_bde_mutation",
      identifier: "main.b.list_bde_mutation(_text,text,text)",
      from: fromCallback65,
      parameters: parameters65,
      isUnique: !false,
      codec: registryConfig_pgCodecs_uuidArray_uuidArray,
      uniques: [],
      isMutation: true,
      extensions: extensions147,
      description: undefined
    },
    edge_case: {
      executor: executor_mainPgExecutor,
      name: "edge_case",
      identifier: "main.c.edge_case",
      from: registryConfig_pgCodecs_edgeCase_edgeCase.sqlType,
      codec: registryConfig_pgCodecs_edgeCase_edgeCase,
      uniques: uniques20,
      isVirtual: false,
      description: undefined,
      extensions: extensions148
    },
    left_arm: registryConfig_pgResources_left_arm_left_arm,
    authenticate_fail: PgResource.functionResourceOptions(resourceConfig_jwt_token, options_authenticate_fail),
    authenticate: PgResource.functionResourceOptions(resourceConfig_jwt_token, options_authenticate),
    issue756: registryConfig_pgResources_issue756_issue756,
    left_arm_identity: PgResource.functionResourceOptions(registryConfig_pgResources_left_arm_left_arm, options_left_arm_identity),
    issue756_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_issue756_issue756, options_issue756_mutation),
    issue756_set_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_issue756_issue756, options_issue756_set_mutation),
    authenticate_many: PgResource.functionResourceOptions(resourceConfig_jwt_token, options_authenticate_many),
    authenticate_payload: PgResource.functionResourceOptions(resourceConfig_auth_payload, options_authenticate_payload),
    types_mutation: {
      executor: executor_mainPgExecutor,
      name: "types_mutation",
      identifier: "main.c.types_mutation(int8,bool,varchar,_int4,json,c.floatrange)",
      from: fromCallback66,
      parameters: parameters66,
      isUnique: !false,
      codec: TYPES.boolean,
      uniques: [],
      isMutation: true,
      extensions: extensions153,
      description: undefined
    },
    types_query: {
      executor: executor_mainPgExecutor,
      name: "types_query",
      identifier: "main.c.types_query(int8,bool,varchar,_int4,json,c.floatrange)",
      from: fromCallback67,
      parameters: parameters67,
      isUnique: !false,
      codec: TYPES.boolean,
      uniques: [],
      isMutation: false,
      extensions: extensions154,
      description: undefined
    },
    compound_type_computed_field: {
      executor: executor_mainPgExecutor,
      name: "compound_type_computed_field",
      identifier: "main.c.compound_type_computed_field(c.compound_type)",
      from: fromCallback68,
      parameters: parameters68,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions155,
      description: undefined
    },
    post_computed_interval_set: {
      executor: executor_mainPgExecutor,
      name: "post_computed_interval_set",
      identifier: "main.a.post_computed_interval_set(a.post)",
      from: fromCallback69,
      parameters: parameters69,
      isUnique: !true,
      codec: TYPES.interval,
      uniques: [],
      isMutation: false,
      extensions: extensions156,
      description: undefined
    },
    post_computed_interval_array: {
      executor: executor_mainPgExecutor,
      name: "post_computed_interval_array",
      identifier: "main.a.post_computed_interval_array(a.post)",
      from: fromCallback70,
      parameters: parameters70,
      isUnique: !false,
      codec: registryConfig_pgCodecs_intervalArray_intervalArray,
      uniques: [],
      isMutation: false,
      extensions: extensions157,
      description: undefined
    },
    post_computed_text_array: {
      executor: executor_mainPgExecutor,
      name: "post_computed_text_array",
      identifier: "main.a.post_computed_text_array(a.post)",
      from: fromCallback71,
      parameters: parameters71,
      isUnique: !false,
      codec: registryConfig_pgCodecs_textArray_textArray,
      uniques: [],
      isMutation: false,
      extensions: extensions158,
      description: undefined
    },
    post_computed_with_optional_arg: {
      executor: executor_mainPgExecutor,
      name: "post_computed_with_optional_arg",
      identifier: "main.a.post_computed_with_optional_arg(a.post,int4)",
      from: fromCallback72,
      parameters: parameters72,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions159,
      description: undefined
    },
    post_computed_with_required_arg: {
      executor: executor_mainPgExecutor,
      name: "post_computed_with_required_arg",
      identifier: "main.a.post_computed_with_required_arg(a.post,int4)",
      from: fromCallback73,
      parameters: parameters73,
      isUnique: !false,
      codec: TYPES.int,
      uniques: [],
      isMutation: false,
      extensions: extensions160,
      description: undefined
    },
    func_out_out_compound_type: {
      executor: executor_mainPgExecutor,
      name: "func_out_out_compound_type",
      identifier: "main.c.func_out_out_compound_type(int4,int4,c.compound_type)",
      from: fromCallback74,
      parameters: parameters74,
      isUnique: !false,
      codec: registryConfig_pgCodecs_FuncOutOutCompoundTypeRecord_FuncOutOutCompoundTypeRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions161,
      description: undefined
    },
    mutation_out_out_compound_type: {
      executor: executor_mainPgExecutor,
      name: "mutation_out_out_compound_type",
      identifier: "main.c.mutation_out_out_compound_type(int4,int4,c.compound_type)",
      from: fromCallback75,
      parameters: parameters75,
      isUnique: !false,
      codec: registryConfig_pgCodecs_MutationOutOutCompoundTypeRecord_MutationOutOutCompoundTypeRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions162,
      description: undefined
    },
    post_headline_trimmed: {
      executor: executor_mainPgExecutor,
      name: "post_headline_trimmed",
      identifier: "main.a.post_headline_trimmed(a.post,int4,text)",
      from: fromCallback76,
      parameters: parameters76,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions163,
      description: undefined
    },
    post_headline_trimmed_no_defaults: {
      executor: executor_mainPgExecutor,
      name: "post_headline_trimmed_no_defaults",
      identifier: "main.a.post_headline_trimmed_no_defaults(a.post,int4,text)",
      from: fromCallback77,
      parameters: parameters77,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions164,
      description: undefined
    },
    post_headline_trimmed_strict: {
      executor: executor_mainPgExecutor,
      name: "post_headline_trimmed_strict",
      identifier: "main.a.post_headline_trimmed_strict(a.post,int4,text)",
      from: fromCallback78,
      parameters: parameters78,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions165,
      description: undefined
    },
    query_output_two_rows: {
      executor: executor_mainPgExecutor,
      name: "query_output_two_rows",
      identifier: "main.c.query_output_two_rows(int4,int4,text,c.left_arm,a.post)",
      from: fromCallback79,
      parameters: parameters79,
      isUnique: !false,
      codec: registryConfig_pgCodecs_QueryOutputTwoRowsRecord_QueryOutputTwoRowsRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions166,
      description: undefined
    },
    post: registryConfig_pgResources_post_post,
    compound_type_set_query: PgResource.functionResourceOptions(resourceConfig_compound_type, options_compound_type_set_query),
    compound_type_mutation: PgResource.functionResourceOptions(resourceConfig_compound_type, options_compound_type_mutation),
    compound_type_query: PgResource.functionResourceOptions(resourceConfig_compound_type, options_compound_type_query),
    compound_type_set_mutation: PgResource.functionResourceOptions(resourceConfig_compound_type, options_compound_type_set_mutation),
    table_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_table_mutation),
    table_query: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_table_query),
    post_with_suffix: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_post_with_suffix),
    mutation_compound_type_array: PgResource.functionResourceOptions(resourceConfig_compound_type, options_mutation_compound_type_array),
    query_compound_type_array: PgResource.functionResourceOptions(resourceConfig_compound_type, options_query_compound_type_array),
    compound_type_array_mutation: PgResource.functionResourceOptions(resourceConfig_compound_type, options_compound_type_array_mutation),
    compound_type_array_query: PgResource.functionResourceOptions(resourceConfig_compound_type, options_compound_type_array_query),
    post_computed_compound_type_array: PgResource.functionResourceOptions(resourceConfig_compound_type, options_post_computed_compound_type_array),
    post_many: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_post_many),
    person_computed_out: {
      executor: executor_mainPgExecutor,
      name: "person_computed_out",
      identifier: "main.c.person_computed_out(c.person,text)",
      from: fromCallback80,
      parameters: parameters80,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions169,
      description: undefined
    },
    person_first_name: {
      executor: executor_mainPgExecutor,
      name: "person_first_name",
      identifier: "main.c.person_first_name(c.person)",
      from: fromCallback81,
      parameters: parameters81,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions170,
      description: "The first name of the person."
    },
    person_computed_out_out: {
      executor: executor_mainPgExecutor,
      name: "person_computed_out_out",
      identifier: "main.c.person_computed_out_out(c.person,text,text)",
      from: fromCallback82,
      parameters: parameters82,
      isUnique: !false,
      codec: registryConfig_pgCodecs_PersonComputedOutOutRecord_PersonComputedOutOutRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions171,
      description: undefined
    },
    person_computed_inout: {
      executor: executor_mainPgExecutor,
      name: "person_computed_inout",
      identifier: "main.c.person_computed_inout(c.person,text)",
      from: fromCallback83,
      parameters: parameters83,
      isUnique: !false,
      codec: TYPES.text,
      uniques: [],
      isMutation: false,
      extensions: extensions172,
      description: undefined
    },
    person_computed_inout_out: {
      executor: executor_mainPgExecutor,
      name: "person_computed_inout_out",
      identifier: "main.c.person_computed_inout_out(c.person,text,text)",
      from: fromCallback84,
      parameters: parameters84,
      isUnique: !false,
      codec: registryConfig_pgCodecs_PersonComputedInoutOutRecord_PersonComputedInoutOutRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions173,
      description: undefined
    },
    person_exists: {
      executor: executor_mainPgExecutor,
      name: "person_exists",
      identifier: "main.c.person_exists(c.person,b.email)",
      from: fromCallback85,
      parameters: parameters85,
      isUnique: !false,
      codec: TYPES.boolean,
      uniques: [],
      isMutation: false,
      extensions: extensions174,
      description: undefined
    },
    person_computed_first_arg_inout_out: {
      executor: executor_mainPgExecutor,
      name: "person_computed_first_arg_inout_out",
      identifier: "main.c.person_computed_first_arg_inout_out(c.person,int4)",
      from: fromCallback86,
      parameters: parameters86,
      isUnique: !false,
      codec: registryConfig_pgCodecs_PersonComputedFirstArgInoutOutRecord_PersonComputedFirstArgInoutOutRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions175,
      description: undefined
    },
    func_out_complex: {
      executor: executor_mainPgExecutor,
      name: "func_out_complex",
      identifier: "main.c.func_out_complex(int4,text,int4,c.compound_type,c.person)",
      from: fromCallback87,
      parameters: parameters87,
      isUnique: !false,
      codec: registryConfig_pgCodecs_FuncOutComplexRecord_FuncOutComplexRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions176,
      description: undefined
    },
    func_out_complex_setof: {
      executor: executor_mainPgExecutor,
      name: "func_out_complex_setof",
      identifier: "main.c.func_out_complex_setof(int4,text,int4,c.compound_type,c.person)",
      from: fromCallback88,
      parameters: parameters88,
      isUnique: !true,
      codec: registryConfig_pgCodecs_FuncOutComplexSetofRecord_FuncOutComplexSetofRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions177,
      description: undefined
    },
    mutation_out_complex: {
      executor: executor_mainPgExecutor,
      name: "mutation_out_complex",
      identifier: "main.c.mutation_out_complex(int4,text,int4,c.compound_type,c.person)",
      from: fromCallback89,
      parameters: parameters89,
      isUnique: !false,
      codec: registryConfig_pgCodecs_MutationOutComplexRecord_MutationOutComplexRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions178,
      description: undefined
    },
    mutation_out_complex_setof: {
      executor: executor_mainPgExecutor,
      name: "mutation_out_complex_setof",
      identifier: "main.c.mutation_out_complex_setof(int4,text,int4,c.compound_type,c.person)",
      from: fromCallback90,
      parameters: parameters90,
      isUnique: !true,
      codec: registryConfig_pgCodecs_MutationOutComplexSetofRecord_MutationOutComplexSetofRecord,
      uniques: [],
      isMutation: true,
      extensions: extensions179,
      description: undefined
    },
    person_computed_complex: {
      executor: executor_mainPgExecutor,
      name: "person_computed_complex",
      identifier: "main.c.person_computed_complex(c.person,int4,text,int4,c.compound_type,c.person)",
      from: fromCallback91,
      parameters: parameters91,
      isUnique: !false,
      codec: registryConfig_pgCodecs_PersonComputedComplexRecord_PersonComputedComplexRecord,
      uniques: [],
      isMutation: false,
      extensions: extensions180,
      description: undefined
    },
    person_first_post: PgResource.functionResourceOptions(registryConfig_pgResources_post_post, options_person_first_post),
    person: registryConfig_pgResources_person_person,
    badly_behaved_function: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_badly_behaved_function),
    func_out_table: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_func_out_table),
    func_out_table_setof: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_func_out_table_setof),
    mutation_out_table: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_mutation_out_table),
    mutation_out_table_setof: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_mutation_out_table_setof),
    table_set_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_table_set_mutation),
    table_set_query: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_table_set_query),
    table_set_query_plpgsql: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_table_set_query_plpgsql),
    person_computed_first_arg_inout: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_person_computed_first_arg_inout),
    person_friends: PgResource.functionResourceOptions(registryConfig_pgResources_person_person, options_person_friends),
    types: registryConfig_pgResources_types_types,
    type_function_connection: PgResource.functionResourceOptions(registryConfig_pgResources_types_types, options_type_function_connection),
    type_function_connection_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_types_types, options_type_function_connection_mutation),
    type_function: PgResource.functionResourceOptions(registryConfig_pgResources_types_types, options_type_function),
    type_function_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_types_types, options_type_function_mutation),
    person_type_function_connection: PgResource.functionResourceOptions(registryConfig_pgResources_types_types, options_person_type_function_connection),
    person_type_function: PgResource.functionResourceOptions(registryConfig_pgResources_types_types, options_person_type_function),
    type_function_list: PgResource.functionResourceOptions(registryConfig_pgResources_types_types, options_type_function_list),
    type_function_list_mutation: PgResource.functionResourceOptions(registryConfig_pgResources_types_types, options_type_function_list_mutation),
    person_type_function_list: PgResource.functionResourceOptions(registryConfig_pgResources_types_types, options_person_type_function_list)
  }),
  pgRelations: Object.assign(Object.create(null), {
    foreignKey: Object.assign(Object.create(null), {
      compoundKeyByMyCompoundKey1AndCompoundKey2: {
        localCodec: registryConfig_pgCodecs_foreignKey_foreignKey,
        remoteResourceOptions: registryConfig_pgResources_compound_key_compound_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["compound_key_1", "compound_key_2"],
        remoteAttributes: ["person_id_1", "person_id_2"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      personByMyPersonId: {
        localCodec: registryConfig_pgCodecs_foreignKey_foreignKey,
        remoteResourceOptions: registryConfig_pgResources_person_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    post: Object.assign(Object.create(null), {
      personByMyAuthorId: {
        localCodec: attributes_post_codec_post,
        remoteResourceOptions: registryConfig_pgResources_person_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["author_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      typesByTheirSmallint: {
        localCodec: attributes_post_codec_post,
        remoteResourceOptions: registryConfig_pgResources_types_types,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["smallint"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      typesByTheirId: {
        localCodec: attributes_post_codec_post,
        remoteResourceOptions: registryConfig_pgResources_types_types,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    uniqueForeignKey: Object.assign(Object.create(null), {
      compoundKeyByMyCompoundKey1AndCompoundKey2: {
        localCodec: registryConfig_pgCodecs_uniqueForeignKey_uniqueForeignKey,
        remoteResourceOptions: registryConfig_pgResources_compound_key_compound_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["compound_key_1", "compound_key_2"],
        remoteAttributes: ["person_id_1", "person_id_2"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    authPayload: Object.assign(Object.create(null), {
      personByMyId: {
        localCodec: registryConfig_pgCodecs_authPayload_authPayload,
        remoteResourceOptions: registryConfig_pgResources_person_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    types: Object.assign(Object.create(null), {
      postByMySmallint: {
        localCodec: registryConfig_pgCodecs_types_types,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["smallint"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postByMyId: {
        localCodec: registryConfig_pgCodecs_types_types,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    compoundKey: Object.assign(Object.create(null), {
      personByMyPersonId1: {
        localCodec: registryConfig_pgCodecs_compoundKey_compoundKey,
        remoteResourceOptions: registryConfig_pgResources_person_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id_1"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      personByMyPersonId2: {
        localCodec: registryConfig_pgCodecs_compoundKey_compoundKey,
        remoteResourceOptions: registryConfig_pgResources_person_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id_2"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      foreignKeysByTheirCompoundKey1AndCompoundKey2: {
        localCodec: registryConfig_pgCodecs_compoundKey_compoundKey,
        remoteResourceOptions: registryConfig_pgResources_foreign_key_foreign_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id_1", "person_id_2"],
        remoteAttributes: ["compound_key_1", "compound_key_2"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      uniqueForeignKeyByTheirCompoundKey1AndCompoundKey2: {
        localCodec: registryConfig_pgCodecs_compoundKey_compoundKey,
        remoteResourceOptions: registryConfig_pgResources_unique_foreign_key_unique_foreign_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id_1", "person_id_2"],
        remoteAttributes: ["compound_key_1", "compound_key_2"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    leftArm: Object.assign(Object.create(null), {
      personByMyPersonId: {
        localCodec: registryConfig_pgCodecs_leftArm_leftArm,
        remoteResourceOptions: registryConfig_pgResources_person_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    person: Object.assign(Object.create(null), {
      postsByTheirAuthorId: {
        localCodec: attributes_person_codec_person,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["author_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      foreignKeysByTheirPersonId: {
        localCodec: attributes_person_codec_person,
        remoteResourceOptions: registryConfig_pgResources_foreign_key_foreign_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      personSecretByTheirPersonId: {
        localCodec: attributes_person_codec_person,
        remoteResourceOptions: registryConfig_pgResources_person_secret_person_secret,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id"],
        isUnique: true,
        isReferencee: true,
        description: "This `Person`'s `PersonSecret`.",
        extensions: {
          tags: {
            forwardDescription: "The `Person` this `PersonSecret` belongs to.",
            backwardDescription: "This `Person`'s `PersonSecret`.",
            behavior: []
          }
        }
      },
      leftArmByTheirPersonId: {
        localCodec: attributes_person_codec_person,
        remoteResourceOptions: registryConfig_pgResources_left_arm_left_arm,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id"],
        isUnique: true,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      compoundKeysByTheirPersonId1: {
        localCodec: attributes_person_codec_person,
        remoteResourceOptions: registryConfig_pgResources_compound_key_compound_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id_1"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      compoundKeysByTheirPersonId2: {
        localCodec: attributes_person_codec_person,
        remoteResourceOptions: registryConfig_pgResources_compound_key_compound_key,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["person_id_2"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    personSecret: Object.assign(Object.create(null), {
      personByMyPersonId: {
        localCodec: registryConfig_pgCodecs_personSecret_personSecret,
        remoteResourceOptions: registryConfig_pgResources_person_person,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["person_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: "The `Person` this `PersonSecret` belongs to.",
        extensions: {
          tags: {
            forwardDescription: "The `Person` this `PersonSecret` belongs to.",
            backwardDescription: "This `Person`'s `PersonSecret`.",
            behavior: []
          }
        }
      }
    })
  })
});
const resource_inputsPgResource = registry.pgResources["inputs"];
const resource_patchsPgResource = registry.pgResources["patchs"];
const resource_reservedPgResource = registry.pgResources["reserved"];
const resource_reservedPatchsPgResource = registry.pgResources["reservedPatchs"];
const resource_reserved_inputPgResource = registry.pgResources["reserved_input"];
const resource_default_valuePgResource = registry.pgResources["default_value"];
const resource_no_primary_keyPgResource = registry.pgResources["no_primary_key"];
const resource_unique_foreign_keyPgResource = registry.pgResources["unique_foreign_key"];
const resource_my_tablePgResource = registry.pgResources["my_table"];
const resource_person_secretPgResource = registry.pgResources["person_secret"];
const resource_view_tablePgResource = registry.pgResources["view_table"];
const resource_compound_keyPgResource = registry.pgResources["compound_key"];
const resource_similar_table_1PgResource = registry.pgResources["similar_table_1"];
const resource_similar_table_2PgResource = registry.pgResources["similar_table_2"];
const resource_null_test_recordPgResource = registry.pgResources["null_test_record"];
const resource_left_armPgResource = registry.pgResources["left_arm"];
const resource_issue756PgResource = registry.pgResources["issue756"];
const resource_postPgResource = registry.pgResources["post"];
const resource_personPgResource = registry.pgResources["person"];
const resource_typesPgResource = registry.pgResources["types"];
const argDetailsSimple = [];
const makeArgs = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_current_user_idPgResource = registry.pgResources["current_user_id"];
const argDetailsSimple2 = [];
const makeArgs2 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple2[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_outPgResource = registry.pgResources["func_out"];
const argDetailsSimple3 = [];
const makeArgs3 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple3[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_setofPgResource = registry.pgResources["func_out_setof"];
const getSelectPlanFromParentAndArgs = ($root, args, _info) => {
  const selectArgs = makeArgs3(args);
  return resource_func_out_setofPgResource.execute(selectArgs);
};
function Query_funcOutSetofPlan($parent, args, info) {
  const $select = getSelectPlanFromParentAndArgs($parent, args, info);
  return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
}
function Query_funcOutSetof_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_funcOutSetof_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_funcOutSetof_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_funcOutSetof_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_funcOutSetof_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple4 = [];
const makeArgs4 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple4[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_unnamedPgResource = registry.pgResources["func_out_unnamed"];
const argDetailsSimple5 = [];
const makeArgs5 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple5[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_no_args_queryPgResource = registry.pgResources["no_args_query"];
const argDetailsSimple6 = [];
const makeArgs6 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple6[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_query_interval_setPgResource = registry.pgResources["query_interval_set"];
const getSelectPlanFromParentAndArgs2 = ($root, args, _info) => {
  const selectArgs = makeArgs6(args);
  return resource_query_interval_setPgResource.execute(selectArgs);
};
function Query_queryIntervalSet_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_queryIntervalSet_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_queryIntervalSet_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_queryIntervalSet_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_queryIntervalSet_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple7 = [];
const makeArgs7 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple7[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_static_big_integerPgResource = registry.pgResources["static_big_integer"];
const getSelectPlanFromParentAndArgs3 = ($root, args, _info) => {
  const selectArgs = makeArgs7(args);
  return resource_static_big_integerPgResource.execute(selectArgs);
};
function Query_staticBigInteger_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_staticBigInteger_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_staticBigInteger_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_staticBigInteger_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_staticBigInteger_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple8 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs8 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple8[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_in_outPgResource = registry.pgResources["func_in_out"];
const argDetailsSimple9 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs9 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple9[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_returns_table_one_colPgResource = registry.pgResources["func_returns_table_one_col"];
const getSelectPlanFromParentAndArgs4 = ($root, args, _info) => {
  const selectArgs = makeArgs9(args);
  return resource_func_returns_table_one_colPgResource.execute(selectArgs);
};
function Query_funcReturnsTableOneCol_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_funcReturnsTableOneCol_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_funcReturnsTableOneCol_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_funcReturnsTableOneCol_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_funcReturnsTableOneCol_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple10 = [{
  graphqlArgName: "json",
  postgresArgName: "json",
  pgCodec: TYPES.json,
  required: true,
  fetcher: null
}];
const makeArgs10 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple10[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_json_identityPgResource = registry.pgResources["json_identity"];
const argDetailsSimple11 = [{
  graphqlArgName: "json",
  postgresArgName: "json",
  pgCodec: TYPES.jsonb,
  required: true,
  fetcher: null
}];
const makeArgs11 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple11[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_jsonb_identityPgResource = registry.pgResources["jsonb_identity"];
const argDetailsSimple12 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs12 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple12[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_1_queryPgResource = registry.pgResources["add_1_query"];
const argDetailsSimple13 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs13 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple13[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_2_queryPgResource = registry.pgResources["add_2_query"];
const argDetailsSimple14 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs14 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple14[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_3_queryPgResource = registry.pgResources["add_3_query"];
const argDetailsSimple15 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs15 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple15[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 1 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_4_queryPgResource = registry.pgResources["add_4_query"];
const argDetailsSimple16 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "ino",
  postgresArgName: "ino",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs16 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple16[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_in_inoutPgResource = registry.pgResources["func_in_inout"];
const argDetailsSimple17 = [];
const makeArgs17 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple17[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_outPgResource = registry.pgResources["func_out_out"];
const argDetailsSimple18 = [];
const makeArgs18 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple18[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_out_setofPgResource = registry.pgResources["func_out_out_setof"];
const getSelectPlanFromParentAndArgs5 = ($root, args, _info) => {
  const selectArgs = makeArgs18(args);
  return resource_func_out_out_setofPgResource.execute(selectArgs);
};
function Query_funcOutOutSetof_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_funcOutOutSetof_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_funcOutOutSetof_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_funcOutOutSetof_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_funcOutOutSetof_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple19 = [];
const makeArgs19 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple19[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_out_unnamedPgResource = registry.pgResources["func_out_out_unnamed"];
const argDetailsSimple20 = [];
const makeArgs20 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple20[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_search_test_summariesPgResource = registry.pgResources["search_test_summaries"];
function Query_searchTestSummariesList_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_searchTestSummariesList_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
const argDetailsSimple21 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs21 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple21[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 1 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_1PgResource = registry.pgResources["optional_missing_middle_1"];
const argDetailsSimple22 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs22 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple22[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_2PgResource = registry.pgResources["optional_missing_middle_2"];
const argDetailsSimple23 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs23 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple23[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_3PgResource = registry.pgResources["optional_missing_middle_3"];
const argDetailsSimple24 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "arg2",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs24 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple24[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 3 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_4PgResource = registry.pgResources["optional_missing_middle_4"];
const argDetailsSimple25 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "arg2",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs25 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple25[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 3 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_optional_missing_middle_5PgResource = registry.pgResources["optional_missing_middle_5"];
const argDetailsSimple26 = [];
const makeArgs26 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple26[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_unnamed_out_out_unnamedPgResource = registry.pgResources["func_out_unnamed_out_out_unnamed"];
const argDetailsSimple27 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs27 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple27[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_returns_table_multi_colPgResource = registry.pgResources["func_returns_table_multi_col"];
const getSelectPlanFromParentAndArgs6 = ($root, args, _info) => {
  const selectArgs = makeArgs27(args);
  return resource_func_returns_table_multi_colPgResource.execute(selectArgs);
};
function Query_funcReturnsTableMultiCol_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_funcReturnsTableMultiCol_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_funcReturnsTableMultiCol_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_funcReturnsTableMultiCol_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_funcReturnsTableMultiCol_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple28 = [{
  graphqlArgName: "x",
  postgresArgName: "x",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "y",
  postgresArgName: "y",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "z",
  postgresArgName: "z",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs28 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple28[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_int_set_queryPgResource = registry.pgResources["int_set_query"];
const getSelectPlanFromParentAndArgs7 = ($root, args, _info) => {
  const selectArgs = makeArgs28(args);
  return resource_int_set_queryPgResource.execute(selectArgs);
};
function Query_intSetQuery_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_intSetQuery_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_intSetQuery_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_intSetQuery_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_intSetQuery_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple29 = [];
const makeArgs29 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple29[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_query_interval_arrayPgResource = registry.pgResources["query_interval_array"];
const argDetailsSimple30 = [];
const makeArgs30 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple30[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_query_text_arrayPgResource = registry.pgResources["query_text_array"];
const argDetailsSimple31 = [];
const makeArgs31 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple31[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_return_table_without_grantsPgResource = registry.pgResources["return_table_without_grants"];
const argDetailsSimple32 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.boolean,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.varchar,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "d",
  postgresArgName: "d",
  pgCodec: registryConfig_pgCodecs_int4Array_int4Array,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "e",
  postgresArgName: "e",
  pgCodec: TYPES.json,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "f",
  postgresArgName: "f",
  pgCodec: registryConfig_pgCodecs_floatrange_floatrange,
  required: true,
  fetcher: null
}];
const makeArgs32 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 6; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple32[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_types_queryPgResource = registry.pgResources["types_query"];
const argDetailsSimple33 = [{
  graphqlArgName: "i1",
  postgresArgName: "i1",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs33 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple33[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_out_compound_typePgResource = registry.pgResources["func_out_out_compound_type"];
const argDetailsSimple34 = [{
  graphqlArgName: "leftArmId",
  postgresArgName: "left_arm_id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "postId",
  postgresArgName: "post_id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "txt",
  postgresArgName: "txt",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs34 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple34[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_query_output_two_rowsPgResource = registry.pgResources["query_output_two_rows"];
const argDetailsSimple35 = [];
const makeArgs35 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple35[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_compound_type_set_queryPgResource = registry.pgResources["compound_type_set_query"];
const getSelectPlanFromParentAndArgs8 = ($root, args, _info) => {
  const selectArgs = makeArgs35(args);
  return resource_compound_type_set_queryPgResource.execute(selectArgs);
};
function Query_compoundTypeSetQuery_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_compoundTypeSetQuery_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_compoundTypeSetQuery_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_compoundTypeSetQuery_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_compoundTypeSetQuery_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple36 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_compoundType,
  required: true,
  fetcher: null
}];
const makeArgs36 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple36[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_compound_type_queryPgResource = registry.pgResources["compound_type_query"];
const argDetailsSimple37 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs37 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple37[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_table_queryPgResource = registry.pgResources["table_query"];
const argDetailsSimple38 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_compoundType,
  required: true,
  fetcher: null
}];
const makeArgs38 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple38[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_query_compound_type_arrayPgResource = registry.pgResources["query_compound_type_array"];
const argDetailsSimple39 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_compoundType,
  required: true,
  fetcher: null
}];
const makeArgs39 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple39[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_compound_type_array_queryPgResource = registry.pgResources["compound_type_array_query"];
const argDetailsSimple40 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs40 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple40[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_complexPgResource = registry.pgResources["func_out_complex"];
const argDetailsSimple41 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs41 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple41[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_complex_setofPgResource = registry.pgResources["func_out_complex_setof"];
const getSelectPlanFromParentAndArgs9 = ($root, args, _info) => {
  const selectArgs = makeArgs41(args);
  return resource_func_out_complex_setofPgResource.execute(selectArgs);
};
function Query_funcOutComplexSetof_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_funcOutComplexSetof_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_funcOutComplexSetof_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_funcOutComplexSetof_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_funcOutComplexSetof_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple42 = [];
const makeArgs42 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple42[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_badly_behaved_functionPgResource = registry.pgResources["badly_behaved_function"];
const getSelectPlanFromParentAndArgs10 = ($root, args, _info) => {
  const selectArgs = makeArgs42(args);
  return resource_badly_behaved_functionPgResource.execute(selectArgs);
};
function Query_badlyBehavedFunction_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_badlyBehavedFunction_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_badlyBehavedFunction_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_badlyBehavedFunction_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_badlyBehavedFunction_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple43 = [];
const makeArgs43 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple43[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_tablePgResource = registry.pgResources["func_out_table"];
const argDetailsSimple44 = [];
const makeArgs44 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple44[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_func_out_table_setofPgResource = registry.pgResources["func_out_table_setof"];
const getSelectPlanFromParentAndArgs11 = ($root, args, _info) => {
  const selectArgs = makeArgs44(args);
  return resource_func_out_table_setofPgResource.execute(selectArgs);
};
function Query_funcOutTableSetof_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_funcOutTableSetof_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_funcOutTableSetof_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_funcOutTableSetof_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_funcOutTableSetof_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple45 = [];
const makeArgs45 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple45[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_table_set_queryPgResource = registry.pgResources["table_set_query"];
const getSelectPlanFromParentAndArgs12 = ($root, args, _info) => {
  const selectArgs = makeArgs45(args);
  return resource_table_set_queryPgResource.execute(selectArgs);
};
function Query_tableSetQuery_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_tableSetQuery_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_tableSetQuery_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_tableSetQuery_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_tableSetQuery_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const applyOrderToPlan = ($select, $value, TableOrderByType) => {
  const val = $value.eval();
  if (val == null) {
    return;
  }
  if (!Array.isArray(val)) {
    throw new Error("Invalid!");
  }
  val.forEach(order => {
    const config = getEnumValueConfig(TableOrderByType, order);
    const plan = config?.extensions?.grafast?.applyPlan;
    if (typeof plan !== "function") {
      console.error(`Internal server error: invalid orderBy configuration: expected function, but received ${inspect(plan)}`);
      throw new SafeError("Internal server error: invalid orderBy configuration");
    }
    plan($select);
  });
};
const argDetailsSimple46 = [];
const makeArgs46 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple46[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_table_set_query_plpgsqlPgResource = registry.pgResources["table_set_query_plpgsql"];
const getSelectPlanFromParentAndArgs13 = ($root, args, _info) => {
  const selectArgs = makeArgs46(args);
  return resource_table_set_query_plpgsqlPgResource.execute(selectArgs);
};
function Query_tableSetQueryPlpgsql_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_tableSetQueryPlpgsql_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_tableSetQueryPlpgsql_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_tableSetQueryPlpgsql_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_tableSetQueryPlpgsql_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple47 = [];
const makeArgs47 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple47[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_type_function_connectionPgResource = registry.pgResources["type_function_connection"];
const getSelectPlanFromParentAndArgs14 = ($root, args, _info) => {
  const selectArgs = makeArgs47(args);
  return resource_type_function_connectionPgResource.execute(selectArgs);
};
function Query_typeFunctionConnection_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_typeFunctionConnection_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_typeFunctionConnection_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_typeFunctionConnection_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_typeFunctionConnection_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple48 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs48 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple48[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_type_functionPgResource = registry.pgResources["type_function"];
const argDetailsSimple49 = [];
const makeArgs49 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple49[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_type_function_listPgResource = registry.pgResources["type_function_list"];
const resource_non_updatable_viewPgResource = registry.pgResources["non_updatable_view"];
function Query_allNonUpdatableViews_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allNonUpdatableViews_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allNonUpdatableViews_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allNonUpdatableViews_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allNonUpdatableViews_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allInputs_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allInputs_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allInputs_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allInputs_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allInputs_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allPatches_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allPatches_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allPatches_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allPatches_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allPatches_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allReserveds_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allReserveds_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allReserveds_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allReserveds_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allReserveds_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allReservedPatchRecords_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allReservedPatchRecords_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allReservedPatchRecords_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allReservedPatchRecords_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allReservedPatchRecords_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allReservedInputRecords_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allReservedInputRecords_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allReservedInputRecords_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allReservedInputRecords_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allReservedInputRecords_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allDefaultValues_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allDefaultValues_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allDefaultValues_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allDefaultValues_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allDefaultValues_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_foreign_keyPgResource = registry.pgResources["foreign_key"];
function Query_allForeignKeys_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allForeignKeys_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allForeignKeys_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allForeignKeys_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allForeignKeys_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allNoPrimaryKeys_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allNoPrimaryKeys_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allNoPrimaryKeys_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allNoPrimaryKeys_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allNoPrimaryKeys_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_testviewPgResource = registry.pgResources["testview"];
function Query_allTestviews_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allTestviews_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allTestviews_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allTestviews_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allTestviews_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allMyTables_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allMyTables_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allMyTables_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allMyTables_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allMyTables_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allPersonSecrets_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allPersonSecrets_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allPersonSecrets_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allPersonSecrets_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allPersonSecrets_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allViewTables_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allViewTables_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allViewTables_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allViewTables_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allViewTables_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allCompoundKeys_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allCompoundKeys_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allCompoundKeys_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allCompoundKeys_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allCompoundKeys_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allSimilarTable1S_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allSimilarTable1S_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allSimilarTable1S_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allSimilarTable1S_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allSimilarTable1S_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allSimilarTable2S_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allSimilarTable2S_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allSimilarTable2S_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allSimilarTable2S_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allSimilarTable2S_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_updatable_viewPgResource = registry.pgResources["updatable_view"];
function Query_allUpdatableViews_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allUpdatableViews_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allUpdatableViews_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allUpdatableViews_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allUpdatableViews_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allNullTestRecords_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allNullTestRecords_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allNullTestRecords_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allNullTestRecords_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allNullTestRecords_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_edge_casePgResource = registry.pgResources["edge_case"];
function Query_allEdgeCases_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allEdgeCases_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allEdgeCases_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allEdgeCases_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allEdgeCases_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allLeftArms_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allLeftArms_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allLeftArms_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allLeftArms_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allLeftArms_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allIssue756S_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allIssue756S_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allIssue756S_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allIssue756S_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allIssue756S_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allPosts_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allPosts_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allPosts_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allPosts_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allPosts_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allPeople_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allPeople_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allPeople_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allPeople_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allPeople_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Query_allTypes_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Query_allTypes_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Query_allTypes_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Query_allTypes_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Query_allTypes_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function hasRecord($row) {
  return "record" in $row && typeof $row.record === "function";
}
const argDetailsSimple50 = [];
const makeArgs50 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple50[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_computed_outPgResource = registry.pgResources["person_computed_out"];
const argDetailsSimple51 = [];
const makeArgs51 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple51[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_first_namePgResource = registry.pgResources["person_first_name"];
const argDetailsSimple52 = [];
const makeArgs52 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple52[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_computed_out_outPgResource = registry.pgResources["person_computed_out_out"];
const argDetailsSimple53 = [{
  graphqlArgName: "ino",
  postgresArgName: "ino",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs53 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple53[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_computed_inoutPgResource = registry.pgResources["person_computed_inout"];
const argDetailsSimple54 = [{
  graphqlArgName: "ino",
  postgresArgName: "ino",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs54 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple54[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_computed_inout_outPgResource = registry.pgResources["person_computed_inout_out"];
const argDetailsSimple55 = [{
  graphqlArgName: "email",
  postgresArgName: "email",
  pgCodec: attributes_email_codec_email,
  required: true,
  fetcher: null
}];
const makeArgs55 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple55[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_existsPgResource = registry.pgResources["person_exists"];
const argDetailsSimple56 = [];
const makeArgs56 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple56[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_computed_first_arg_inout_outPgResource = registry.pgResources["person_computed_first_arg_inout_out"];
const argDetailsSimple57 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs57 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple57[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_computed_complexPgResource = registry.pgResources["person_computed_complex"];
const argDetailsSimple58 = [];
const makeArgs58 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple58[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_first_postPgResource = registry.pgResources["person_first_post"];
const argDetailsSimple59 = [];
const makeArgs59 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple59[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_computed_first_arg_inoutPgResource = registry.pgResources["person_computed_first_arg_inout"];
const argDetailsSimple60 = [];
const makeArgs60 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple60[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_friendsPgResource = registry.pgResources["person_friends"];
const getSelectPlanFromParentAndArgs15 = ($in, args, _info) => {
  if (!hasRecord($in)) {
    throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
  }
  const extraSelectArgs = makeArgs60(args);
  /**
   * An optimisation - if all our dependencies are
   * compatible with the expression's class plan then we
   * can inline ourselves into that, otherwise we must
   * issue the query separately.
   */
  const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
  const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
  const selectArgs = [{
    step: $row.record()
  }, ...extraSelectArgs];
  if (resource_person_friendsPgResource.isUnique && !resource_person_friendsPgResource.codec.attributes && typeof resource_person_friendsPgResource.from === "function") {
    // This is a scalar computed attribute, let's inline the expression
    const placeholders = selectArgs.map((arg, i) => {
      if (i === 0) {
        return $row.getClassStep().alias;
      } else if ("pgCodec" in arg && arg.pgCodec) {
        return $row.placeholder(arg.step, arg.pgCodec);
      } else {
        return $row.placeholder(arg.step);
      }
    });
    return pgClassExpression($row, resource_person_friendsPgResource.codec)`${resource_person_friendsPgResource.from(...placeholders.map(placeholder => ({
      placeholder
    })))}`;
  }
  // PERF: or here, if scalar add select to `$row`?
  return resource_person_friendsPgResource.execute(selectArgs);
};
function Person_friends_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_friends_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_friends_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_friends_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_friends_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple61 = [];
const makeArgs61 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple61[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_type_function_connectionPgResource = registry.pgResources["person_type_function_connection"];
const getSelectPlanFromParentAndArgs16 = ($in, args, _info) => {
  if (!hasRecord($in)) {
    throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
  }
  const extraSelectArgs = makeArgs61(args);
  /**
   * An optimisation - if all our dependencies are
   * compatible with the expression's class plan then we
   * can inline ourselves into that, otherwise we must
   * issue the query separately.
   */
  const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
  const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
  const selectArgs = [{
    step: $row.record()
  }, ...extraSelectArgs];
  if (resource_person_type_function_connectionPgResource.isUnique && !resource_person_type_function_connectionPgResource.codec.attributes && typeof resource_person_type_function_connectionPgResource.from === "function") {
    // This is a scalar computed attribute, let's inline the expression
    const placeholders = selectArgs.map((arg, i) => {
      if (i === 0) {
        return $row.getClassStep().alias;
      } else if ("pgCodec" in arg && arg.pgCodec) {
        return $row.placeholder(arg.step, arg.pgCodec);
      } else {
        return $row.placeholder(arg.step);
      }
    });
    return pgClassExpression($row, resource_person_type_function_connectionPgResource.codec)`${resource_person_type_function_connectionPgResource.from(...placeholders.map(placeholder => ({
      placeholder
    })))}`;
  }
  // PERF: or here, if scalar add select to `$row`?
  return resource_person_type_function_connectionPgResource.execute(selectArgs);
};
function Person_typeFunctionConnection_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_typeFunctionConnection_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_typeFunctionConnection_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_typeFunctionConnection_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_typeFunctionConnection_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple62 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs62 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple62[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_type_functionPgResource = registry.pgResources["person_type_function"];
const argDetailsSimple63 = [];
const makeArgs63 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple63[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_person_type_function_listPgResource = registry.pgResources["person_type_function_list"];
const resource_frmcdc_wrappedUrlPgResource = registry.pgResources["frmcdc_wrappedUrl"];
function Person_postsByAuthorId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_postsByAuthorId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_postsByAuthorId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_postsByAuthorId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_postsByAuthorId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Person_foreignKeysByPersonId_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_foreignKeysByPersonId_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_foreignKeysByPersonId_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_foreignKeysByPersonId_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_foreignKeysByPersonId_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Person_compoundKeysByPersonId1_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_compoundKeysByPersonId1_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_compoundKeysByPersonId1_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_compoundKeysByPersonId1_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_compoundKeysByPersonId1_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function Person_compoundKeysByPersonId2_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Person_compoundKeysByPersonId2_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Person_compoundKeysByPersonId2_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Person_compoundKeysByPersonId2_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Person_compoundKeysByPersonId2_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const resource_frmcdc_compoundTypePgResource = registry.pgResources["frmcdc_compoundType"];
const argDetailsSimple64 = [];
const makeArgs64 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple64[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_compound_type_computed_fieldPgResource = registry.pgResources["compound_type_computed_field"];
function Interval_secondsPlan($r) {
  return access($r, ["seconds"]);
}
function Interval_minutesPlan($r) {
  return access($r, ["minutes"]);
}
function Interval_hoursPlan($r) {
  return access($r, ["hours"]);
}
function Interval_daysPlan($r) {
  return access($r, ["days"]);
}
function Interval_monthsPlan($r) {
  return access($r, ["months"]);
}
function Interval_yearsPlan($r) {
  return access($r, ["years"]);
}
const argDetailsSimple65 = [];
const makeArgs65 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple65[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_interval_setPgResource = registry.pgResources["post_computed_interval_set"];
const getSelectPlanFromParentAndArgs17 = ($in, args, _info) => {
  if (!hasRecord($in)) {
    throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
  }
  const extraSelectArgs = makeArgs65(args);
  /**
   * An optimisation - if all our dependencies are
   * compatible with the expression's class plan then we
   * can inline ourselves into that, otherwise we must
   * issue the query separately.
   */
  const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
  const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
  const selectArgs = [{
    step: $row.record()
  }, ...extraSelectArgs];
  if (resource_post_computed_interval_setPgResource.isUnique && !resource_post_computed_interval_setPgResource.codec.attributes && typeof resource_post_computed_interval_setPgResource.from === "function") {
    // This is a scalar computed attribute, let's inline the expression
    const placeholders = selectArgs.map((arg, i) => {
      if (i === 0) {
        return $row.getClassStep().alias;
      } else if ("pgCodec" in arg && arg.pgCodec) {
        return $row.placeholder(arg.step, arg.pgCodec);
      } else {
        return $row.placeholder(arg.step);
      }
    });
    return pgClassExpression($row, resource_post_computed_interval_setPgResource.codec)`${resource_post_computed_interval_setPgResource.from(...placeholders.map(placeholder => ({
      placeholder
    })))}`;
  }
  // PERF: or here, if scalar add select to `$row`?
  return resource_post_computed_interval_setPgResource.execute(selectArgs);
};
function Post_computedIntervalSet_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Post_computedIntervalSet_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Post_computedIntervalSet_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Post_computedIntervalSet_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Post_computedIntervalSet_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
const argDetailsSimple66 = [];
const makeArgs66 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple66[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_interval_arrayPgResource = registry.pgResources["post_computed_interval_array"];
const argDetailsSimple67 = [];
const makeArgs67 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple67[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_text_arrayPgResource = registry.pgResources["post_computed_text_array"];
const argDetailsSimple68 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs68 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple68[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_with_optional_argPgResource = registry.pgResources["post_computed_with_optional_arg"];
const argDetailsSimple69 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs69 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple69[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_with_required_argPgResource = registry.pgResources["post_computed_with_required_arg"];
const argDetailsSimple70 = [{
  graphqlArgName: "length",
  postgresArgName: "length",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "omission",
  postgresArgName: "omission",
  pgCodec: TYPES.text,
  required: false,
  fetcher: null
}];
const makeArgs70 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple70[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_headline_trimmedPgResource = registry.pgResources["post_headline_trimmed"];
const argDetailsSimple71 = [{
  graphqlArgName: "length",
  postgresArgName: "length",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "omission",
  postgresArgName: "omission",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs71 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple71[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_headline_trimmed_no_defaultsPgResource = registry.pgResources["post_headline_trimmed_no_defaults"];
const argDetailsSimple72 = [{
  graphqlArgName: "length",
  postgresArgName: "length",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}, {
  graphqlArgName: "omission",
  postgresArgName: "omission",
  pgCodec: TYPES.text,
  required: false,
  fetcher: null
}];
const makeArgs72 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple72[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_headline_trimmed_strictPgResource = registry.pgResources["post_headline_trimmed_strict"];
const argDetailsSimple73 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_compoundType,
  required: true,
  fetcher: null
}];
const makeArgs73 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple73[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_computed_compound_type_arrayPgResource = registry.pgResources["post_computed_compound_type_array"];
const resource_frmcdc_comptypePgResource = registry.pgResources["frmcdc_comptype"];
function Post_typesBySmallint_first_applyPlan(_, $connection, arg) {
  $connection.setFirst(arg.getRaw());
}
function Post_typesBySmallint_last_applyPlan(_, $connection, val) {
  $connection.setLast(val.getRaw());
}
function Post_typesBySmallint_offset_applyPlan(_, $connection, val) {
  $connection.setOffset(val.getRaw());
}
function Post_typesBySmallint_before_applyPlan(_, $connection, val) {
  $connection.setBefore(val.getRaw());
}
function Post_typesBySmallint_after_applyPlan(_, $connection, val) {
  $connection.setAfter(val.getRaw());
}
function PostComputedIntervalSetConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PostComputedIntervalSetConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PostComputedIntervalSetConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PageInfo_hasNextPagePlan($pageInfo) {
  return $pageInfo.hasNextPage();
}
function PageInfo_hasPreviousPagePlan($pageInfo) {
  return $pageInfo.hasPreviousPage();
}
function TypesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function TypesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function TypesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const resource_frmcdc_nestedCompoundTypePgResource = registry.pgResources["frmcdc_nestedCompoundType"];
function PeopleConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PeopleConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PeopleConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PostsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PostsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PostsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ForeignKeysConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ForeignKeysConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ForeignKeysConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CompoundKeysConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CompoundKeysConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CompoundKeysConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function FuncOutSetofConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function FuncOutSetofConnection_edgesPlan($connection) {
  return $connection.edges();
}
function FuncOutSetofConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function QueryIntervalSetConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function QueryIntervalSetConnection_edgesPlan($connection) {
  return $connection.edges();
}
function QueryIntervalSetConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function StaticBigIntegerConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function StaticBigIntegerConnection_edgesPlan($connection) {
  return $connection.edges();
}
function StaticBigIntegerConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function FuncReturnsTableOneColConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function FuncReturnsTableOneColConnection_edgesPlan($connection) {
  return $connection.edges();
}
function FuncReturnsTableOneColConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function FuncOutOutSetofConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function FuncOutOutSetofConnection_edgesPlan($connection) {
  return $connection.edges();
}
function FuncOutOutSetofConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function FuncReturnsTableMultiColConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function FuncReturnsTableMultiColConnection_edgesPlan($connection) {
  return $connection.edges();
}
function FuncReturnsTableMultiColConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function IntSetQueryConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function IntSetQueryConnection_edgesPlan($connection) {
  return $connection.edges();
}
function IntSetQueryConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function CompoundTypesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function CompoundTypesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function CompoundTypesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function FuncOutComplexSetofConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function FuncOutComplexSetofConnection_edgesPlan($connection) {
  return $connection.edges();
}
function FuncOutComplexSetofConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function NonUpdatableViewsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function NonUpdatableViewsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function NonUpdatableViewsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function InputsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function InputsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function InputsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PatchesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PatchesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PatchesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ReservedsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ReservedsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ReservedsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ReservedPatchRecordsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ReservedPatchRecordsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ReservedPatchRecordsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ReservedInputRecordsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ReservedInputRecordsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ReservedInputRecordsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function DefaultValuesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function DefaultValuesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function DefaultValuesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function NoPrimaryKeysConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function NoPrimaryKeysConnection_edgesPlan($connection) {
  return $connection.edges();
}
function NoPrimaryKeysConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function TestviewsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function TestviewsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function TestviewsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function MyTablesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function MyTablesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function MyTablesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function PersonSecretsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function PersonSecretsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function PersonSecretsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function ViewTablesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function ViewTablesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function ViewTablesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function SimilarTable1SConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function SimilarTable1SConnection_edgesPlan($connection) {
  return $connection.edges();
}
function SimilarTable1SConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function SimilarTable2SConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function SimilarTable2SConnection_edgesPlan($connection) {
  return $connection.edges();
}
function SimilarTable2SConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function UpdatableViewsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function UpdatableViewsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function UpdatableViewsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function NullTestRecordsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function NullTestRecordsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function NullTestRecordsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function EdgeCasesConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function EdgeCasesConnection_edgesPlan($connection) {
  return $connection.edges();
}
function EdgeCasesConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const argDetailsSimple74 = [];
const makeArgs74 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple74[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_edge_case_computedPgResource = registry.pgResources["edge_case_computed"];
function LeftArmsConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function LeftArmsConnection_edgesPlan($connection) {
  return $connection.edges();
}
function LeftArmsConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
function Issue756SConnection_nodesPlan($connection) {
  return $connection.nodes();
}
function Issue756SConnection_edgesPlan($connection) {
  return $connection.edges();
}
function Issue756SConnection_pageInfoPlan($connection) {
  // TYPES: why is this a TypeScript issue without the 'any'?
  return $connection.pageInfo();
}
const argDetailsSimple75 = [];
const makeArgs75 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple75[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_outPgResource = registry.pgResources["mutation_out"];
function Mutation_mutationOut_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple76 = [];
const makeArgs76 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple76[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_setofPgResource = registry.pgResources["mutation_out_setof"];
function Mutation_mutationOutSetof_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple77 = [];
const makeArgs77 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple77[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_unnamedPgResource = registry.pgResources["mutation_out_unnamed"];
function Mutation_mutationOutUnnamed_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple78 = [];
const makeArgs78 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple78[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_no_args_mutationPgResource = registry.pgResources["no_args_mutation"];
function Mutation_noArgsMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple79 = [];
const makeArgs79 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple79[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_return_void_mutationPgResource = registry.pgResources["return_void_mutation"];
function Mutation_returnVoidMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple80 = [];
const makeArgs80 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple80[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_interval_setPgResource = registry.pgResources["mutation_interval_set"];
function Mutation_mutationIntervalSet_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple81 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs81 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple81[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_in_outPgResource = registry.pgResources["mutation_in_out"];
function Mutation_mutationInOut_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple82 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs82 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple82[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_returns_table_one_colPgResource = registry.pgResources["mutation_returns_table_one_col"];
function Mutation_mutationReturnsTableOneCol_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple83 = [{
  graphqlArgName: "json",
  postgresArgName: "json",
  pgCodec: TYPES.json,
  required: true,
  fetcher: null
}];
const makeArgs83 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple83[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_json_identity_mutationPgResource = registry.pgResources["json_identity_mutation"];
function Mutation_jsonIdentityMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple84 = [{
  graphqlArgName: "json",
  postgresArgName: "json",
  pgCodec: TYPES.jsonb,
  required: true,
  fetcher: null
}];
const makeArgs84 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple84[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_jsonb_identity_mutationPgResource = registry.pgResources["jsonb_identity_mutation"];
function Mutation_jsonbIdentityMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple85 = [{
  graphqlArgName: "_theJson",
  postgresArgName: "_the_json",
  pgCodec: TYPES.jsonb,
  required: true,
  fetcher: null
}];
const makeArgs85 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple85[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_jsonb_identity_mutation_plpgsqlPgResource = registry.pgResources["jsonb_identity_mutation_plpgsql"];
function Mutation_jsonbIdentityMutationPlpgsql_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple86 = [{
  graphqlArgName: "_theJson",
  postgresArgName: "_the_json",
  pgCodec: TYPES.jsonb,
  required: false,
  fetcher: null
}];
const makeArgs86 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple86[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_jsonb_identity_mutation_plpgsql_with_defaultPgResource = registry.pgResources["jsonb_identity_mutation_plpgsql_with_default"];
function Mutation_jsonbIdentityMutationPlpgsqlWithDefault_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple87 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs87 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple87[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_1_mutationPgResource = registry.pgResources["add_1_mutation"];
function Mutation_add1Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple88 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs88 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple88[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_2_mutationPgResource = registry.pgResources["add_2_mutation"];
function Mutation_add2Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple89 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs89 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple89[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_3_mutationPgResource = registry.pgResources["add_3_mutation"];
function Mutation_add3Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple90 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs90 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple90[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 1 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_4_mutationPgResource = registry.pgResources["add_4_mutation"];
function Mutation_add4Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple91 = [{
  graphqlArgName: "arg0",
  postgresArgName: "",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.int,
  required: false,
  fetcher: null
}];
const makeArgs91 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple91[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 1 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_add_4_mutation_errorPgResource = registry.pgResources["add_4_mutation_error"];
function Mutation_add4MutationError_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple92 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs92 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple92[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mult_1PgResource = registry.pgResources["mult_1"];
function Mutation_mult1_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple93 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs93 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple93[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mult_2PgResource = registry.pgResources["mult_2"];
function Mutation_mult2_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple94 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs94 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple94[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mult_3PgResource = registry.pgResources["mult_3"];
function Mutation_mult3_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple95 = [{
  graphqlArgName: "arg0",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "arg1",
  postgresArgName: null,
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs95 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple95[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 2 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mult_4PgResource = registry.pgResources["mult_4"];
function Mutation_mult4_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple96 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "ino",
  postgresArgName: "ino",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs96 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple96[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_in_inoutPgResource = registry.pgResources["mutation_in_inout"];
function Mutation_mutationInInout_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple97 = [];
const makeArgs97 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple97[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_outPgResource = registry.pgResources["mutation_out_out"];
function Mutation_mutationOutOut_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple98 = [];
const makeArgs98 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple98[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_out_setofPgResource = registry.pgResources["mutation_out_out_setof"];
function Mutation_mutationOutOutSetof_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple99 = [];
const makeArgs99 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple99[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_out_unnamedPgResource = registry.pgResources["mutation_out_out_unnamed"];
function Mutation_mutationOutOutUnnamed_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple100 = [{
  graphqlArgName: "x",
  postgresArgName: "x",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "y",
  postgresArgName: "y",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "z",
  postgresArgName: "z",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs100 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple100[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_int_set_mutationPgResource = registry.pgResources["int_set_mutation"];
function Mutation_intSetMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple101 = [];
const makeArgs101 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple101[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_unnamed_out_out_unnamedPgResource = registry.pgResources["mutation_out_unnamed_out_out_unnamed"];
function Mutation_mutationOutUnnamedOutOutUnnamed_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple102 = [{
  graphqlArgName: "i",
  postgresArgName: "i",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs102 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple102[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_returns_table_multi_colPgResource = registry.pgResources["mutation_returns_table_multi_col"];
function Mutation_mutationReturnsTableMultiCol_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple103 = [{
  graphqlArgName: "g",
  postgresArgName: "g",
  pgCodec: registryConfig_pgCodecs_guid_guid,
  required: true,
  fetcher: null
}];
const makeArgs103 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple103[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_guid_fnPgResource = registry.pgResources["guid_fn"];
function Mutation_guidFn_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple104 = [];
const makeArgs104 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple104[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_interval_arrayPgResource = registry.pgResources["mutation_interval_array"];
function Mutation_mutationIntervalArray_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple105 = [];
const makeArgs105 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple105[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_text_arrayPgResource = registry.pgResources["mutation_text_array"];
function Mutation_mutationTextArray_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple106 = [{
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: registryConfig_pgCodecs_textArray_textArray,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "d",
  postgresArgName: "d",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "e",
  postgresArgName: "e",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs106 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple106[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_list_bde_mutationPgResource = registry.pgResources["list_bde_mutation"];
function Mutation_listBdeMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple107 = [];
const makeArgs107 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple107[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_authenticate_failPgResource = registry.pgResources["authenticate_fail"];
function Mutation_authenticateFail_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple108 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.numeric,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}];
const makeArgs108 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple108[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_authenticatePgResource = registry.pgResources["authenticate"];
function Mutation_authenticate_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple109 = [{
  graphqlArgName: "leftArm",
  postgresArgName: "left_arm",
  pgCodec: registryConfig_pgCodecs_leftArm_leftArm,
  required: true,
  fetcher: null
}];
const makeArgs109 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple109[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_left_arm_identityPgResource = registry.pgResources["left_arm_identity"];
function Mutation_leftArmIdentity_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple110 = [];
const makeArgs110 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple110[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_issue756_mutationPgResource = registry.pgResources["issue756_mutation"];
function Mutation_issue756Mutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple111 = [];
const makeArgs111 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple111[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_issue756_set_mutationPgResource = registry.pgResources["issue756_set_mutation"];
function Mutation_issue756SetMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple112 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.numeric,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}];
const makeArgs112 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple112[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_authenticate_manyPgResource = registry.pgResources["authenticate_many"];
function Mutation_authenticateMany_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple113 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.numeric,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}];
const makeArgs113 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 3; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple113[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_authenticate_payloadPgResource = registry.pgResources["authenticate_payload"];
function Mutation_authenticatePayload_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple114 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.bigint,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.boolean,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "c",
  postgresArgName: "c",
  pgCodec: TYPES.varchar,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "d",
  postgresArgName: "d",
  pgCodec: registryConfig_pgCodecs_int4Array_int4Array,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "e",
  postgresArgName: "e",
  pgCodec: TYPES.json,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "f",
  postgresArgName: "f",
  pgCodec: registryConfig_pgCodecs_floatrange_floatrange,
  required: true,
  fetcher: null
}];
const makeArgs114 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 6; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple114[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_types_mutationPgResource = registry.pgResources["types_mutation"];
function Mutation_typesMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple115 = [{
  graphqlArgName: "i1",
  postgresArgName: "i1",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs115 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple115[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_out_compound_typePgResource = registry.pgResources["mutation_out_out_compound_type"];
function Mutation_mutationOutOutCompoundType_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple116 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_compoundType,
  required: true,
  fetcher: null
}];
const makeArgs116 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple116[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_compound_type_mutationPgResource = registry.pgResources["compound_type_mutation"];
function Mutation_compoundTypeMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple117 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_compoundType,
  required: true,
  fetcher: null
}];
const makeArgs117 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple117[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_compound_type_set_mutationPgResource = registry.pgResources["compound_type_set_mutation"];
function Mutation_compoundTypeSetMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple118 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs118 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple118[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_table_mutationPgResource = registry.pgResources["table_mutation"];
function Mutation_tableMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple119 = [{
  graphqlArgName: "post",
  postgresArgName: "post",
  pgCodec: attributes_post_codec_post,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "suffix",
  postgresArgName: "suffix",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs119 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple119[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_with_suffixPgResource = registry.pgResources["post_with_suffix"];
function Mutation_postWithSuffix_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple120 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_compoundType,
  required: true,
  fetcher: null
}];
const makeArgs120 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple120[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_compound_type_arrayPgResource = registry.pgResources["mutation_compound_type_array"];
function Mutation_mutationCompoundTypeArray_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple121 = [{
  graphqlArgName: "object",
  postgresArgName: "object",
  pgCodec: attributes_o2_codec_compoundType,
  required: true,
  fetcher: null
}];
const makeArgs121 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple121[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_compound_type_array_mutationPgResource = registry.pgResources["compound_type_array_mutation"];
function Mutation_compoundTypeArrayMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple122 = [{
  graphqlArgName: "posts",
  postgresArgName: "posts",
  pgCodec: registryConfig_pgCodecs_postArray_postArray,
  required: true,
  fetcher: null
}];
const makeArgs122 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple122[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_post_manyPgResource = registry.pgResources["post_many"];
function Mutation_postMany_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple123 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs123 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple123[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_complexPgResource = registry.pgResources["mutation_out_complex"];
function Mutation_mutationOutComplex_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple124 = [{
  graphqlArgName: "a",
  postgresArgName: "a",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}, {
  graphqlArgName: "b",
  postgresArgName: "b",
  pgCodec: TYPES.text,
  required: true,
  fetcher: null
}];
const makeArgs124 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 2; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple124[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_complex_setofPgResource = registry.pgResources["mutation_out_complex_setof"];
function Mutation_mutationOutComplexSetof_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple125 = [];
const makeArgs125 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple125[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_tablePgResource = registry.pgResources["mutation_out_table"];
function Mutation_mutationOutTable_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple126 = [];
const makeArgs126 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple126[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_mutation_out_table_setofPgResource = registry.pgResources["mutation_out_table_setof"];
function Mutation_mutationOutTableSetof_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple127 = [];
const makeArgs127 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple127[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_table_set_mutationPgResource = registry.pgResources["table_set_mutation"];
function Mutation_tableSetMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple128 = [];
const makeArgs128 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple128[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_type_function_connection_mutationPgResource = registry.pgResources["type_function_connection_mutation"];
function Mutation_typeFunctionConnectionMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple129 = [{
  graphqlArgName: "id",
  postgresArgName: "id",
  pgCodec: TYPES.int,
  required: true,
  fetcher: null
}];
const makeArgs129 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 1; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple129[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_type_function_mutationPgResource = registry.pgResources["type_function_mutation"];
function Mutation_typeFunctionMutation_input_applyPlan(_, $object) {
  return $object;
}
const argDetailsSimple130 = [];
const makeArgs130 = (args, path = []) => {
  const selectArgs = [];
  let skipped = false;
  for (let i = 0; i < 0; i++) {
    const {
      graphqlArgName,
      postgresArgName,
      pgCodec,
      required,
      fetcher
    } = argDetailsSimple130[i];
    const $raw = args.getRaw([...path, graphqlArgName]);
    let step;
    if ($raw.evalIs(undefined)) {
      if (!required && i >= 0 - 1) {
        skipped = true;
        continue;
      } else {
        step = constant(null);
      }
    } else if (fetcher) {
      step = fetcher(args.get([...path, graphqlArgName])).record();
    } else {
      step = args.get([...path, graphqlArgName]);
    }
    if (skipped) {
      const name = postgresArgName;
      if (!name) {
        throw new Error("GraphileInternalError<6f9e0fbc-6c73-4811-a7cf-c2bc2b3c0946>: This should not be possible since we asserted that allArgsAreNamed");
      }
      selectArgs.push({
        step,
        pgCodec,
        name
      });
    } else {
      selectArgs.push({
        step,
        pgCodec
      });
    }
  }
  return selectArgs;
};
const resource_type_function_list_mutationPgResource = registry.pgResources["type_function_list_mutation"];
function Mutation_typeFunctionListMutation_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createInput_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createPatch_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createReserved_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createReservedPatchRecord_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createReservedInputRecord_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createDefaultValue_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createForeignKey_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createNoPrimaryKey_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createTestview_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createMyTable_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createPersonSecret_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createViewTable_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createCompoundKey_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createSimilarTable1_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createSimilarTable2_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createUpdatableView_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createNullTestRecord_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createEdgeCase_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createLeftArm_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createIssue756_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createPost_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createPerson_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_createType_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateInputById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updatePatchById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateReservedById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateReservedPatchRecordById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateReservedInputRecordById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateDefaultValueById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateNoPrimaryKeyById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateMyTableById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updatePersonSecretByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateViewTableById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateCompoundKeyByPersonId1AndPersonId2_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateSimilarTable1ById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateSimilarTable2ById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateNullTestRecordById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateLeftArmById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateLeftArmByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateIssue756ById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updatePostById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updatePersonById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updatePersonByEmail_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_updateTypeById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteInputById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deletePatchById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteReservedById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteReservedPatchRecordById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteReservedInputRecordById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteDefaultValueById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteNoPrimaryKeyById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteMyTableById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deletePersonSecretByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteViewTableById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteCompoundKeyByPersonId1AndPersonId2_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteSimilarTable1ById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteSimilarTable2ById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteNullTestRecordById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteLeftArmById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteLeftArmByPersonId_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteIssue756ById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deletePostById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deletePersonById_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deletePersonByEmail_input_applyPlan(_, $object) {
  return $object;
}
function Mutation_deleteTypeById_input_applyPlan(_, $object) {
  return $object;
}
function MutationOutPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutPayload_queryPlan() {
  return rootValue();
}
function MutationOutInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutSetofPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutSetofPayload_queryPlan() {
  return rootValue();
}
function MutationOutSetofInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutUnnamedPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutUnnamedPayload_queryPlan() {
  return rootValue();
}
function MutationOutUnnamedInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function NoArgsMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function NoArgsMutationPayload_queryPlan() {
  return rootValue();
}
function NoArgsMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function ReturnVoidMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function ReturnVoidMutationPayload_queryPlan() {
  return rootValue();
}
function ReturnVoidMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationIntervalSetPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationIntervalSetPayload_queryPlan() {
  return rootValue();
}
function MutationIntervalSetInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationInOutPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationInOutPayload_queryPlan() {
  return rootValue();
}
function MutationInOutInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationReturnsTableOneColPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationReturnsTableOneColPayload_queryPlan() {
  return rootValue();
}
function MutationReturnsTableOneColInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function JsonIdentityMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function JsonIdentityMutationPayload_queryPlan() {
  return rootValue();
}
function JsonIdentityMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function JsonbIdentityMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function JsonbIdentityMutationPayload_queryPlan() {
  return rootValue();
}
function JsonbIdentityMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function JsonbIdentityMutationPlpgsqlPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function JsonbIdentityMutationPlpgsqlPayload_queryPlan() {
  return rootValue();
}
function JsonbIdentityMutationPlpgsqlInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function JsonbIdentityMutationPlpgsqlWithDefaultPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function JsonbIdentityMutationPlpgsqlWithDefaultPayload_queryPlan() {
  return rootValue();
}
function JsonbIdentityMutationPlpgsqlWithDefaultInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add1MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add1MutationPayload_queryPlan() {
  return rootValue();
}
function Add1MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add2MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add2MutationPayload_queryPlan() {
  return rootValue();
}
function Add2MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add3MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add3MutationPayload_queryPlan() {
  return rootValue();
}
function Add3MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add4MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add4MutationPayload_queryPlan() {
  return rootValue();
}
function Add4MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Add4MutationErrorPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Add4MutationErrorPayload_queryPlan() {
  return rootValue();
}
function Add4MutationErrorInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Mult1Payload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Mult1Payload_queryPlan() {
  return rootValue();
}
function Mult1Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Mult2Payload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Mult2Payload_queryPlan() {
  return rootValue();
}
function Mult2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Mult3Payload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Mult3Payload_queryPlan() {
  return rootValue();
}
function Mult3Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Mult4Payload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Mult4Payload_queryPlan() {
  return rootValue();
}
function Mult4Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationInInoutPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationInInoutPayload_queryPlan() {
  return rootValue();
}
function MutationInInoutInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutOutPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutOutPayload_queryPlan() {
  return rootValue();
}
function MutationOutOutInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutOutSetofPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutOutSetofPayload_queryPlan() {
  return rootValue();
}
function MutationOutOutSetofInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutOutUnnamedPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutOutUnnamedPayload_queryPlan() {
  return rootValue();
}
function MutationOutOutUnnamedInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function IntSetMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function IntSetMutationPayload_queryPlan() {
  return rootValue();
}
function IntSetMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutUnnamedOutOutUnnamedPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutUnnamedOutOutUnnamedPayload_queryPlan() {
  return rootValue();
}
function MutationOutUnnamedOutOutUnnamedInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationReturnsTableMultiColPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationReturnsTableMultiColPayload_queryPlan() {
  return rootValue();
}
function MutationReturnsTableMultiColInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function GuidFnPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function GuidFnPayload_queryPlan() {
  return rootValue();
}
function GuidFnInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationIntervalArrayPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationIntervalArrayPayload_queryPlan() {
  return rootValue();
}
function MutationIntervalArrayInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationTextArrayPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationTextArrayPayload_queryPlan() {
  return rootValue();
}
function MutationTextArrayInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function ListBdeMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function ListBdeMutationPayload_queryPlan() {
  return rootValue();
}
function ListBdeMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function AuthenticateFailPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function AuthenticateFailPayload_queryPlan() {
  return rootValue();
}
function AuthenticateFailInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function AuthenticatePayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function AuthenticatePayload_queryPlan() {
  return rootValue();
}
function AuthenticateInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function LeftArmIdentityPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function LeftArmIdentityPayload_queryPlan() {
  return rootValue();
}
function LeftArmIdentityInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Issue756MutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Issue756MutationPayload_queryPlan() {
  return rootValue();
}
function Issue756MutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function Issue756SetMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function Issue756SetMutationPayload_queryPlan() {
  return rootValue();
}
function Issue756SetMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function AuthenticateManyPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function AuthenticateManyPayload_queryPlan() {
  return rootValue();
}
function AuthenticateManyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function AuthenticatePayloadPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function AuthenticatePayloadPayload_queryPlan() {
  return rootValue();
}
const resource_frmcdc_jwtTokenPgResource = registry.pgResources["frmcdc_jwtToken"];
function AuthenticatePayloadInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function TypesMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function TypesMutationPayload_queryPlan() {
  return rootValue();
}
function TypesMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutOutCompoundTypePayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutOutCompoundTypePayload_queryPlan() {
  return rootValue();
}
function MutationOutOutCompoundTypeInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CompoundTypeMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CompoundTypeMutationPayload_queryPlan() {
  return rootValue();
}
function CompoundTypeMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CompoundTypeSetMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CompoundTypeSetMutationPayload_queryPlan() {
  return rootValue();
}
function CompoundTypeSetMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function TableMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function TableMutationPayload_queryPlan() {
  return rootValue();
}
function TableMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function PostWithSuffixPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function PostWithSuffixPayload_queryPlan() {
  return rootValue();
}
function PostWithSuffixInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationCompoundTypeArrayPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationCompoundTypeArrayPayload_queryPlan() {
  return rootValue();
}
function MutationCompoundTypeArrayInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CompoundTypeArrayMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function CompoundTypeArrayMutationPayload_queryPlan() {
  return rootValue();
}
function CompoundTypeArrayMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function PostManyPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function PostManyPayload_queryPlan() {
  return rootValue();
}
function PostManyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutComplexPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutComplexPayload_queryPlan() {
  return rootValue();
}
function MutationOutComplexInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutComplexSetofPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutComplexSetofPayload_queryPlan() {
  return rootValue();
}
function MutationOutComplexSetofInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutTablePayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutTablePayload_queryPlan() {
  return rootValue();
}
function MutationOutTableInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function MutationOutTableSetofPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function MutationOutTableSetofPayload_queryPlan() {
  return rootValue();
}
function MutationOutTableSetofInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function TableSetMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function TableSetMutationPayload_queryPlan() {
  return rootValue();
}
function TableSetMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function TypeFunctionConnectionMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function TypeFunctionConnectionMutationPayload_queryPlan() {
  return rootValue();
}
function TypeFunctionConnectionMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function TypeFunctionMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function TypeFunctionMutationPayload_queryPlan() {
  return rootValue();
}
function TypeFunctionMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function TypeFunctionListMutationPayload_clientMutationIdPlan($object) {
  return $object.getStepForKey("clientMutationId", true) ?? constant(undefined);
}
function TypeFunctionListMutationPayload_queryPlan() {
  return rootValue();
}
function TypeFunctionListMutationInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateInputPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateInputPayload_inputPlan($object) {
  return $object.get("result");
}
function CreateInputPayload_queryPlan() {
  return rootValue();
}
function CreateInputInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateInputInput_input_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreatePatchPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreatePatchPayload_patchPlan($object) {
  return $object.get("result");
}
function CreatePatchPayload_queryPlan() {
  return rootValue();
}
function CreatePatchInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreatePatchInput_patch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateReservedPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateReservedPayload_reservedPlan($object) {
  return $object.get("result");
}
function CreateReservedPayload_queryPlan() {
  return rootValue();
}
function CreateReservedInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateReservedInput_reserved_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateReservedPatchRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateReservedPatchRecordPayload_reservedPatchRecordPlan($object) {
  return $object.get("result");
}
function CreateReservedPatchRecordPayload_queryPlan() {
  return rootValue();
}
function CreateReservedPatchRecordInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateReservedPatchRecordInput_reservedPatchRecord_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateReservedInputRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateReservedInputRecordPayload_reservedInputRecordPlan($object) {
  return $object.get("result");
}
function CreateReservedInputRecordPayload_queryPlan() {
  return rootValue();
}
function CreateReservedInputRecordInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateReservedInputRecordInput_reservedInputRecord_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateDefaultValuePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateDefaultValuePayload_defaultValuePlan($object) {
  return $object.get("result");
}
function CreateDefaultValuePayload_queryPlan() {
  return rootValue();
}
function CreateDefaultValueInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateDefaultValueInput_defaultValue_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateForeignKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateForeignKeyPayload_foreignKeyPlan($object) {
  return $object.get("result");
}
function CreateForeignKeyPayload_queryPlan() {
  return rootValue();
}
function CreateForeignKeyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateForeignKeyInput_foreignKey_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateNoPrimaryKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateNoPrimaryKeyPayload_noPrimaryKeyPlan($object) {
  return $object.get("result");
}
function CreateNoPrimaryKeyPayload_queryPlan() {
  return rootValue();
}
function CreateNoPrimaryKeyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateNoPrimaryKeyInput_noPrimaryKey_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateTestviewPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateTestviewPayload_testviewPlan($object) {
  return $object.get("result");
}
function CreateTestviewPayload_queryPlan() {
  return rootValue();
}
function CreateTestviewInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateTestviewInput_testview_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateMyTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateMyTablePayload_myTablePlan($object) {
  return $object.get("result");
}
function CreateMyTablePayload_queryPlan() {
  return rootValue();
}
function CreateMyTableInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateMyTableInput_myTable_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreatePersonSecretPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreatePersonSecretPayload_personSecretPlan($object) {
  return $object.get("result");
}
function CreatePersonSecretPayload_queryPlan() {
  return rootValue();
}
function CreatePersonSecretInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreatePersonSecretInput_personSecret_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateViewTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateViewTablePayload_viewTablePlan($object) {
  return $object.get("result");
}
function CreateViewTablePayload_queryPlan() {
  return rootValue();
}
function CreateViewTableInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateViewTableInput_viewTable_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateCompoundKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateCompoundKeyPayload_compoundKeyPlan($object) {
  return $object.get("result");
}
function CreateCompoundKeyPayload_queryPlan() {
  return rootValue();
}
function CreateCompoundKeyInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateCompoundKeyInput_compoundKey_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateSimilarTable1Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateSimilarTable1Payload_similarTable1Plan($object) {
  return $object.get("result");
}
function CreateSimilarTable1Payload_queryPlan() {
  return rootValue();
}
function CreateSimilarTable1Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateSimilarTable1Input_similarTable1_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateSimilarTable2Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateSimilarTable2Payload_similarTable2Plan($object) {
  return $object.get("result");
}
function CreateSimilarTable2Payload_queryPlan() {
  return rootValue();
}
function CreateSimilarTable2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateSimilarTable2Input_similarTable2_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateUpdatableViewPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateUpdatableViewPayload_updatableViewPlan($object) {
  return $object.get("result");
}
function CreateUpdatableViewPayload_queryPlan() {
  return rootValue();
}
function CreateUpdatableViewInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateUpdatableViewInput_updatableView_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateNullTestRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateNullTestRecordPayload_nullTestRecordPlan($object) {
  return $object.get("result");
}
function CreateNullTestRecordPayload_queryPlan() {
  return rootValue();
}
function CreateNullTestRecordInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateNullTestRecordInput_nullTestRecord_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateEdgeCasePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateEdgeCasePayload_edgeCasePlan($object) {
  return $object.get("result");
}
function CreateEdgeCasePayload_queryPlan() {
  return rootValue();
}
function CreateEdgeCaseInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateEdgeCaseInput_edgeCase_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateLeftArmPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateLeftArmPayload_leftArmPlan($object) {
  return $object.get("result");
}
function CreateLeftArmPayload_queryPlan() {
  return rootValue();
}
function CreateLeftArmInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateLeftArmInput_leftArm_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateIssue756Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateIssue756Payload_issue756Plan($object) {
  return $object.get("result");
}
function CreateIssue756Payload_queryPlan() {
  return rootValue();
}
function CreateIssue756Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateIssue756Input_issue756_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreatePostPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreatePostPayload_postPlan($object) {
  return $object.get("result");
}
function CreatePostPayload_queryPlan() {
  return rootValue();
}
function CreatePostInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreatePostInput_post_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreatePersonPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreatePersonPayload_personPlan($object) {
  return $object.get("result");
}
function CreatePersonPayload_queryPlan() {
  return rootValue();
}
function CreatePersonInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreatePersonInput_person_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function CreateTypePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function CreateTypePayload_typePlan($object) {
  return $object.get("result");
}
function CreateTypePayload_queryPlan() {
  return rootValue();
}
function CreateTypeInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function CreateTypeInput_type_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateInputPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateInputPayload_inputPlan($object) {
  return $object.get("result");
}
function UpdateInputPayload_queryPlan() {
  return rootValue();
}
function UpdateInputByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateInputByIdInput_inputPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePatchPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdatePatchPayload_patchPlan($object) {
  return $object.get("result");
}
function UpdatePatchPayload_queryPlan() {
  return rootValue();
}
function UpdatePatchByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePatchByIdInput_patchPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateReservedPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateReservedPayload_reservedPlan($object) {
  return $object.get("result");
}
function UpdateReservedPayload_queryPlan() {
  return rootValue();
}
function UpdateReservedByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateReservedByIdInput_reservedPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateReservedPatchRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateReservedPatchRecordPayload_reservedPatchRecordPlan($object) {
  return $object.get("result");
}
function UpdateReservedPatchRecordPayload_queryPlan() {
  return rootValue();
}
function UpdateReservedPatchRecordByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateReservedPatchRecordByIdInput_reservedPatchRecordPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateReservedInputRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateReservedInputRecordPayload_reservedInputRecordPlan($object) {
  return $object.get("result");
}
function UpdateReservedInputRecordPayload_queryPlan() {
  return rootValue();
}
function UpdateReservedInputRecordByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateReservedInputRecordByIdInput_reservedInputRecordPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateDefaultValuePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateDefaultValuePayload_defaultValuePlan($object) {
  return $object.get("result");
}
function UpdateDefaultValuePayload_queryPlan() {
  return rootValue();
}
function UpdateDefaultValueByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateDefaultValueByIdInput_defaultValuePatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateNoPrimaryKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateNoPrimaryKeyPayload_noPrimaryKeyPlan($object) {
  return $object.get("result");
}
function UpdateNoPrimaryKeyPayload_queryPlan() {
  return rootValue();
}
function UpdateNoPrimaryKeyByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateNoPrimaryKeyByIdInput_noPrimaryKeyPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateMyTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateMyTablePayload_myTablePlan($object) {
  return $object.get("result");
}
function UpdateMyTablePayload_queryPlan() {
  return rootValue();
}
function UpdateMyTableByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateMyTableByIdInput_myTablePatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePersonSecretPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdatePersonSecretPayload_personSecretPlan($object) {
  return $object.get("result");
}
function UpdatePersonSecretPayload_queryPlan() {
  return rootValue();
}
function UpdatePersonSecretByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePersonSecretByPersonIdInput_personSecretPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateViewTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateViewTablePayload_viewTablePlan($object) {
  return $object.get("result");
}
function UpdateViewTablePayload_queryPlan() {
  return rootValue();
}
function UpdateViewTableByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateViewTableByIdInput_viewTablePatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateCompoundKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateCompoundKeyPayload_compoundKeyPlan($object) {
  return $object.get("result");
}
function UpdateCompoundKeyPayload_queryPlan() {
  return rootValue();
}
function UpdateCompoundKeyByPersonId1AndPersonId2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateCompoundKeyByPersonId1AndPersonId2Input_compoundKeyPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateSimilarTable1Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateSimilarTable1Payload_similarTable1Plan($object) {
  return $object.get("result");
}
function UpdateSimilarTable1Payload_queryPlan() {
  return rootValue();
}
function UpdateSimilarTable1ByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateSimilarTable1ByIdInput_similarTable1Patch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateSimilarTable2Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateSimilarTable2Payload_similarTable2Plan($object) {
  return $object.get("result");
}
function UpdateSimilarTable2Payload_queryPlan() {
  return rootValue();
}
function UpdateSimilarTable2ByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateSimilarTable2ByIdInput_similarTable2Patch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateNullTestRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateNullTestRecordPayload_nullTestRecordPlan($object) {
  return $object.get("result");
}
function UpdateNullTestRecordPayload_queryPlan() {
  return rootValue();
}
function UpdateNullTestRecordByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateNullTestRecordByIdInput_nullTestRecordPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateLeftArmPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateLeftArmPayload_leftArmPlan($object) {
  return $object.get("result");
}
function UpdateLeftArmPayload_queryPlan() {
  return rootValue();
}
function UpdateLeftArmByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateLeftArmByIdInput_leftArmPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateLeftArmByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateLeftArmByPersonIdInput_leftArmPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateIssue756Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateIssue756Payload_issue756Plan($object) {
  return $object.get("result");
}
function UpdateIssue756Payload_queryPlan() {
  return rootValue();
}
function UpdateIssue756ByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateIssue756ByIdInput_issue756Patch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePostPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdatePostPayload_postPlan($object) {
  return $object.get("result");
}
function UpdatePostPayload_queryPlan() {
  return rootValue();
}
function UpdatePostByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePostByIdInput_postPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePersonPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdatePersonPayload_personPlan($object) {
  return $object.get("result");
}
function UpdatePersonPayload_queryPlan() {
  return rootValue();
}
function UpdatePersonByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePersonByIdInput_personPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdatePersonByEmailInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdatePersonByEmailInput_personPatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function UpdateTypePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function UpdateTypePayload_typePlan($object) {
  return $object.get("result");
}
function UpdateTypePayload_queryPlan() {
  return rootValue();
}
function UpdateTypeByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function UpdateTypeByIdInput_typePatch_applyPlan($object) {
  const $record = $object.getStepForKey("result");
  return $record.setPlan();
}
function DeleteInputPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteInputPayload_inputPlan($object) {
  return $object.get("result");
}
function DeleteInputPayload_queryPlan() {
  return rootValue();
}
function DeleteInputByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePatchPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeletePatchPayload_patchPlan($object) {
  return $object.get("result");
}
function DeletePatchPayload_queryPlan() {
  return rootValue();
}
function DeletePatchByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteReservedPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteReservedPayload_reservedPlan($object) {
  return $object.get("result");
}
function DeleteReservedPayload_queryPlan() {
  return rootValue();
}
function DeleteReservedByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteReservedPatchRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteReservedPatchRecordPayload_reservedPatchRecordPlan($object) {
  return $object.get("result");
}
function DeleteReservedPatchRecordPayload_queryPlan() {
  return rootValue();
}
function DeleteReservedPatchRecordByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteReservedInputRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteReservedInputRecordPayload_reservedInputRecordPlan($object) {
  return $object.get("result");
}
function DeleteReservedInputRecordPayload_queryPlan() {
  return rootValue();
}
function DeleteReservedInputRecordByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteDefaultValuePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteDefaultValuePayload_defaultValuePlan($object) {
  return $object.get("result");
}
function DeleteDefaultValuePayload_queryPlan() {
  return rootValue();
}
function DeleteDefaultValueByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteNoPrimaryKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteNoPrimaryKeyPayload_noPrimaryKeyPlan($object) {
  return $object.get("result");
}
function DeleteNoPrimaryKeyPayload_queryPlan() {
  return rootValue();
}
function DeleteNoPrimaryKeyByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteMyTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteMyTablePayload_myTablePlan($object) {
  return $object.get("result");
}
function DeleteMyTablePayload_queryPlan() {
  return rootValue();
}
function DeleteMyTableByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePersonSecretPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeletePersonSecretPayload_personSecretPlan($object) {
  return $object.get("result");
}
function DeletePersonSecretPayload_queryPlan() {
  return rootValue();
}
function DeletePersonSecretByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteViewTablePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteViewTablePayload_viewTablePlan($object) {
  return $object.get("result");
}
function DeleteViewTablePayload_queryPlan() {
  return rootValue();
}
function DeleteViewTableByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteCompoundKeyPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteCompoundKeyPayload_compoundKeyPlan($object) {
  return $object.get("result");
}
function DeleteCompoundKeyPayload_queryPlan() {
  return rootValue();
}
function DeleteCompoundKeyByPersonId1AndPersonId2Input_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteSimilarTable1Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteSimilarTable1Payload_similarTable1Plan($object) {
  return $object.get("result");
}
function DeleteSimilarTable1Payload_queryPlan() {
  return rootValue();
}
function DeleteSimilarTable1ByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteSimilarTable2Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteSimilarTable2Payload_similarTable2Plan($object) {
  return $object.get("result");
}
function DeleteSimilarTable2Payload_queryPlan() {
  return rootValue();
}
function DeleteSimilarTable2ByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteNullTestRecordPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteNullTestRecordPayload_nullTestRecordPlan($object) {
  return $object.get("result");
}
function DeleteNullTestRecordPayload_queryPlan() {
  return rootValue();
}
function DeleteNullTestRecordByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteLeftArmPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteLeftArmPayload_leftArmPlan($object) {
  return $object.get("result");
}
function DeleteLeftArmPayload_queryPlan() {
  return rootValue();
}
function DeleteLeftArmByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteLeftArmByPersonIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteIssue756Payload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteIssue756Payload_issue756Plan($object) {
  return $object.get("result");
}
function DeleteIssue756Payload_queryPlan() {
  return rootValue();
}
function DeleteIssue756ByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePostPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeletePostPayload_postPlan($object) {
  return $object.get("result");
}
function DeletePostPayload_queryPlan() {
  return rootValue();
}
function DeletePostByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePersonPayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeletePersonPayload_personPlan($object) {
  return $object.get("result");
}
function DeletePersonPayload_queryPlan() {
  return rootValue();
}
function DeletePersonByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeletePersonByEmailInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
function DeleteTypePayload_clientMutationIdPlan($mutation) {
  return $mutation.getStepForKey("clientMutationId", true) ?? constant(null);
}
function DeleteTypePayload_typePlan($object) {
  return $object.get("result");
}
function DeleteTypePayload_queryPlan() {
  return rootValue();
}
function DeleteTypeByIdInput_clientMutationId_applyPlan($input, val) {
  $input.set("clientMutationId", val.get());
}
export const typeDefs = /* GraphQL */`"""The root query type which gives access points into the data universe."""
type Query {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """Get a single \`Input\`."""
  inputById(id: Int!): Input

  """Get a single \`Patch\`."""
  patchById(id: Int!): Patch

  """Get a single \`Reserved\`."""
  reservedById(id: Int!): Reserved

  """Get a single \`ReservedPatchRecord\`."""
  reservedPatchRecordById(id: Int!): ReservedPatchRecord

  """Get a single \`ReservedInputRecord\`."""
  reservedInputRecordById(id: Int!): ReservedInputRecord

  """Get a single \`DefaultValue\`."""
  defaultValueById(id: Int!): DefaultValue

  """Get a single \`NoPrimaryKey\`."""
  noPrimaryKeyById(id: Int!): NoPrimaryKey

  """Get a single \`UniqueForeignKey\`."""
  uniqueForeignKeyByCompoundKey1AndCompoundKey2(compoundKey1: Int!, compoundKey2: Int!): UniqueForeignKey

  """Get a single \`MyTable\`."""
  myTableById(id: Int!): MyTable

  """Get a single \`PersonSecret\`."""
  personSecretByPersonId(personId: Int!): PersonSecret @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Get a single \`ViewTable\`."""
  viewTableById(id: Int!): ViewTable

  """Get a single \`CompoundKey\`."""
  compoundKeyByPersonId1AndPersonId2(personId1: Int!, personId2: Int!): CompoundKey

  """Get a single \`SimilarTable1\`."""
  similarTable1ById(id: Int!): SimilarTable1

  """Get a single \`SimilarTable2\`."""
  similarTable2ById(id: Int!): SimilarTable2

  """Get a single \`NullTestRecord\`."""
  nullTestRecordById(id: Int!): NullTestRecord

  """Get a single \`LeftArm\`."""
  leftArmById(id: Int!): LeftArm

  """Get a single \`LeftArm\`."""
  leftArmByPersonId(personId: Int!): LeftArm

  """Get a single \`Issue756\`."""
  issue756ById(id: Int!): Issue756

  """Get a single \`Post\`."""
  postById(id: Int!): Post

  """Get a single \`Person\`."""
  personById(id: Int!): Person

  """Get a single \`Person\`."""
  personByEmail(email: Email!): Person

  """Get a single \`Type\`."""
  typeById(id: Int!): Type
  currentUserId: Int
  funcOut: Int

  """Reads and enables pagination through a set of \`Int4\`."""
  funcOutSetof(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): FuncOutSetofConnection
  funcOutUnnamed: Int
  noArgsQuery: Int

  """Reads and enables pagination through a set of \`Interval\`."""
  queryIntervalSet(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): QueryIntervalSetConnection

  """Reads and enables pagination through a set of \`Int8\`."""
  staticBigInteger(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): StaticBigIntegerConnection
  funcInOut(i: Int): Int

  """Reads and enables pagination through a set of \`Int4\`."""
  funcReturnsTableOneCol(
    i: Int

    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): FuncReturnsTableOneColConnection
  jsonIdentity(json: JSON): JSON
  jsonbIdentity(json: JSON): JSON

  """lol, add some stuff 1 query"""
  add1Query(arg0: Int!, arg1: Int!): Int

  """lol, add some stuff 2 query"""
  add2Query(a: Int!, b: Int): Int

  """lol, add some stuff 3 query"""
  add3Query(a: Int, arg1: Int): Int

  """lol, add some stuff 4 query"""
  add4Query(arg0: Int, b: Int): Int
  funcInInout(i: Int, ino: Int): Int
  funcOutOut: FuncOutOutRecord

  """Reads and enables pagination through a set of \`FuncOutOutSetofRecord\`."""
  funcOutOutSetof(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): FuncOutOutSetofConnection
  funcOutOutUnnamed: FuncOutOutUnnamedRecord
  searchTestSummariesList(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Skip the first \`n\` values."""
    offset: Int
  ): [SearchTestSummariesRecord]
  optionalMissingMiddle1(arg0: Int!, b: Int, c: Int): Int
  optionalMissingMiddle2(a: Int!, b: Int, c: Int): Int
  optionalMissingMiddle3(a: Int!, arg1: Int, c: Int): Int
  optionalMissingMiddle4(arg0: Int!, b: Int, arg2: Int): Int
  optionalMissingMiddle5(a: Int!, arg1: Int, arg2: Int): Int
  funcOutUnnamedOutOutUnnamed: FuncOutUnnamedOutOutUnnamedRecord

  """
  Reads and enables pagination through a set of \`FuncReturnsTableMultiColRecord\`.
  """
  funcReturnsTableMultiCol(
    i: Int

    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): FuncReturnsTableMultiColConnection

  """Reads and enables pagination through a set of \`Int4\`."""
  intSetQuery(
    x: Int
    y: Int
    z: Int

    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): IntSetQueryConnection
  queryIntervalArray: [Interval]
  queryTextArray: [String]
  returnTableWithoutGrants: CompoundKey
  typesQuery(a: BigInt!, b: Boolean!, c: String!, d: [Int]!, e: JSON!, f: FloatRangeInput!): Boolean
  funcOutOutCompoundType(i1: Int): FuncOutOutCompoundTypeRecord
  queryOutputTwoRows(leftArmId: Int, postId: Int, txt: String): QueryOutputTwoRowsRecord

  """Reads and enables pagination through a set of \`CompoundType\`."""
  compoundTypeSetQuery(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): CompoundTypesConnection
  compoundTypeQuery(object: CompoundTypeInput): CompoundType
  tableQuery(id: Int): Post
  queryCompoundTypeArray(object: CompoundTypeInput): [CompoundType]
  compoundTypeArrayQuery(object: CompoundTypeInput): [CompoundType]
  funcOutComplex(a: Int, b: String): FuncOutComplexRecord

  """
  Reads and enables pagination through a set of \`FuncOutComplexSetofRecord\`.
  """
  funcOutComplexSetof(
    a: Int
    b: String

    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): FuncOutComplexSetofConnection

  """Reads and enables pagination through a set of \`Person\`."""
  badlyBehavedFunction(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): PeopleConnection @deprecated(reason: "This is deprecated (comment on function c.badly_behaved_function).")
  funcOutTable: Person

  """Reads and enables pagination through a set of \`Person\`."""
  funcOutTableSetof(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): PeopleConnection

  """Reads and enables pagination through a set of \`Person\`."""
  tableSetQuery(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonCondition
  ): PeopleConnection

  """Reads and enables pagination through a set of \`Person\`."""
  tableSetQueryPlpgsql(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): PeopleConnection

  """Reads and enables pagination through a set of \`Type\`."""
  typeFunctionConnection(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): TypesConnection
  typeFunction(id: Int): Type
  typeFunctionList: [Type]

  """Reads and enables pagination through a set of \`NonUpdatableView\`."""
  allNonUpdatableViews(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`NonUpdatableView\`."""
    orderBy: [NonUpdatableViewsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NonUpdatableViewCondition
  ): NonUpdatableViewsConnection

  """Reads and enables pagination through a set of \`Input\`."""
  allInputs(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Input\`."""
    orderBy: [InputsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InputCondition
  ): InputsConnection

  """Reads and enables pagination through a set of \`Patch\`."""
  allPatches(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Patch\`."""
    orderBy: [PatchesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PatchCondition
  ): PatchesConnection

  """Reads and enables pagination through a set of \`Reserved\`."""
  allReserveds(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Reserved\`."""
    orderBy: [ReservedsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReservedCondition
  ): ReservedsConnection

  """Reads and enables pagination through a set of \`ReservedPatchRecord\`."""
  allReservedPatchRecords(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ReservedPatchRecord\`."""
    orderBy: [ReservedPatchRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReservedPatchRecordCondition
  ): ReservedPatchRecordsConnection

  """Reads and enables pagination through a set of \`ReservedInputRecord\`."""
  allReservedInputRecords(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ReservedInputRecord\`."""
    orderBy: [ReservedInputRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReservedInputRecordCondition
  ): ReservedInputRecordsConnection

  """Reads and enables pagination through a set of \`DefaultValue\`."""
  allDefaultValues(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`DefaultValue\`."""
    orderBy: [DefaultValuesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefaultValueCondition
  ): DefaultValuesConnection

  """Reads and enables pagination through a set of \`ForeignKey\`."""
  allForeignKeys(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ForeignKey\`."""
    orderBy: [ForeignKeysOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ForeignKeyCondition
  ): ForeignKeysConnection

  """Reads and enables pagination through a set of \`NoPrimaryKey\`."""
  allNoPrimaryKeys(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`NoPrimaryKey\`."""
    orderBy: [NoPrimaryKeysOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NoPrimaryKeyCondition
  ): NoPrimaryKeysConnection

  """Reads and enables pagination through a set of \`Testview\`."""
  allTestviews(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Testview\`."""
    orderBy: [TestviewsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TestviewCondition
  ): TestviewsConnection

  """Reads and enables pagination through a set of \`MyTable\`."""
  allMyTables(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`MyTable\`."""
    orderBy: [MyTablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MyTableCondition
  ): MyTablesConnection

  """Reads and enables pagination through a set of \`PersonSecret\`."""
  allPersonSecrets(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`PersonSecret\`."""
    orderBy: [PersonSecretsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonSecretCondition
  ): PersonSecretsConnection @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Reads and enables pagination through a set of \`ViewTable\`."""
  allViewTables(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ViewTable\`."""
    orderBy: [ViewTablesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ViewTableCondition
  ): ViewTablesConnection

  """Reads and enables pagination through a set of \`CompoundKey\`."""
  allCompoundKeys(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CompoundKey\`."""
    orderBy: [CompoundKeysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompoundKeyCondition
  ): CompoundKeysConnection

  """Reads and enables pagination through a set of \`SimilarTable1\`."""
  allSimilarTable1S(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SimilarTable1\`."""
    orderBy: [SimilarTable1SOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SimilarTable1Condition
  ): SimilarTable1SConnection

  """Reads and enables pagination through a set of \`SimilarTable2\`."""
  allSimilarTable2S(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`SimilarTable2\`."""
    orderBy: [SimilarTable2SOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SimilarTable2Condition
  ): SimilarTable2SConnection

  """Reads and enables pagination through a set of \`UpdatableView\`."""
  allUpdatableViews(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`UpdatableView\`."""
    orderBy: [UpdatableViewsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UpdatableViewCondition
  ): UpdatableViewsConnection

  """Reads and enables pagination through a set of \`NullTestRecord\`."""
  allNullTestRecords(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`NullTestRecord\`."""
    orderBy: [NullTestRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NullTestRecordCondition
  ): NullTestRecordsConnection

  """Reads and enables pagination through a set of \`EdgeCase\`."""
  allEdgeCases(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`EdgeCase\`."""
    orderBy: [EdgeCasesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EdgeCaseCondition
  ): EdgeCasesConnection

  """Reads and enables pagination through a set of \`LeftArm\`."""
  allLeftArms(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`LeftArm\`."""
    orderBy: [LeftArmsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LeftArmCondition
  ): LeftArmsConnection

  """Reads and enables pagination through a set of \`Issue756\`."""
  allIssue756S(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Issue756\`."""
    orderBy: [Issue756SOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: Issue756Condition
  ): Issue756SConnection

  """Reads and enables pagination through a set of \`Post\`."""
  allPosts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Post\`."""
    orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition
  ): PostsConnection

  """Reads and enables pagination through a set of \`Person\`."""
  allPeople(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonCondition
  ): PeopleConnection

  """Reads and enables pagination through a set of \`Type\`."""
  allTypes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Type\`."""
    orderBy: [TypesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TypeCondition
  ): TypesConnection
}

"""Should output as Input"""
type Input {
  id: Int!
}

"""Should output as Patch"""
type Patch {
  id: Int!
}

type Reserved {
  id: Int!
}

"""
\`reservedPatchs\` table should get renamed to ReservedPatchRecord to prevent clashes with ReservedPatch from \`reserved\` table
"""
type ReservedPatchRecord {
  id: Int!
}

"""
\`reserved_input\` table should get renamed to ReservedInputRecord to prevent clashes with ReservedInput from \`reserved\` table
"""
type ReservedInputRecord {
  id: Int!
}

type DefaultValue {
  id: Int!
  nullValue: String
}

type NoPrimaryKey {
  id: Int!
  str: String!
}

type UniqueForeignKey {
  compoundKey1: Int
  compoundKey2: Int

  """
  Reads a single \`CompoundKey\` that is related to this \`UniqueForeignKey\`.
  """
  compoundKeyByCompoundKey1AndCompoundKey2: CompoundKey
}

type CompoundKey {
  personId2: Int!
  personId1: Int!
  extra: Boolean

  """Reads a single \`Person\` that is related to this \`CompoundKey\`."""
  personByPersonId1: Person

  """Reads a single \`Person\` that is related to this \`CompoundKey\`."""
  personByPersonId2: Person

  """Reads and enables pagination through a set of \`ForeignKey\`."""
  foreignKeysByCompoundKey1AndCompoundKey2(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ForeignKey\`."""
    orderBy: [ForeignKeysOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ForeignKeyCondition
  ): ForeignKeysConnection!

  """
  Reads a single \`UniqueForeignKey\` that is related to this \`CompoundKey\`.
  """
  uniqueForeignKeyByCompoundKey1AndCompoundKey2: UniqueForeignKey
}

"""Person test comment"""
type Person {
  computedOut: String!

  """The first name of the person."""
  firstName: String
  computedOutOut: PersonComputedOutOutRecord
  computedInout(ino: String): String
  computedInoutOut(ino: String): PersonComputedInoutOutRecord
  exists(email: Email): Boolean @deprecated(reason: "This is deprecated (comment on function c.person_exists).")
  computedFirstArgInoutOut: PersonComputedFirstArgInoutOutRecord
  computedComplex(a: Int, b: String): PersonComputedComplexRecord

  """The first post by the person."""
  firstPost: Post
  computedFirstArgInout: Person

  """Reads and enables pagination through a set of \`Person\`."""
  friends(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!]
  ): PeopleConnection!

  """Reads and enables pagination through a set of \`Type\`."""
  typeFunctionConnection(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): TypesConnection!
  typeFunction(id: Int): Type
  typeFunctionList: [Type]

  """The primary unique identifier for the person"""
  id: Int!

  """The persons name"""
  name: String!
  aliases: [String]!
  about: String
  email: Email!
  site: WrappedUrl @deprecated(reason: "Dont use me")
  config: KeyValueHash
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: String
  userMac: String
  createdAt: Datetime

  """Reads and enables pagination through a set of \`Post\`."""
  postsByAuthorId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Post\`."""
    orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition
  ): PostsConnection!

  """Reads and enables pagination through a set of \`ForeignKey\`."""
  foreignKeysByPersonId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`ForeignKey\`."""
    orderBy: [ForeignKeysOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ForeignKeyCondition
  ): ForeignKeysConnection!

  """This \`Person\`'s \`PersonSecret\`."""
  personSecretByPersonId: PersonSecret @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Reads a single \`LeftArm\` that is related to this \`Person\`."""
  leftArmByPersonId: LeftArm

  """Reads and enables pagination through a set of \`CompoundKey\`."""
  compoundKeysByPersonId1(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CompoundKey\`."""
    orderBy: [CompoundKeysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompoundKeyCondition
  ): CompoundKeysConnection!

  """Reads and enables pagination through a set of \`CompoundKey\`."""
  compoundKeysByPersonId2(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`CompoundKey\`."""
    orderBy: [CompoundKeysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompoundKeyCondition
  ): CompoundKeysConnection!
}

type PersonComputedOutOutRecord {
  o1: String
  o2: String
}

type PersonComputedInoutOutRecord {
  ino: String
  o: String
}

scalar Email

type PersonComputedFirstArgInoutOutRecord {
  person: Person
  o: Int
}

type PersonComputedComplexRecord {
  x: Int
  y: CompoundType
  z: Person
}

"""Awesome feature!"""
type CompoundType {
  computedField: Int
  a: Int
  b: String
  c: Color
  d: UUID
  e: EnumCaps
  f: EnumWithEmptyString
  g: Interval
  fooBar: Int
}

enum Color {
  RED
  GREEN
  BLUE
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

enum EnumCaps {
  FOO_BAR
  BAR_FOO
  BAZ_QUX
  _0_BAR
}

enum EnumWithEmptyString {
  _EMPTY_
  ONE
  TWO
}

"""
An interval of time that has passed where the smallest distinct unit is a second.
"""
type Interval {
  """
  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals dont
  have a smaller unit than seconds.
  """
  seconds: Float

  """A quantity of minutes."""
  minutes: Int

  """A quantity of hours."""
  hours: Int

  """A quantity of days."""
  days: Int

  """A quantity of months."""
  months: Int

  """A quantity of years."""
  years: Int
}

type Post {
  """Reads and enables pagination through a set of \`Interval\`."""
  computedIntervalSet(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): PostComputedIntervalSetConnection!
  computedIntervalArray: [Interval]
  computedTextArray: [String]
  computedWithOptionalArg(i: Int): Int
  computedWithRequiredArg(i: Int!): Int
  headlineTrimmed(length: Int, omission: String): String
  headlineTrimmedNoDefaults(length: Int, omission: String): String
  headlineTrimmedStrict(length: Int, omission: String): String
  computedCompoundTypeArray(object: CompoundTypeInput): [CompoundType]
  id: Int!
  headline: String!
  body: String
  authorId: Int
  enums: [AnEnum]
  comptypes: [Comptype]

  """Reads a single \`Person\` that is related to this \`Post\`."""
  personByAuthorId: Person

  """Reads and enables pagination through a set of \`Type\`."""
  typesBySmallint(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Type\`."""
    orderBy: [TypesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TypeCondition
  ): TypesConnection!

  """Reads a single \`Type\` that is related to this \`Post\`."""
  typeById: Type
}

"""A connection to a list of \`Interval\` values."""
type PostComputedIntervalSetConnection {
  """A list of \`Interval\` objects."""
  nodes: [Interval]!

  """
  A list of edges which contains the \`Interval\` and cursor to aid in pagination.
  """
  edges: [PostComputedIntervalSetEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Interval\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Interval\` edge in the connection."""
type PostComputedIntervalSetEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Interval\` at the end of the edge."""
  node: Interval
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""An input for mutations affecting \`CompoundType\`"""
input CompoundTypeInput {
  a: Int
  b: String
  c: Color
  d: UUID
  e: EnumCaps
  f: EnumWithEmptyString
  g: IntervalInput
  fooBar: Int
}

"""
An interval of time that has passed where the smallest distinct unit is a second.
"""
input IntervalInput {
  """
  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals dont
  have a smaller unit than seconds.
  """
  seconds: Float

  """A quantity of minutes."""
  minutes: Int

  """A quantity of hours."""
  hours: Int

  """A quantity of days."""
  days: Int

  """A quantity of months."""
  months: Int

  """A quantity of years."""
  years: Int
}

enum AnEnum {
  AWAITING
  REJECTED
  PUBLISHED
  ASTERISK
  ASTERISK_ASTERISK
  ASTERISK_ASTERISK_ASTERISK
  FOO_ASTERISK
  FOO_ASTERISK_
  _FOO_ASTERISK
  ASTERISK_BAR
  ASTERISK_BAR_
  _ASTERISK_BAR_
  ASTERISK_BAZ_ASTERISK
  _ASTERISK_BAZ_ASTERISK_
  PERCENT
  GREATER_THAN_OR_EQUAL
  LIKE
  DOLLAR
}

type Comptype {
  schedule: Datetime
  isOptimised: Boolean
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
to unexpected results.
"""
scalar Datetime

"""A connection to a list of \`Type\` values."""
type TypesConnection {
  """A list of \`Type\` objects."""
  nodes: [Type]!

  """
  A list of edges which contains the \`Type\` and cursor to aid in pagination.
  """
  edges: [TypesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Type\` you could get from the connection."""
  totalCount: Int!
}

type Type {
  id: Int!
  smallint: Int!
  bigint: BigInt!
  numeric: BigFloat!
  decimal: BigFloat!
  boolean: Boolean!
  varchar: String!
  enum: Color!
  enumArray: [Color]!
  domain: AnInt!
  domain2: AnotherInt!
  textArray: [String]!
  json: JSON!
  jsonb: JSON!
  nullableRange: BigFloatRange
  numrange: BigFloatRange!
  daterange: DateRange!
  anIntRange: AnIntRange!
  timestamp: Datetime!
  timestamptz: Datetime!
  date: Date!
  time: Time!
  timetz: Time!
  interval: Interval!
  intervalArray: [Interval]!
  money: Float!
  compoundType: CompoundType!
  nestedCompoundType: NestedCompoundType!
  nullableCompoundType: CompoundType
  nullableNestedCompoundType: NestedCompoundType
  point: Point!
  nullablePoint: Point
  inet: InternetAddress
  cidr: String
  macaddr: String
  regproc: RegProc
  regprocedure: RegProcedure
  regoper: RegOper
  regoperator: RegOperator
  regclass: RegClass
  regtype: RegType
  regconfig: RegConfig
  regdictionary: RegDictionary
  textArrayDomain: [String]
  int8ArrayDomain: [BigInt]
  bytea: Base64EncodedBinary
  byteaArray: [Base64EncodedBinary]
  ltree: LTree
  ltreeArray: [LTree]

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postBySmallint: Post

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postById: Post
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

scalar AnInt

scalar AnotherInt

"""
A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""A range of \`BigFloat\`."""
type BigFloatRange {
  """The starting bound of our range."""
  start: BigFloatRangeBound

  """The ending bound of our range."""
  end: BigFloatRangeBound
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
type BigFloatRangeBound {
  """The value at one end of our range."""
  value: BigFloat!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""A range of \`Date\`."""
type DateRange {
  """The starting bound of our range."""
  start: DateRangeBound

  """The ending bound of our range."""
  end: DateRangeBound
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
type DateRangeBound {
  """The value at one end of our range."""
  value: Date!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""A calendar date in YYYY-MM-DD format."""
scalar Date

"""A range of \`AnInt\`."""
type AnIntRange {
  """The starting bound of our range."""
  start: AnIntRangeBound

  """The ending bound of our range."""
  end: AnIntRangeBound
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
type AnIntRangeBound {
  """The value at one end of our range."""
  value: AnInt!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""
The exact time of day, does not include the date. May or may not have a timezone offset.
"""
scalar Time

type NestedCompoundType {
  a: CompoundType
  b: CompoundType
  bazBuz: Int
}

"""A cartesian point."""
type Point {
  x: Float!
  y: Float!
}

"""An IPv4 or IPv6 host address, and optionally its subnet."""
scalar InternetAddress

"""A builtin object identifier type for a function name"""
scalar RegProc

"""A builtin object identifier type for a function with argument types"""
scalar RegProcedure

"""A builtin object identifier type for an operator"""
scalar RegOper

"""A builtin object identifier type for an operator with argument types"""
scalar RegOperator

"""A builtin object identifier type for a relation name"""
scalar RegClass

"""A builtin object identifier type for a data type name"""
scalar RegType

"""A builtin object identifier type for a text search configuration"""
scalar RegConfig

"""A builtin object identifier type for a text search dictionary"""
scalar RegDictionary

"""Binary data encoded using Base64"""
scalar Base64EncodedBinary

"""
Represents an \`ltree\` hierarchical label tree as outlined in https://www.postgresql.org/docs/current/ltree.html
"""
scalar LTree

"""A \`Type\` edge in the connection."""
type TypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Type\` at the end of the edge."""
  node: Type
}

"""Methods to use when ordering \`Type\`."""
enum TypesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  SMALLINT_ASC
  SMALLINT_DESC
  BIGINT_ASC
  BIGINT_DESC
  NUMERIC_ASC
  NUMERIC_DESC
  DECIMAL_ASC
  DECIMAL_DESC
  BOOLEAN_ASC
  BOOLEAN_DESC
  VARCHAR_ASC
  VARCHAR_DESC
  ENUM_ASC
  ENUM_DESC
  DOMAIN_ASC
  DOMAIN_DESC
  DOMAIN2_ASC
  DOMAIN2_DESC
  JSON_ASC
  JSON_DESC
  JSONB_ASC
  JSONB_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  TIMESTAMPTZ_ASC
  TIMESTAMPTZ_DESC
  DATE_ASC
  DATE_DESC
  TIME_ASC
  TIME_DESC
  TIMETZ_ASC
  TIMETZ_DESC
  INTERVAL_ASC
  INTERVAL_DESC
  MONEY_ASC
  MONEY_DESC
  COMPOUND_TYPE_ASC
  COMPOUND_TYPE_DESC
  NESTED_COMPOUND_TYPE_ASC
  NESTED_COMPOUND_TYPE_DESC
  NULLABLE_COMPOUND_TYPE_ASC
  NULLABLE_COMPOUND_TYPE_DESC
  NULLABLE_NESTED_COMPOUND_TYPE_ASC
  NULLABLE_NESTED_COMPOUND_TYPE_DESC
  POINT_ASC
  POINT_DESC
  NULLABLE_POINT_ASC
  NULLABLE_POINT_DESC
  INET_ASC
  INET_DESC
  CIDR_ASC
  CIDR_DESC
  MACADDR_ASC
  MACADDR_DESC
  REGPROC_ASC
  REGPROC_DESC
  REGPROCEDURE_ASC
  REGPROCEDURE_DESC
  REGOPER_ASC
  REGOPER_DESC
  REGOPERATOR_ASC
  REGOPERATOR_DESC
  REGCLASS_ASC
  REGCLASS_DESC
  REGTYPE_ASC
  REGTYPE_DESC
  REGCONFIG_ASC
  REGCONFIG_DESC
  REGDICTIONARY_ASC
  REGDICTIONARY_DESC
  LTREE_ASC
  LTREE_DESC
}

"""
A condition to be used against \`Type\` object types. All fields are tested for equality and combined with a logical and.
"""
input TypeCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`smallint\` field."""
  smallint: Int

  """Checks for equality with the objects \`bigint\` field."""
  bigint: BigInt

  """Checks for equality with the objects \`numeric\` field."""
  numeric: BigFloat

  """Checks for equality with the objects \`decimal\` field."""
  decimal: BigFloat

  """Checks for equality with the objects \`boolean\` field."""
  boolean: Boolean

  """Checks for equality with the objects \`varchar\` field."""
  varchar: String

  """Checks for equality with the objects \`enum\` field."""
  enum: Color

  """Checks for equality with the objects \`enumArray\` field."""
  enumArray: [Color]

  """Checks for equality with the objects \`domain\` field."""
  domain: AnInt

  """Checks for equality with the objects \`domain2\` field."""
  domain2: AnotherInt

  """Checks for equality with the objects \`textArray\` field."""
  textArray: [String]

  """Checks for equality with the objects \`json\` field."""
  json: JSON

  """Checks for equality with the objects \`jsonb\` field."""
  jsonb: JSON

  """Checks for equality with the objects \`nullableRange\` field."""
  nullableRange: BigFloatRangeInput

  """Checks for equality with the objects \`numrange\` field."""
  numrange: BigFloatRangeInput

  """Checks for equality with the objects \`daterange\` field."""
  daterange: DateRangeInput

  """Checks for equality with the objects \`anIntRange\` field."""
  anIntRange: AnIntRangeInput

  """Checks for equality with the objects \`timestamp\` field."""
  timestamp: Datetime

  """Checks for equality with the objects \`timestamptz\` field."""
  timestamptz: Datetime

  """Checks for equality with the objects \`date\` field."""
  date: Date

  """Checks for equality with the objects \`time\` field."""
  time: Time

  """Checks for equality with the objects \`timetz\` field."""
  timetz: Time

  """Checks for equality with the objects \`interval\` field."""
  interval: IntervalInput

  """Checks for equality with the objects \`intervalArray\` field."""
  intervalArray: [IntervalInput]

  """Checks for equality with the objects \`money\` field."""
  money: Float

  """Checks for equality with the objects \`compoundType\` field."""
  compoundType: CompoundTypeInput

  """Checks for equality with the objects \`nestedCompoundType\` field."""
  nestedCompoundType: NestedCompoundTypeInput

  """Checks for equality with the objects \`nullableCompoundType\` field."""
  nullableCompoundType: CompoundTypeInput

  """
  Checks for equality with the objects \`nullableNestedCompoundType\` field.
  """
  nullableNestedCompoundType: NestedCompoundTypeInput

  """Checks for equality with the objects \`point\` field."""
  point: PointInput

  """Checks for equality with the objects \`nullablePoint\` field."""
  nullablePoint: PointInput

  """Checks for equality with the objects \`inet\` field."""
  inet: InternetAddress

  """Checks for equality with the objects \`cidr\` field."""
  cidr: String

  """Checks for equality with the objects \`macaddr\` field."""
  macaddr: String

  """Checks for equality with the objects \`regproc\` field."""
  regproc: RegProc

  """Checks for equality with the objects \`regprocedure\` field."""
  regprocedure: RegProcedure

  """Checks for equality with the objects \`regoper\` field."""
  regoper: RegOper

  """Checks for equality with the objects \`regoperator\` field."""
  regoperator: RegOperator

  """Checks for equality with the objects \`regclass\` field."""
  regclass: RegClass

  """Checks for equality with the objects \`regtype\` field."""
  regtype: RegType

  """Checks for equality with the objects \`regconfig\` field."""
  regconfig: RegConfig

  """Checks for equality with the objects \`regdictionary\` field."""
  regdictionary: RegDictionary

  """Checks for equality with the objects \`textArrayDomain\` field."""
  textArrayDomain: [String]

  """Checks for equality with the objects \`int8ArrayDomain\` field."""
  int8ArrayDomain: [BigInt]

  """Checks for equality with the objects \`ltree\` field."""
  ltree: LTree

  """Checks for equality with the objects \`ltreeArray\` field."""
  ltreeArray: [LTree]
}

"""A range of \`BigFloat\`."""
input BigFloatRangeInput {
  """The starting bound of our range."""
  start: BigFloatRangeBoundInput

  """The ending bound of our range."""
  end: BigFloatRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input BigFloatRangeBoundInput {
  """The value at one end of our range."""
  value: BigFloat!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""A range of \`Date\`."""
input DateRangeInput {
  """The starting bound of our range."""
  start: DateRangeBoundInput

  """The ending bound of our range."""
  end: DateRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input DateRangeBoundInput {
  """The value at one end of our range."""
  value: Date!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""A range of \`AnInt\`."""
input AnIntRangeInput {
  """The starting bound of our range."""
  start: AnIntRangeBoundInput

  """The ending bound of our range."""
  end: AnIntRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input AnIntRangeBoundInput {
  """The value at one end of our range."""
  value: AnInt!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""An input for mutations affecting \`NestedCompoundType\`"""
input NestedCompoundTypeInput {
  a: CompoundTypeInput
  b: CompoundTypeInput
  bazBuz: Int
}

"""A cartesian point."""
input PointInput {
  x: Float!
  y: Float!
}

"""A connection to a list of \`Person\` values."""
type PeopleConnection {
  """A list of \`Person\` objects."""
  nodes: [Person]!

  """
  A list of edges which contains the \`Person\` and cursor to aid in pagination.
  """
  edges: [PeopleEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Person\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Person\` edge in the connection."""
type PeopleEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Person\` at the end of the edge."""
  node: Person
}

"""Methods to use when ordering \`Person\`."""
enum PeopleOrderBy {
  NATURAL
  COMPUTED_OUT_ASC
  COMPUTED_OUT_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ABOUT_ASC
  ABOUT_DESC
  EMAIL_ASC
  EMAIL_DESC
  SITE_ASC
  SITE_DESC
  CONFIG_ASC
  CONFIG_DESC
  LAST_LOGIN_FROM_IP_ASC
  LAST_LOGIN_FROM_IP_DESC
  LAST_LOGIN_FROM_SUBNET_ASC
  LAST_LOGIN_FROM_SUBNET_DESC
  USER_MAC_ASC
  USER_MAC_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

type WrappedUrl {
  url: NotNullUrl!
}

scalar NotNullUrl

"""
A set of key/value pairs, keys are strings, values may be a string or null. Exposed as a JSON object.
"""
scalar KeyValueHash

"""A connection to a list of \`Post\` values."""
type PostsConnection {
  """A list of \`Post\` objects."""
  nodes: [Post]!

  """
  A list of edges which contains the \`Post\` and cursor to aid in pagination.
  """
  edges: [PostsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Post\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Post\` edge in the connection."""
type PostsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Post\` at the end of the edge."""
  node: Post
}

"""Methods to use when ordering \`Post\`."""
enum PostsOrderBy {
  NATURAL
  COMPUTED_WITH_OPTIONAL_ARG_ASC
  COMPUTED_WITH_OPTIONAL_ARG_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  HEADLINE_ASC
  HEADLINE_DESC
  BODY_ASC
  BODY_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
}

"""
A condition to be used against \`Post\` object types. All fields are tested for equality and combined with a logical and.
"""
input PostCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`headline\` field."""
  headline: String

  """Checks for equality with the objects \`body\` field."""
  body: String

  """Checks for equality with the objects \`authorId\` field."""
  authorId: Int

  """Checks for equality with the objects \`enums\` field."""
  enums: [AnEnum]

  """Checks for equality with the objects \`comptypes\` field."""
  comptypes: [ComptypeInput]

  """Checks for equality with the objects \`computedWithOptionalArg\` field."""
  computedWithOptionalArg: Int
}

"""An input for mutations affecting \`Comptype\`"""
input ComptypeInput {
  schedule: Datetime
  isOptimised: Boolean
}

"""A connection to a list of \`ForeignKey\` values."""
type ForeignKeysConnection {
  """A list of \`ForeignKey\` objects."""
  nodes: [ForeignKey]!

  """
  A list of edges which contains the \`ForeignKey\` and cursor to aid in pagination.
  """
  edges: [ForeignKeysEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`ForeignKey\` you could get from the connection."""
  totalCount: Int!
}

type ForeignKey {
  personId: Int
  compoundKey1: Int
  compoundKey2: Int

  """Reads a single \`CompoundKey\` that is related to this \`ForeignKey\`."""
  compoundKeyByCompoundKey1AndCompoundKey2: CompoundKey

  """Reads a single \`Person\` that is related to this \`ForeignKey\`."""
  personByPersonId: Person
}

"""A \`ForeignKey\` edge in the connection."""
type ForeignKeysEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ForeignKey\` at the end of the edge."""
  node: ForeignKey
}

"""Methods to use when ordering \`ForeignKey\`."""
enum ForeignKeysOrderBy {
  NATURAL
  PERSON_ID_ASC
  PERSON_ID_DESC
  COMPOUND_KEY_1_ASC
  COMPOUND_KEY_1_DESC
  COMPOUND_KEY_2_ASC
  COMPOUND_KEY_2_DESC
}

"""
A condition to be used against \`ForeignKey\` object types. All fields are tested
for equality and combined with a logical and.
"""
input ForeignKeyCondition {
  """Checks for equality with the objects \`personId\` field."""
  personId: Int

  """Checks for equality with the objects \`compoundKey1\` field."""
  compoundKey1: Int

  """Checks for equality with the objects \`compoundKey2\` field."""
  compoundKey2: Int
}

"""Tracks the person's secret"""
type PersonSecret {
  personId: Int!

  """A secret held by the associated Person"""
  secret: String

  """The \`Person\` this \`PersonSecret\` belongs to."""
  personByPersonId: Person
}

"""Tracks metadata about the left arms of various people"""
type LeftArm {
  id: Int!
  personId: Int!
  lengthInMetres: Float
  mood: String!

  """Reads a single \`Person\` that is related to this \`LeftArm\`."""
  personByPersonId: Person
}

"""A connection to a list of \`CompoundKey\` values."""
type CompoundKeysConnection {
  """A list of \`CompoundKey\` objects."""
  nodes: [CompoundKey]!

  """
  A list of edges which contains the \`CompoundKey\` and cursor to aid in pagination.
  """
  edges: [CompoundKeysEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CompoundKey\` you could get from the connection."""
  totalCount: Int!
}

"""A \`CompoundKey\` edge in the connection."""
type CompoundKeysEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CompoundKey\` at the end of the edge."""
  node: CompoundKey
}

"""Methods to use when ordering \`CompoundKey\`."""
enum CompoundKeysOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PERSON_ID_2_ASC
  PERSON_ID_2_DESC
  PERSON_ID_1_ASC
  PERSON_ID_1_DESC
  EXTRA_ASC
  EXTRA_DESC
}

"""
A condition to be used against \`CompoundKey\` object types. All fields are tested
for equality and combined with a logical and.
"""
input CompoundKeyCondition {
  """Checks for equality with the objects \`personId2\` field."""
  personId2: Int

  """Checks for equality with the objects \`personId1\` field."""
  personId1: Int

  """Checks for equality with the objects \`extra\` field."""
  extra: Boolean
}

type MyTable {
  id: Int!
  jsonData: JSON
}

type ViewTable {
  id: Int!
  col1: Int
  col2: Int
}

type SimilarTable1 {
  id: Int!
  col1: Int
  col2: Int
  col3: Int!
}

type SimilarTable2 {
  id: Int!
  col3: Int!
  col4: Int
  col5: Int
}

type NullTestRecord {
  id: Int!
  nullableText: String
  nullableInt: Int
  nonNullText: String!
}

type Issue756 {
  id: Int!
  ts: NotNullTimestamp!
}

scalar NotNullTimestamp

"""A connection to a list of \`Int\` values."""
type FuncOutSetofConnection {
  """A list of \`Int\` objects."""
  nodes: [Int]!

  """
  A list of edges which contains the \`Int\` and cursor to aid in pagination.
  """
  edges: [FuncOutSetofEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Int\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Int\` edge in the connection."""
type FuncOutSetofEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Int\` at the end of the edge."""
  node: Int
}

"""A connection to a list of \`Interval\` values."""
type QueryIntervalSetConnection {
  """A list of \`Interval\` objects."""
  nodes: [Interval]!

  """
  A list of edges which contains the \`Interval\` and cursor to aid in pagination.
  """
  edges: [QueryIntervalSetEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Interval\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Interval\` edge in the connection."""
type QueryIntervalSetEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Interval\` at the end of the edge."""
  node: Interval
}

"""A connection to a list of \`BigInt\` values."""
type StaticBigIntegerConnection {
  """A list of \`BigInt\` objects."""
  nodes: [BigInt]!

  """
  A list of edges which contains the \`BigInt\` and cursor to aid in pagination.
  """
  edges: [StaticBigIntegerEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`BigInt\` you could get from the connection."""
  totalCount: Int!
}

"""A \`BigInt\` edge in the connection."""
type StaticBigIntegerEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`BigInt\` at the end of the edge."""
  node: BigInt
}

"""A connection to a list of \`Int\` values."""
type FuncReturnsTableOneColConnection {
  """A list of \`Int\` objects."""
  nodes: [Int]!

  """
  A list of edges which contains the \`Int\` and cursor to aid in pagination.
  """
  edges: [FuncReturnsTableOneColEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Int\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Int\` edge in the connection."""
type FuncReturnsTableOneColEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Int\` at the end of the edge."""
  node: Int
}

type FuncOutOutRecord {
  firstOut: Int
  secondOut: String
}

"""A connection to a list of \`FuncOutOutSetofRecord\` values."""
type FuncOutOutSetofConnection {
  """A list of \`FuncOutOutSetofRecord\` objects."""
  nodes: [FuncOutOutSetofRecord]!

  """
  A list of edges which contains the \`FuncOutOutSetofRecord\` and cursor to aid in pagination.
  """
  edges: [FuncOutOutSetofEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`FuncOutOutSetofRecord\` you could get from the connection.
  """
  totalCount: Int!
}

type FuncOutOutSetofRecord {
  o1: Int
  o2: String
}

"""A \`FuncOutOutSetofRecord\` edge in the connection."""
type FuncOutOutSetofEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`FuncOutOutSetofRecord\` at the end of the edge."""
  node: FuncOutOutSetofRecord
}

type FuncOutOutUnnamedRecord {
  arg1: Int
  arg2: String
}

type SearchTestSummariesRecord {
  id: Int
  totalDuration: Interval
}

type FuncOutUnnamedOutOutUnnamedRecord {
  arg1: Int
  o2: String
  arg3: Int
}

"""A connection to a list of \`FuncReturnsTableMultiColRecord\` values."""
type FuncReturnsTableMultiColConnection {
  """A list of \`FuncReturnsTableMultiColRecord\` objects."""
  nodes: [FuncReturnsTableMultiColRecord]!

  """
  A list of edges which contains the \`FuncReturnsTableMultiColRecord\` and cursor to aid in pagination.
  """
  edges: [FuncReturnsTableMultiColEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`FuncReturnsTableMultiColRecord\` you could get from the connection.
  """
  totalCount: Int!
}

type FuncReturnsTableMultiColRecord {
  col1: Int
  col2: String
}

"""A \`FuncReturnsTableMultiColRecord\` edge in the connection."""
type FuncReturnsTableMultiColEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`FuncReturnsTableMultiColRecord\` at the end of the edge."""
  node: FuncReturnsTableMultiColRecord
}

"""A connection to a list of \`Int\` values."""
type IntSetQueryConnection {
  """A list of \`Int\` objects."""
  nodes: [Int]!

  """
  A list of edges which contains the \`Int\` and cursor to aid in pagination.
  """
  edges: [IntSetQueryEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Int\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Int\` edge in the connection."""
type IntSetQueryEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Int\` at the end of the edge."""
  node: Int
}

"""A range of \`Float\`."""
input FloatRangeInput {
  """The starting bound of our range."""
  start: FloatRangeBoundInput

  """The ending bound of our range."""
  end: FloatRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input FloatRangeBoundInput {
  """The value at one end of our range."""
  value: Float!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

type FuncOutOutCompoundTypeRecord {
  o1: Int
  o2: CompoundType
}

type QueryOutputTwoRowsRecord {
  txt: String
  leftArm: LeftArm
  post: Post
}

"""A connection to a list of \`CompoundType\` values."""
type CompoundTypesConnection {
  """A list of \`CompoundType\` objects."""
  nodes: [CompoundType]!

  """
  A list of edges which contains the \`CompoundType\` and cursor to aid in pagination.
  """
  edges: [CompoundTypesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`CompoundType\` you could get from the connection."""
  totalCount: Int!
}

"""A \`CompoundType\` edge in the connection."""
type CompoundTypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`CompoundType\` at the end of the edge."""
  node: CompoundType
}

type FuncOutComplexRecord {
  x: Int
  y: CompoundType
  z: Person
}

"""A connection to a list of \`FuncOutComplexSetofRecord\` values."""
type FuncOutComplexSetofConnection {
  """A list of \`FuncOutComplexSetofRecord\` objects."""
  nodes: [FuncOutComplexSetofRecord]!

  """
  A list of edges which contains the \`FuncOutComplexSetofRecord\` and cursor to aid in pagination.
  """
  edges: [FuncOutComplexSetofEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`FuncOutComplexSetofRecord\` you could get from the connection.
  """
  totalCount: Int!
}

type FuncOutComplexSetofRecord {
  x: Int
  y: CompoundType
  z: Person
}

"""A \`FuncOutComplexSetofRecord\` edge in the connection."""
type FuncOutComplexSetofEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`FuncOutComplexSetofRecord\` at the end of the edge."""
  node: FuncOutComplexSetofRecord
}

"""
A condition to be used against \`Person\` object types. All fields are tested for equality and combined with a logical and.
"""
input PersonCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`aliases\` field."""
  aliases: [String]

  """Checks for equality with the objects \`about\` field."""
  about: String

  """Checks for equality with the objects \`email\` field."""
  email: Email

  """Checks for equality with the objects \`site\` field."""
  site: WrappedUrlInput

  """Checks for equality with the objects \`config\` field."""
  config: KeyValueHash

  """Checks for equality with the objects \`lastLoginFromIp\` field."""
  lastLoginFromIp: InternetAddress

  """Checks for equality with the objects \`lastLoginFromSubnet\` field."""
  lastLoginFromSubnet: String

  """Checks for equality with the objects \`userMac\` field."""
  userMac: String

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`computedOut\` field."""
  computedOut: String
}

"""An input for mutations affecting \`WrappedUrl\`"""
input WrappedUrlInput {
  url: NotNullUrl!
}

"""A connection to a list of \`NonUpdatableView\` values."""
type NonUpdatableViewsConnection {
  """A list of \`NonUpdatableView\` objects."""
  nodes: [NonUpdatableView]!

  """
  A list of edges which contains the \`NonUpdatableView\` and cursor to aid in pagination.
  """
  edges: [NonUpdatableViewsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`NonUpdatableView\` you could get from the connection.
  """
  totalCount: Int!
}

type NonUpdatableView {
  column: Int
}

"""A \`NonUpdatableView\` edge in the connection."""
type NonUpdatableViewsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`NonUpdatableView\` at the end of the edge."""
  node: NonUpdatableView
}

"""Methods to use when ordering \`NonUpdatableView\`."""
enum NonUpdatableViewsOrderBy {
  NATURAL
  COLUMN_ASC
  COLUMN_DESC
}

"""
A condition to be used against \`NonUpdatableView\` object types. All fields are
tested for equality and combined with a logical and.
"""
input NonUpdatableViewCondition {
  """Checks for equality with the objects \`column\` field."""
  column: Int
}

"""A connection to a list of \`Input\` values."""
type InputsConnection {
  """A list of \`Input\` objects."""
  nodes: [Input]!

  """
  A list of edges which contains the \`Input\` and cursor to aid in pagination.
  """
  edges: [InputsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Input\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Input\` edge in the connection."""
type InputsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Input\` at the end of the edge."""
  node: Input
}

"""Methods to use when ordering \`Input\`."""
enum InputsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`Input\` object types. All fields are tested for equality and combined with a logical and.
"""
input InputCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int
}

"""A connection to a list of \`Patch\` values."""
type PatchesConnection {
  """A list of \`Patch\` objects."""
  nodes: [Patch]!

  """
  A list of edges which contains the \`Patch\` and cursor to aid in pagination.
  """
  edges: [PatchesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Patch\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Patch\` edge in the connection."""
type PatchesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Patch\` at the end of the edge."""
  node: Patch
}

"""Methods to use when ordering \`Patch\`."""
enum PatchesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`Patch\` object types. All fields are tested for equality and combined with a logical and.
"""
input PatchCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int
}

"""A connection to a list of \`Reserved\` values."""
type ReservedsConnection {
  """A list of \`Reserved\` objects."""
  nodes: [Reserved]!

  """
  A list of edges which contains the \`Reserved\` and cursor to aid in pagination.
  """
  edges: [ReservedsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Reserved\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Reserved\` edge in the connection."""
type ReservedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Reserved\` at the end of the edge."""
  node: Reserved
}

"""Methods to use when ordering \`Reserved\`."""
enum ReservedsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`Reserved\` object types. All fields are tested
for equality and combined with a logical and.
"""
input ReservedCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int
}

"""A connection to a list of \`ReservedPatchRecord\` values."""
type ReservedPatchRecordsConnection {
  """A list of \`ReservedPatchRecord\` objects."""
  nodes: [ReservedPatchRecord]!

  """
  A list of edges which contains the \`ReservedPatchRecord\` and cursor to aid in pagination.
  """
  edges: [ReservedPatchRecordsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`ReservedPatchRecord\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`ReservedPatchRecord\` edge in the connection."""
type ReservedPatchRecordsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ReservedPatchRecord\` at the end of the edge."""
  node: ReservedPatchRecord
}

"""Methods to use when ordering \`ReservedPatchRecord\`."""
enum ReservedPatchRecordsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`ReservedPatchRecord\` object types. All fields
are tested for equality and combined with a logical and.
"""
input ReservedPatchRecordCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int
}

"""A connection to a list of \`ReservedInputRecord\` values."""
type ReservedInputRecordsConnection {
  """A list of \`ReservedInputRecord\` objects."""
  nodes: [ReservedInputRecord]!

  """
  A list of edges which contains the \`ReservedInputRecord\` and cursor to aid in pagination.
  """
  edges: [ReservedInputRecordsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`ReservedInputRecord\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`ReservedInputRecord\` edge in the connection."""
type ReservedInputRecordsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ReservedInputRecord\` at the end of the edge."""
  node: ReservedInputRecord
}

"""Methods to use when ordering \`ReservedInputRecord\`."""
enum ReservedInputRecordsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against \`ReservedInputRecord\` object types. All fields
are tested for equality and combined with a logical and.
"""
input ReservedInputRecordCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int
}

"""A connection to a list of \`DefaultValue\` values."""
type DefaultValuesConnection {
  """A list of \`DefaultValue\` objects."""
  nodes: [DefaultValue]!

  """
  A list of edges which contains the \`DefaultValue\` and cursor to aid in pagination.
  """
  edges: [DefaultValuesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`DefaultValue\` you could get from the connection."""
  totalCount: Int!
}

"""A \`DefaultValue\` edge in the connection."""
type DefaultValuesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`DefaultValue\` at the end of the edge."""
  node: DefaultValue
}

"""Methods to use when ordering \`DefaultValue\`."""
enum DefaultValuesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NULL_VALUE_ASC
  NULL_VALUE_DESC
}

"""
A condition to be used against \`DefaultValue\` object types. All fields are
tested for equality and combined with a logical and.
"""
input DefaultValueCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`nullValue\` field."""
  nullValue: String
}

"""A connection to a list of \`NoPrimaryKey\` values."""
type NoPrimaryKeysConnection {
  """A list of \`NoPrimaryKey\` objects."""
  nodes: [NoPrimaryKey]!

  """
  A list of edges which contains the \`NoPrimaryKey\` and cursor to aid in pagination.
  """
  edges: [NoPrimaryKeysEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`NoPrimaryKey\` you could get from the connection."""
  totalCount: Int!
}

"""A \`NoPrimaryKey\` edge in the connection."""
type NoPrimaryKeysEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`NoPrimaryKey\` at the end of the edge."""
  node: NoPrimaryKey
}

"""Methods to use when ordering \`NoPrimaryKey\`."""
enum NoPrimaryKeysOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  STR_ASC
  STR_DESC
}

"""
A condition to be used against \`NoPrimaryKey\` object types. All fields are
tested for equality and combined with a logical and.
"""
input NoPrimaryKeyCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`str\` field."""
  str: String
}

"""A connection to a list of \`Testview\` values."""
type TestviewsConnection {
  """A list of \`Testview\` objects."""
  nodes: [Testview]!

  """
  A list of edges which contains the \`Testview\` and cursor to aid in pagination.
  """
  edges: [TestviewsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Testview\` you could get from the connection."""
  totalCount: Int!
}

type Testview {
  testviewid: Int
  col1: Int
  col2: Int
}

"""A \`Testview\` edge in the connection."""
type TestviewsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Testview\` at the end of the edge."""
  node: Testview
}

"""Methods to use when ordering \`Testview\`."""
enum TestviewsOrderBy {
  NATURAL
  TESTVIEWID_ASC
  TESTVIEWID_DESC
  COL1_ASC
  COL1_DESC
  COL2_ASC
  COL2_DESC
}

"""
A condition to be used against \`Testview\` object types. All fields are tested
for equality and combined with a logical and.
"""
input TestviewCondition {
  """Checks for equality with the objects \`testviewid\` field."""
  testviewid: Int

  """Checks for equality with the objects \`col1\` field."""
  col1: Int

  """Checks for equality with the objects \`col2\` field."""
  col2: Int
}

"""A connection to a list of \`MyTable\` values."""
type MyTablesConnection {
  """A list of \`MyTable\` objects."""
  nodes: [MyTable]!

  """
  A list of edges which contains the \`MyTable\` and cursor to aid in pagination.
  """
  edges: [MyTablesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`MyTable\` you could get from the connection."""
  totalCount: Int!
}

"""A \`MyTable\` edge in the connection."""
type MyTablesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`MyTable\` at the end of the edge."""
  node: MyTable
}

"""Methods to use when ordering \`MyTable\`."""
enum MyTablesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  JSON_DATA_ASC
  JSON_DATA_DESC
}

"""
A condition to be used against \`MyTable\` object types. All fields are tested for equality and combined with a logical and.
"""
input MyTableCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`jsonData\` field."""
  jsonData: JSON
}

"""A connection to a list of \`PersonSecret\` values."""
type PersonSecretsConnection {
  """A list of \`PersonSecret\` objects."""
  nodes: [PersonSecret]!

  """
  A list of edges which contains the \`PersonSecret\` and cursor to aid in pagination.
  """
  edges: [PersonSecretsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`PersonSecret\` you could get from the connection."""
  totalCount: Int!
}

"""A \`PersonSecret\` edge in the connection."""
type PersonSecretsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`PersonSecret\` at the end of the edge."""
  node: PersonSecret
}

"""Methods to use when ordering \`PersonSecret\`."""
enum PersonSecretsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  SECRET_ASC
  SECRET_DESC
}

"""
A condition to be used against \`PersonSecret\` object types. All fields are
tested for equality and combined with a logical and.
"""
input PersonSecretCondition {
  """Checks for equality with the objects \`personId\` field."""
  personId: Int

  """Checks for equality with the objects \`secret\` field."""
  secret: String
}

"""A connection to a list of \`ViewTable\` values."""
type ViewTablesConnection {
  """A list of \`ViewTable\` objects."""
  nodes: [ViewTable]!

  """
  A list of edges which contains the \`ViewTable\` and cursor to aid in pagination.
  """
  edges: [ViewTablesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`ViewTable\` you could get from the connection."""
  totalCount: Int!
}

"""A \`ViewTable\` edge in the connection."""
type ViewTablesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`ViewTable\` at the end of the edge."""
  node: ViewTable
}

"""Methods to use when ordering \`ViewTable\`."""
enum ViewTablesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  COL1_ASC
  COL1_DESC
  COL2_ASC
  COL2_DESC
}

"""
A condition to be used against \`ViewTable\` object types. All fields are tested
for equality and combined with a logical and.
"""
input ViewTableCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`col1\` field."""
  col1: Int

  """Checks for equality with the objects \`col2\` field."""
  col2: Int
}

"""A connection to a list of \`SimilarTable1\` values."""
type SimilarTable1SConnection {
  """A list of \`SimilarTable1\` objects."""
  nodes: [SimilarTable1]!

  """
  A list of edges which contains the \`SimilarTable1\` and cursor to aid in pagination.
  """
  edges: [SimilarTable1SEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`SimilarTable1\` you could get from the connection."""
  totalCount: Int!
}

"""A \`SimilarTable1\` edge in the connection."""
type SimilarTable1SEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`SimilarTable1\` at the end of the edge."""
  node: SimilarTable1
}

"""Methods to use when ordering \`SimilarTable1\`."""
enum SimilarTable1SOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  COL1_ASC
  COL1_DESC
  COL2_ASC
  COL2_DESC
  COL3_ASC
  COL3_DESC
}

"""
A condition to be used against \`SimilarTable1\` object types. All fields are
tested for equality and combined with a logical and.
"""
input SimilarTable1Condition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`col1\` field."""
  col1: Int

  """Checks for equality with the objects \`col2\` field."""
  col2: Int

  """Checks for equality with the objects \`col3\` field."""
  col3: Int
}

"""A connection to a list of \`SimilarTable2\` values."""
type SimilarTable2SConnection {
  """A list of \`SimilarTable2\` objects."""
  nodes: [SimilarTable2]!

  """
  A list of edges which contains the \`SimilarTable2\` and cursor to aid in pagination.
  """
  edges: [SimilarTable2SEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`SimilarTable2\` you could get from the connection."""
  totalCount: Int!
}

"""A \`SimilarTable2\` edge in the connection."""
type SimilarTable2SEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`SimilarTable2\` at the end of the edge."""
  node: SimilarTable2
}

"""Methods to use when ordering \`SimilarTable2\`."""
enum SimilarTable2SOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  COL3_ASC
  COL3_DESC
  COL4_ASC
  COL4_DESC
  COL5_ASC
  COL5_DESC
}

"""
A condition to be used against \`SimilarTable2\` object types. All fields are
tested for equality and combined with a logical and.
"""
input SimilarTable2Condition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`col3\` field."""
  col3: Int

  """Checks for equality with the objects \`col4\` field."""
  col4: Int

  """Checks for equality with the objects \`col5\` field."""
  col5: Int
}

"""A connection to a list of \`UpdatableView\` values."""
type UpdatableViewsConnection {
  """A list of \`UpdatableView\` objects."""
  nodes: [UpdatableView]!

  """
  A list of edges which contains the \`UpdatableView\` and cursor to aid in pagination.
  """
  edges: [UpdatableViewsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`UpdatableView\` you could get from the connection."""
  totalCount: Int!
}

"""YOYOYO!!"""
type UpdatableView {
  x: Int
  name: String
  description: String

  """This is constantly 2"""
  constant: Int
}

"""A \`UpdatableView\` edge in the connection."""
type UpdatableViewsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`UpdatableView\` at the end of the edge."""
  node: UpdatableView
}

"""Methods to use when ordering \`UpdatableView\`."""
enum UpdatableViewsOrderBy {
  NATURAL
  X_ASC
  X_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CONSTANT_ASC
  CONSTANT_DESC
}

"""
A condition to be used against \`UpdatableView\` object types. All fields are
tested for equality and combined with a logical and.
"""
input UpdatableViewCondition {
  """Checks for equality with the objects \`x\` field."""
  x: Int

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`description\` field."""
  description: String

  """Checks for equality with the objects \`constant\` field."""
  constant: Int
}

"""A connection to a list of \`NullTestRecord\` values."""
type NullTestRecordsConnection {
  """A list of \`NullTestRecord\` objects."""
  nodes: [NullTestRecord]!

  """
  A list of edges which contains the \`NullTestRecord\` and cursor to aid in pagination.
  """
  edges: [NullTestRecordsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`NullTestRecord\` you could get from the connection."""
  totalCount: Int!
}

"""A \`NullTestRecord\` edge in the connection."""
type NullTestRecordsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`NullTestRecord\` at the end of the edge."""
  node: NullTestRecord
}

"""Methods to use when ordering \`NullTestRecord\`."""
enum NullTestRecordsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  NULLABLE_TEXT_ASC
  NULLABLE_TEXT_DESC
  NULLABLE_INT_ASC
  NULLABLE_INT_DESC
  NON_NULL_TEXT_ASC
  NON_NULL_TEXT_DESC
}

"""
A condition to be used against \`NullTestRecord\` object types. All fields are
tested for equality and combined with a logical and.
"""
input NullTestRecordCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`nullableText\` field."""
  nullableText: String

  """Checks for equality with the objects \`nullableInt\` field."""
  nullableInt: Int

  """Checks for equality with the objects \`nonNullText\` field."""
  nonNullText: String
}

"""A connection to a list of \`EdgeCase\` values."""
type EdgeCasesConnection {
  """A list of \`EdgeCase\` objects."""
  nodes: [EdgeCase]!

  """
  A list of edges which contains the \`EdgeCase\` and cursor to aid in pagination.
  """
  edges: [EdgeCasesEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`EdgeCase\` you could get from the connection."""
  totalCount: Int!
}

type EdgeCase {
  computed: String
  notNullHasDefault: Boolean!
  wontCastEasy: Int
  rowId: Int
}

"""A \`EdgeCase\` edge in the connection."""
type EdgeCasesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`EdgeCase\` at the end of the edge."""
  node: EdgeCase
}

"""Methods to use when ordering \`EdgeCase\`."""
enum EdgeCasesOrderBy {
  NATURAL
  NOT_NULL_HAS_DEFAULT_ASC
  NOT_NULL_HAS_DEFAULT_DESC
  WONT_CAST_EASY_ASC
  WONT_CAST_EASY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
}

"""
A condition to be used against \`EdgeCase\` object types. All fields are tested
for equality and combined with a logical and.
"""
input EdgeCaseCondition {
  """Checks for equality with the objects \`notNullHasDefault\` field."""
  notNullHasDefault: Boolean

  """Checks for equality with the objects \`wontCastEasy\` field."""
  wontCastEasy: Int

  """Checks for equality with the objects \`rowId\` field."""
  rowId: Int
}

"""A connection to a list of \`LeftArm\` values."""
type LeftArmsConnection {
  """A list of \`LeftArm\` objects."""
  nodes: [LeftArm]!

  """
  A list of edges which contains the \`LeftArm\` and cursor to aid in pagination.
  """
  edges: [LeftArmsEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`LeftArm\` you could get from the connection."""
  totalCount: Int!
}

"""A \`LeftArm\` edge in the connection."""
type LeftArmsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`LeftArm\` at the end of the edge."""
  node: LeftArm
}

"""Methods to use when ordering \`LeftArm\`."""
enum LeftArmsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  LENGTH_IN_METRES_ASC
  LENGTH_IN_METRES_DESC
  MOOD_ASC
  MOOD_DESC
}

"""
A condition to be used against \`LeftArm\` object types. All fields are tested for equality and combined with a logical and.
"""
input LeftArmCondition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`personId\` field."""
  personId: Int

  """Checks for equality with the objects \`lengthInMetres\` field."""
  lengthInMetres: Float

  """Checks for equality with the objects \`mood\` field."""
  mood: String
}

"""A connection to a list of \`Issue756\` values."""
type Issue756SConnection {
  """A list of \`Issue756\` objects."""
  nodes: [Issue756]!

  """
  A list of edges which contains the \`Issue756\` and cursor to aid in pagination.
  """
  edges: [Issue756SEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Issue756\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Issue756\` edge in the connection."""
type Issue756SEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Issue756\` at the end of the edge."""
  node: Issue756
}

"""Methods to use when ordering \`Issue756\`."""
enum Issue756SOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  TS_ASC
  TS_DESC
}

"""
A condition to be used against \`Issue756\` object types. All fields are tested
for equality and combined with a logical and.
"""
input Issue756Condition {
  """Checks for equality with the objects \`id\` field."""
  id: Int

  """Checks for equality with the objects \`ts\` field."""
  ts: NotNullTimestamp
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  mutationOut(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutInput!
  ): MutationOutPayload
  mutationOutSetof(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutSetofInput!
  ): MutationOutSetofPayload
  mutationOutUnnamed(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutUnnamedInput!
  ): MutationOutUnnamedPayload
  noArgsMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: NoArgsMutationInput!
  ): NoArgsMutationPayload
  returnVoidMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: ReturnVoidMutationInput!
  ): ReturnVoidMutationPayload
  mutationIntervalSet(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationIntervalSetInput!
  ): MutationIntervalSetPayload
  mutationInOut(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationInOutInput!
  ): MutationInOutPayload
  mutationReturnsTableOneCol(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationReturnsTableOneColInput!
  ): MutationReturnsTableOneColPayload
  jsonIdentityMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: JsonIdentityMutationInput!
  ): JsonIdentityMutationPayload
  jsonbIdentityMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: JsonbIdentityMutationInput!
  ): JsonbIdentityMutationPayload
  jsonbIdentityMutationPlpgsql(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: JsonbIdentityMutationPlpgsqlInput!
  ): JsonbIdentityMutationPlpgsqlPayload
  jsonbIdentityMutationPlpgsqlWithDefault(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: JsonbIdentityMutationPlpgsqlWithDefaultInput!
  ): JsonbIdentityMutationPlpgsqlWithDefaultPayload

  """lol, add some stuff 1 mutation"""
  add1Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Add1MutationInput!
  ): Add1MutationPayload

  """lol, add some stuff 2 mutation"""
  add2Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Add2MutationInput!
  ): Add2MutationPayload

  """lol, add some stuff 3 mutation"""
  add3Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Add3MutationInput!
  ): Add3MutationPayload

  """lol, add some stuff 4 mutation"""
  add4Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Add4MutationInput!
  ): Add4MutationPayload
  add4MutationError(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Add4MutationErrorInput!
  ): Add4MutationErrorPayload
  mult1(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Mult1Input!
  ): Mult1Payload
  mult2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Mult2Input!
  ): Mult2Payload
  mult3(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Mult3Input!
  ): Mult3Payload
  mult4(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Mult4Input!
  ): Mult4Payload
  mutationInInout(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationInInoutInput!
  ): MutationInInoutPayload
  mutationOutOut(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutOutInput!
  ): MutationOutOutPayload
  mutationOutOutSetof(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutOutSetofInput!
  ): MutationOutOutSetofPayload
  mutationOutOutUnnamed(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutOutUnnamedInput!
  ): MutationOutOutUnnamedPayload
  intSetMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: IntSetMutationInput!
  ): IntSetMutationPayload
  mutationOutUnnamedOutOutUnnamed(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutUnnamedOutOutUnnamedInput!
  ): MutationOutUnnamedOutOutUnnamedPayload
  mutationReturnsTableMultiCol(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationReturnsTableMultiColInput!
  ): MutationReturnsTableMultiColPayload
  guidFn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: GuidFnInput!
  ): GuidFnPayload
  mutationIntervalArray(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationIntervalArrayInput!
  ): MutationIntervalArrayPayload
  mutationTextArray(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationTextArrayInput!
  ): MutationTextArrayPayload
  listBdeMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: ListBdeMutationInput!
  ): ListBdeMutationPayload
  authenticateFail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: AuthenticateFailInput!
  ): AuthenticateFailPayload
  authenticate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: AuthenticateInput!
  ): AuthenticatePayload
  leftArmIdentity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: LeftArmIdentityInput!
  ): LeftArmIdentityPayload
  issue756Mutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Issue756MutationInput!
  ): Issue756MutationPayload
  issue756SetMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: Issue756SetMutationInput!
  ): Issue756SetMutationPayload
  authenticateMany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: AuthenticateManyInput!
  ): AuthenticateManyPayload
  authenticatePayload(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: AuthenticatePayloadInput!
  ): AuthenticatePayloadPayload
  typesMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: TypesMutationInput!
  ): TypesMutationPayload
  mutationOutOutCompoundType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutOutCompoundTypeInput!
  ): MutationOutOutCompoundTypePayload
  compoundTypeMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CompoundTypeMutationInput!
  ): CompoundTypeMutationPayload
  compoundTypeSetMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CompoundTypeSetMutationInput!
  ): CompoundTypeSetMutationPayload
  tableMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: TableMutationInput!
  ): TableMutationPayload
  postWithSuffix(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: PostWithSuffixInput!
  ): PostWithSuffixPayload @deprecated(reason: "This is deprecated (comment on function a.post_with_suffix).")
  mutationCompoundTypeArray(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationCompoundTypeArrayInput!
  ): MutationCompoundTypeArrayPayload
  compoundTypeArrayMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CompoundTypeArrayMutationInput!
  ): CompoundTypeArrayMutationPayload
  postMany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: PostManyInput!
  ): PostManyPayload
  mutationOutComplex(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutComplexInput!
  ): MutationOutComplexPayload
  mutationOutComplexSetof(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutComplexSetofInput!
  ): MutationOutComplexSetofPayload
  mutationOutTable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutTableInput!
  ): MutationOutTablePayload
  mutationOutTableSetof(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: MutationOutTableSetofInput!
  ): MutationOutTableSetofPayload
  tableSetMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: TableSetMutationInput!
  ): TableSetMutationPayload
  typeFunctionConnectionMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: TypeFunctionConnectionMutationInput!
  ): TypeFunctionConnectionMutationPayload
  typeFunctionMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: TypeFunctionMutationInput!
  ): TypeFunctionMutationPayload
  typeFunctionListMutation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: TypeFunctionListMutationInput!
  ): TypeFunctionListMutationPayload

  """Creates a single \`Input\`."""
  createInput(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateInputInput!
  ): CreateInputPayload

  """Creates a single \`Patch\`."""
  createPatch(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePatchInput!
  ): CreatePatchPayload

  """Creates a single \`Reserved\`."""
  createReserved(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateReservedInput!
  ): CreateReservedPayload

  """Creates a single \`ReservedPatchRecord\`."""
  createReservedPatchRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateReservedPatchRecordInput!
  ): CreateReservedPatchRecordPayload

  """Creates a single \`ReservedInputRecord\`."""
  createReservedInputRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateReservedInputRecordInput!
  ): CreateReservedInputRecordPayload

  """Creates a single \`DefaultValue\`."""
  createDefaultValue(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateDefaultValueInput!
  ): CreateDefaultValuePayload

  """Creates a single \`ForeignKey\`."""
  createForeignKey(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateForeignKeyInput!
  ): CreateForeignKeyPayload

  """Creates a single \`NoPrimaryKey\`."""
  createNoPrimaryKey(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateNoPrimaryKeyInput!
  ): CreateNoPrimaryKeyPayload

  """Creates a single \`Testview\`."""
  createTestview(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateTestviewInput!
  ): CreateTestviewPayload

  """Creates a single \`MyTable\`."""
  createMyTable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateMyTableInput!
  ): CreateMyTablePayload

  """Creates a single \`PersonSecret\`."""
  createPersonSecret(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePersonSecretInput!
  ): CreatePersonSecretPayload @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Creates a single \`ViewTable\`."""
  createViewTable(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateViewTableInput!
  ): CreateViewTablePayload

  """Creates a single \`CompoundKey\`."""
  createCompoundKey(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateCompoundKeyInput!
  ): CreateCompoundKeyPayload

  """Creates a single \`SimilarTable1\`."""
  createSimilarTable1(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateSimilarTable1Input!
  ): CreateSimilarTable1Payload

  """Creates a single \`SimilarTable2\`."""
  createSimilarTable2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateSimilarTable2Input!
  ): CreateSimilarTable2Payload

  """Creates a single \`UpdatableView\`."""
  createUpdatableView(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUpdatableViewInput!
  ): CreateUpdatableViewPayload

  """Creates a single \`NullTestRecord\`."""
  createNullTestRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateNullTestRecordInput!
  ): CreateNullTestRecordPayload

  """Creates a single \`EdgeCase\`."""
  createEdgeCase(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateEdgeCaseInput!
  ): CreateEdgeCasePayload

  """Creates a single \`LeftArm\`."""
  createLeftArm(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateLeftArmInput!
  ): CreateLeftArmPayload

  """Creates a single \`Issue756\`."""
  createIssue756(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateIssue756Input!
  ): CreateIssue756Payload

  """Creates a single \`Post\`."""
  createPost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePostInput!
  ): CreatePostPayload

  """Creates a single \`Person\`."""
  createPerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePersonInput!
  ): CreatePersonPayload

  """Creates a single \`Type\`."""
  createType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateTypeInput!
  ): CreateTypePayload

  """Updates a single \`Input\` using a unique key and a patch."""
  updateInputById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateInputByIdInput!
  ): UpdateInputPayload

  """Updates a single \`Patch\` using a unique key and a patch."""
  updatePatchById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePatchByIdInput!
  ): UpdatePatchPayload

  """Updates a single \`Reserved\` using a unique key and a patch."""
  updateReservedById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateReservedByIdInput!
  ): UpdateReservedPayload

  """Updates a single \`ReservedPatchRecord\` using a unique key and a patch."""
  updateReservedPatchRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateReservedPatchRecordByIdInput!
  ): UpdateReservedPatchRecordPayload

  """Updates a single \`ReservedInputRecord\` using a unique key and a patch."""
  updateReservedInputRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateReservedInputRecordByIdInput!
  ): UpdateReservedInputRecordPayload

  """Updates a single \`DefaultValue\` using a unique key and a patch."""
  updateDefaultValueById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDefaultValueByIdInput!
  ): UpdateDefaultValuePayload

  """Updates a single \`NoPrimaryKey\` using a unique key and a patch."""
  updateNoPrimaryKeyById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateNoPrimaryKeyByIdInput!
  ): UpdateNoPrimaryKeyPayload

  """Updates a single \`MyTable\` using a unique key and a patch."""
  updateMyTableById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMyTableByIdInput!
  ): UpdateMyTablePayload

  """Updates a single \`PersonSecret\` using a unique key and a patch."""
  updatePersonSecretByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePersonSecretByPersonIdInput!
  ): UpdatePersonSecretPayload @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Updates a single \`ViewTable\` using a unique key and a patch."""
  updateViewTableById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateViewTableByIdInput!
  ): UpdateViewTablePayload

  """Updates a single \`CompoundKey\` using a unique key and a patch."""
  updateCompoundKeyByPersonId1AndPersonId2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateCompoundKeyByPersonId1AndPersonId2Input!
  ): UpdateCompoundKeyPayload

  """Updates a single \`SimilarTable1\` using a unique key and a patch."""
  updateSimilarTable1ById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSimilarTable1ByIdInput!
  ): UpdateSimilarTable1Payload

  """Updates a single \`SimilarTable2\` using a unique key and a patch."""
  updateSimilarTable2ById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSimilarTable2ByIdInput!
  ): UpdateSimilarTable2Payload

  """Updates a single \`NullTestRecord\` using a unique key and a patch."""
  updateNullTestRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateNullTestRecordByIdInput!
  ): UpdateNullTestRecordPayload

  """Updates a single \`LeftArm\` using a unique key and a patch."""
  updateLeftArmById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateLeftArmByIdInput!
  ): UpdateLeftArmPayload

  """Updates a single \`LeftArm\` using a unique key and a patch."""
  updateLeftArmByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateLeftArmByPersonIdInput!
  ): UpdateLeftArmPayload

  """Updates a single \`Issue756\` using a unique key and a patch."""
  updateIssue756ById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateIssue756ByIdInput!
  ): UpdateIssue756Payload

  """Updates a single \`Post\` using a unique key and a patch."""
  updatePostById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePostByIdInput!
  ): UpdatePostPayload

  """Updates a single \`Person\` using a unique key and a patch."""
  updatePersonById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePersonByIdInput!
  ): UpdatePersonPayload

  """Updates a single \`Person\` using a unique key and a patch."""
  updatePersonByEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePersonByEmailInput!
  ): UpdatePersonPayload

  """Updates a single \`Type\` using a unique key and a patch."""
  updateTypeById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateTypeByIdInput!
  ): UpdateTypePayload

  """Deletes a single \`Input\` using a unique key."""
  deleteInputById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteInputByIdInput!
  ): DeleteInputPayload

  """Deletes a single \`Patch\` using a unique key."""
  deletePatchById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePatchByIdInput!
  ): DeletePatchPayload

  """Deletes a single \`Reserved\` using a unique key."""
  deleteReservedById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteReservedByIdInput!
  ): DeleteReservedPayload

  """Deletes a single \`ReservedPatchRecord\` using a unique key."""
  deleteReservedPatchRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteReservedPatchRecordByIdInput!
  ): DeleteReservedPatchRecordPayload

  """Deletes a single \`ReservedInputRecord\` using a unique key."""
  deleteReservedInputRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteReservedInputRecordByIdInput!
  ): DeleteReservedInputRecordPayload

  """Deletes a single \`DefaultValue\` using a unique key."""
  deleteDefaultValueById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDefaultValueByIdInput!
  ): DeleteDefaultValuePayload

  """Deletes a single \`NoPrimaryKey\` using a unique key."""
  deleteNoPrimaryKeyById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteNoPrimaryKeyByIdInput!
  ): DeleteNoPrimaryKeyPayload

  """Deletes a single \`MyTable\` using a unique key."""
  deleteMyTableById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMyTableByIdInput!
  ): DeleteMyTablePayload

  """Deletes a single \`PersonSecret\` using a unique key."""
  deletePersonSecretByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePersonSecretByPersonIdInput!
  ): DeletePersonSecretPayload @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """Deletes a single \`ViewTable\` using a unique key."""
  deleteViewTableById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteViewTableByIdInput!
  ): DeleteViewTablePayload

  """Deletes a single \`CompoundKey\` using a unique key."""
  deleteCompoundKeyByPersonId1AndPersonId2(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteCompoundKeyByPersonId1AndPersonId2Input!
  ): DeleteCompoundKeyPayload

  """Deletes a single \`SimilarTable1\` using a unique key."""
  deleteSimilarTable1ById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSimilarTable1ByIdInput!
  ): DeleteSimilarTable1Payload

  """Deletes a single \`SimilarTable2\` using a unique key."""
  deleteSimilarTable2ById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSimilarTable2ByIdInput!
  ): DeleteSimilarTable2Payload

  """Deletes a single \`NullTestRecord\` using a unique key."""
  deleteNullTestRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteNullTestRecordByIdInput!
  ): DeleteNullTestRecordPayload

  """Deletes a single \`LeftArm\` using a unique key."""
  deleteLeftArmById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteLeftArmByIdInput!
  ): DeleteLeftArmPayload

  """Deletes a single \`LeftArm\` using a unique key."""
  deleteLeftArmByPersonId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteLeftArmByPersonIdInput!
  ): DeleteLeftArmPayload

  """Deletes a single \`Issue756\` using a unique key."""
  deleteIssue756ById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteIssue756ByIdInput!
  ): DeleteIssue756Payload

  """Deletes a single \`Post\` using a unique key."""
  deletePostById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePostByIdInput!
  ): DeletePostPayload

  """Deletes a single \`Person\` using a unique key."""
  deletePersonById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePersonByIdInput!
  ): DeletePersonPayload

  """Deletes a single \`Person\` using a unique key."""
  deletePersonByEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePersonByEmailInput!
  ): DeletePersonPayload

  """Deletes a single \`Type\` using a unique key."""
  deleteTypeById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteTypeByIdInput!
  ): DeleteTypePayload
}

"""The output of our \`mutationOut\` mutation."""
type MutationOutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  o: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationOut\` mutation."""
input MutationOutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationOutSetof\` mutation."""
type MutationOutSetofPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  os: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationOutSetof\` mutation."""
input MutationOutSetofInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationOutUnnamed\` mutation."""
type MutationOutUnnamedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationOutUnnamed\` mutation."""
input MutationOutUnnamedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`noArgsMutation\` mutation."""
type NoArgsMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`noArgsMutation\` mutation."""
input NoArgsMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`returnVoidMutation\` mutation."""
type ReturnVoidMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`returnVoidMutation\` mutation."""
input ReturnVoidMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationIntervalSet\` mutation."""
type MutationIntervalSetPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  intervals: [Interval]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationIntervalSet\` mutation."""
input MutationIntervalSetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationInOut\` mutation."""
type MutationInOutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  o: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationInOut\` mutation."""
input MutationInOutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i: Int
}

"""The output of our \`mutationReturnsTableOneCol\` mutation."""
type MutationReturnsTableOneColPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  col1S: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationReturnsTableOneCol\` mutation."""
input MutationReturnsTableOneColInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i: Int
}

"""The output of our \`jsonIdentityMutation\` mutation."""
type JsonIdentityMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  json: JSON

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`jsonIdentityMutation\` mutation."""
input JsonIdentityMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  json: JSON
}

"""The output of our \`jsonbIdentityMutation\` mutation."""
type JsonbIdentityMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  json: JSON

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`jsonbIdentityMutation\` mutation."""
input JsonbIdentityMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  json: JSON
}

"""The output of our \`jsonbIdentityMutationPlpgsql\` mutation."""
type JsonbIdentityMutationPlpgsqlPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  json: JSON

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`jsonbIdentityMutationPlpgsql\` mutation."""
input JsonbIdentityMutationPlpgsqlInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _theJson: JSON!
}

"""The output of our \`jsonbIdentityMutationPlpgsqlWithDefault\` mutation."""
type JsonbIdentityMutationPlpgsqlWithDefaultPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  json: JSON

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`jsonbIdentityMutationPlpgsqlWithDefault\` mutation."""
input JsonbIdentityMutationPlpgsqlWithDefaultInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _theJson: JSON
}

"""The output of our \`add1Mutation\` mutation."""
type Add1MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add1Mutation\` mutation."""
input Add1MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

"""The output of our \`add2Mutation\` mutation."""
type Add2MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add2Mutation\` mutation."""
input Add2MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int!
  b: Int
}

"""The output of our \`add3Mutation\` mutation."""
type Add3MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add3Mutation\` mutation."""
input Add3MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  arg1: Int
}

"""The output of our \`add4Mutation\` mutation."""
type Add4MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add4Mutation\` mutation."""
input Add4MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int
  b: Int
}

"""The output of our \`add4MutationError\` mutation."""
type Add4MutationErrorPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`add4MutationError\` mutation."""
input Add4MutationErrorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int
  b: Int
}

"""The output of our \`mult1\` mutation."""
type Mult1Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mult1\` mutation."""
input Mult1Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int
  arg1: Int
}

"""The output of our \`mult2\` mutation."""
type Mult2Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mult2\` mutation."""
input Mult2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int
  arg1: Int
}

"""The output of our \`mult3\` mutation."""
type Mult3Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mult3\` mutation."""
input Mult3Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

"""The output of our \`mult4\` mutation."""
type Mult4Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mult4\` mutation."""
input Mult4Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

"""The output of our \`mutationInInout\` mutation."""
type MutationInInoutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  ino: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationInInout\` mutation."""
input MutationInInoutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i: Int
  ino: Int
}

"""The output of our \`mutationOutOut\` mutation."""
type MutationOutOutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: MutationOutOutRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type MutationOutOutRecord {
  firstOut: Int
  secondOut: String
}

"""All input for the \`mutationOutOut\` mutation."""
input MutationOutOutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationOutOutSetof\` mutation."""
type MutationOutOutSetofPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  results: [MutationOutOutSetofRecord]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type MutationOutOutSetofRecord {
  o1: Int
  o2: String
}

"""All input for the \`mutationOutOutSetof\` mutation."""
input MutationOutOutSetofInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationOutOutUnnamed\` mutation."""
type MutationOutOutUnnamedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: MutationOutOutUnnamedRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type MutationOutOutUnnamedRecord {
  arg1: Int
  arg2: String
}

"""All input for the \`mutationOutOutUnnamed\` mutation."""
input MutationOutOutUnnamedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`intSetMutation\` mutation."""
type IntSetMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integers: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`intSetMutation\` mutation."""
input IntSetMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  x: Int
  y: Int
  z: Int
}

"""The output of our \`mutationOutUnnamedOutOutUnnamed\` mutation."""
type MutationOutUnnamedOutOutUnnamedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: MutationOutUnnamedOutOutUnnamedRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type MutationOutUnnamedOutOutUnnamedRecord {
  arg1: Int
  o2: String
  arg3: Int
}

"""All input for the \`mutationOutUnnamedOutOutUnnamed\` mutation."""
input MutationOutUnnamedOutOutUnnamedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationReturnsTableMultiCol\` mutation."""
type MutationReturnsTableMultiColPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  results: [MutationReturnsTableMultiColRecord]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type MutationReturnsTableMultiColRecord {
  col1: Int
  col2: String
}

"""All input for the \`mutationReturnsTableMultiCol\` mutation."""
input MutationReturnsTableMultiColInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i: Int
}

"""The output of our \`guidFn\` mutation."""
type GuidFnPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  guid: Guid

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

scalar Guid

"""All input for the \`guidFn\` mutation."""
input GuidFnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  g: Guid
}

"""The output of our \`mutationIntervalArray\` mutation."""
type MutationIntervalArrayPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  intervals: [Interval]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationIntervalArray\` mutation."""
input MutationIntervalArrayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationTextArray\` mutation."""
type MutationTextArrayPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  strings: [String]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationTextArray\` mutation."""
input MutationTextArrayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`listBdeMutation\` mutation."""
type ListBdeMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  uuids: [UUID]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`listBdeMutation\` mutation."""
input ListBdeMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  b: [String]
  d: String
  e: String
}

"""The output of our \`authenticateFail\` mutation."""
type AuthenticateFailPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  jwtToken: JwtToken

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type JwtToken {
  role: String
  exp: BigInt
  a: Int
  b: BigFloat
  c: BigInt
}

"""All input for the \`authenticateFail\` mutation."""
input AuthenticateFailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`authenticate\` mutation."""
type AuthenticatePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  jwtToken: JwtToken

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`authenticate\` mutation."""
input AuthenticateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: BigFloat
  c: BigInt
}

"""The output of our \`leftArmIdentity\` mutation."""
type LeftArmIdentityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  leftArm: LeftArm

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`LeftArm\`. May be used by Relay 1."""
  leftArmEdge(
    """The method to use when ordering \`LeftArm\`."""
    orderBy: [LeftArmsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LeftArmsEdge

  """Reads a single \`Person\` that is related to this \`LeftArm\`."""
  personByPersonId: Person
}

"""All input for the \`leftArmIdentity\` mutation."""
input LeftArmIdentityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  leftArm: LeftArmBaseInput
}

"""An input representation of \`LeftArm\` with nullable fields."""
input LeftArmBaseInput {
  id: Int
  personId: Int
  lengthInMetres: Float
  mood: String
}

"""The output of our \`issue756Mutation\` mutation."""
type Issue756MutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  issue756: Issue756

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Issue756\`. May be used by Relay 1."""
  issue756Edge(
    """The method to use when ordering \`Issue756\`."""
    orderBy: [Issue756SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): Issue756SEdge
}

"""All input for the \`issue756Mutation\` mutation."""
input Issue756MutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`issue756SetMutation\` mutation."""
type Issue756SetMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  issue756S: [Issue756]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`issue756SetMutation\` mutation."""
input Issue756SetMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`authenticateMany\` mutation."""
type AuthenticateManyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  jwtTokens: [JwtToken]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`authenticateMany\` mutation."""
input AuthenticateManyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: BigFloat
  c: BigInt
}

"""The output of our \`authenticatePayload\` mutation."""
type AuthenticatePayloadPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  authPayload: AuthPayload

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single \`Person\` that is related to this \`AuthPayload\`."""
  personById: Person
}

type AuthPayload {
  jwt: JwtToken
  id: Int
  admin: Boolean

  """Reads a single \`Person\` that is related to this \`AuthPayload\`."""
  personById: Person
}

"""All input for the \`authenticatePayload\` mutation."""
input AuthenticatePayloadInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: BigFloat
  c: BigInt
}

"""The output of our \`typesMutation\` mutation."""
type TypesMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  boolean: Boolean

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`typesMutation\` mutation."""
input TypesMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: BigInt!
  b: Boolean!
  c: String!
  d: [Int]!
  e: JSON!
  f: FloatRangeInput!
}

"""The output of our \`mutationOutOutCompoundType\` mutation."""
type MutationOutOutCompoundTypePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: MutationOutOutCompoundTypeRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type MutationOutOutCompoundTypeRecord {
  o1: Int
  o2: CompoundType
}

"""All input for the \`mutationOutOutCompoundType\` mutation."""
input MutationOutOutCompoundTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  i1: Int
}

"""The output of our \`compoundTypeMutation\` mutation."""
type CompoundTypeMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  compoundType: CompoundType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`compoundTypeMutation\` mutation."""
input CompoundTypeMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  object: CompoundTypeInput
}

"""The output of our \`compoundTypeSetMutation\` mutation."""
type CompoundTypeSetMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  compoundTypes: [CompoundType]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`compoundTypeSetMutation\` mutation."""
input CompoundTypeSetMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  object: CompoundTypeInput
}

"""The output of our \`tableMutation\` mutation."""
type TableMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostsEdge

  """Reads a single \`Person\` that is related to this \`Post\`."""
  personByAuthorId: Person
}

"""All input for the \`tableMutation\` mutation."""
input TableMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int
}

"""The output of our \`postWithSuffix\` mutation."""
type PostWithSuffixPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostsEdge

  """Reads a single \`Person\` that is related to this \`Post\`."""
  personByAuthorId: Person
}

"""All input for the \`postWithSuffix\` mutation."""
input PostWithSuffixInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  post: PostInput
  suffix: String
}

"""An input for mutations affecting \`Post\`"""
input PostInput {
  id: Int
  headline: String!
  body: String
  authorId: Int
  enums: [AnEnum]
  comptypes: [ComptypeInput]
}

"""The output of our \`mutationCompoundTypeArray\` mutation."""
type MutationCompoundTypeArrayPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  compoundTypes: [CompoundType]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationCompoundTypeArray\` mutation."""
input MutationCompoundTypeArrayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  object: CompoundTypeInput
}

"""The output of our \`compoundTypeArrayMutation\` mutation."""
type CompoundTypeArrayMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  compoundTypes: [CompoundType]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`compoundTypeArrayMutation\` mutation."""
input CompoundTypeArrayMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  object: CompoundTypeInput
}

"""The output of our \`postMany\` mutation."""
type PostManyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  posts: [Post]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`postMany\` mutation."""
input PostManyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  posts: [PostInput]
}

"""The output of our \`mutationOutComplex\` mutation."""
type MutationOutComplexPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  result: MutationOutComplexRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type MutationOutComplexRecord {
  x: Int
  y: CompoundType
  z: Person
}

"""All input for the \`mutationOutComplex\` mutation."""
input MutationOutComplexInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: String
}

"""The output of our \`mutationOutComplexSetof\` mutation."""
type MutationOutComplexSetofPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  results: [MutationOutComplexSetofRecord]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type MutationOutComplexSetofRecord {
  x: Int
  y: CompoundType
  z: Person
}

"""All input for the \`mutationOutComplexSetof\` mutation."""
input MutationOutComplexSetofInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  a: Int
  b: String
}

"""The output of our \`mutationOutTable\` mutation."""
type MutationOutTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  person: Person

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Person\`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the \`mutationOutTable\` mutation."""
input MutationOutTableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`mutationOutTableSetof\` mutation."""
type MutationOutTableSetofPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  people: [Person]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`mutationOutTableSetof\` mutation."""
input MutationOutTableSetofInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`tableSetMutation\` mutation."""
type TableSetMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  people: [Person]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`tableSetMutation\` mutation."""
input TableSetMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`typeFunctionConnectionMutation\` mutation."""
type TypeFunctionConnectionMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  types: [Type]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`typeFunctionConnectionMutation\` mutation."""
input TypeFunctionConnectionMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our \`typeFunctionMutation\` mutation."""
type TypeFunctionMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  type: Type

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Type\`. May be used by Relay 1."""
  typeEdge(
    """The method to use when ordering \`Type\`."""
    orderBy: [TypesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TypesEdge

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postBySmallint: Post

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postById: Post
}

"""All input for the \`typeFunctionMutation\` mutation."""
input TypeFunctionMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int
}

"""The output of our \`typeFunctionListMutation\` mutation."""
type TypeFunctionListMutationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  types: [Type]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`typeFunctionListMutation\` mutation."""
input TypeFunctionListMutationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create \`Input\` mutation."""
type CreateInputPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Input\` that was created by this mutation."""
  input: Input

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Input\`. May be used by Relay 1."""
  inputEdge(
    """The method to use when ordering \`Input\`."""
    orderBy: [InputsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InputsEdge
}

"""All input for the create \`Input\` mutation."""
input CreateInputInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Input\` to be created by this mutation."""
  input: InputInput!
}

"""An input for mutations affecting \`Input\`"""
input InputInput {
  id: Int
}

"""The output of our create \`Patch\` mutation."""
type CreatePatchPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Patch\` that was created by this mutation."""
  patch: Patch

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Patch\`. May be used by Relay 1."""
  patchEdge(
    """The method to use when ordering \`Patch\`."""
    orderBy: [PatchesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PatchesEdge
}

"""All input for the create \`Patch\` mutation."""
input CreatePatchInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Patch\` to be created by this mutation."""
  patch: PatchInput!
}

"""An input for mutations affecting \`Patch\`"""
input PatchInput {
  id: Int
}

"""The output of our create \`Reserved\` mutation."""
type CreateReservedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Reserved\` that was created by this mutation."""
  reserved: Reserved

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Reserved\`. May be used by Relay 1."""
  reservedEdge(
    """The method to use when ordering \`Reserved\`."""
    orderBy: [ReservedsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedsEdge
}

"""All input for the create \`Reserved\` mutation."""
input CreateReservedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Reserved\` to be created by this mutation."""
  reserved: ReservedInput!
}

"""An input for mutations affecting \`Reserved\`"""
input ReservedInput {
  id: Int
}

"""The output of our create \`ReservedPatchRecord\` mutation."""
type CreateReservedPatchRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedPatchRecord\` that was created by this mutation."""
  reservedPatchRecord: ReservedPatchRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedPatchRecord\`. May be used by Relay 1."""
  reservedPatchRecordEdge(
    """The method to use when ordering \`ReservedPatchRecord\`."""
    orderBy: [ReservedPatchRecordsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedPatchRecordsEdge
}

"""All input for the create \`ReservedPatchRecord\` mutation."""
input CreateReservedPatchRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`ReservedPatchRecord\` to be created by this mutation."""
  reservedPatchRecord: ReservedPatchRecordInput!
}

"""An input for mutations affecting \`ReservedPatchRecord\`"""
input ReservedPatchRecordInput {
  id: Int
}

"""The output of our create \`ReservedInputRecord\` mutation."""
type CreateReservedInputRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedInputRecord\` that was created by this mutation."""
  reservedInputRecord: ReservedInputRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedInputRecord\`. May be used by Relay 1."""
  reservedInputRecordEdge(
    """The method to use when ordering \`ReservedInputRecord\`."""
    orderBy: [ReservedInputRecordsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedInputRecordsEdge
}

"""All input for the create \`ReservedInputRecord\` mutation."""
input CreateReservedInputRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`ReservedInputRecord\` to be created by this mutation."""
  reservedInputRecord: ReservedInputRecordInput!
}

"""An input for mutations affecting \`ReservedInputRecord\`"""
input ReservedInputRecordInput {
  id: Int
}

"""The output of our create \`DefaultValue\` mutation."""
type CreateDefaultValuePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`DefaultValue\` that was created by this mutation."""
  defaultValue: DefaultValue

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`DefaultValue\`. May be used by Relay 1."""
  defaultValueEdge(
    """The method to use when ordering \`DefaultValue\`."""
    orderBy: [DefaultValuesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DefaultValuesEdge
}

"""All input for the create \`DefaultValue\` mutation."""
input CreateDefaultValueInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`DefaultValue\` to be created by this mutation."""
  defaultValue: DefaultValueInput!
}

"""An input for mutations affecting \`DefaultValue\`"""
input DefaultValueInput {
  id: Int
  nullValue: String
}

"""The output of our create \`ForeignKey\` mutation."""
type CreateForeignKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ForeignKey\` that was created by this mutation."""
  foreignKey: ForeignKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single \`CompoundKey\` that is related to this \`ForeignKey\`."""
  compoundKeyByCompoundKey1AndCompoundKey2: CompoundKey

  """Reads a single \`Person\` that is related to this \`ForeignKey\`."""
  personByPersonId: Person
}

"""All input for the create \`ForeignKey\` mutation."""
input CreateForeignKeyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`ForeignKey\` to be created by this mutation."""
  foreignKey: ForeignKeyInput!
}

"""An input for mutations affecting \`ForeignKey\`"""
input ForeignKeyInput {
  personId: Int
  compoundKey1: Int
  compoundKey2: Int
}

"""The output of our create \`NoPrimaryKey\` mutation."""
type CreateNoPrimaryKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`NoPrimaryKey\` that was created by this mutation."""
  noPrimaryKey: NoPrimaryKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`NoPrimaryKey\` mutation."""
input CreateNoPrimaryKeyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`NoPrimaryKey\` to be created by this mutation."""
  noPrimaryKey: NoPrimaryKeyInput!
}

"""An input for mutations affecting \`NoPrimaryKey\`"""
input NoPrimaryKeyInput {
  id: Int!
  str: String!
}

"""The output of our create \`Testview\` mutation."""
type CreateTestviewPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Testview\` that was created by this mutation."""
  testview: Testview

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`Testview\` mutation."""
input CreateTestviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Testview\` to be created by this mutation."""
  testview: TestviewInput!
}

"""An input for mutations affecting \`Testview\`"""
input TestviewInput {
  testviewid: Int
  col1: Int
  col2: Int
}

"""The output of our create \`MyTable\` mutation."""
type CreateMyTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`MyTable\` that was created by this mutation."""
  myTable: MyTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`MyTable\`. May be used by Relay 1."""
  myTableEdge(
    """The method to use when ordering \`MyTable\`."""
    orderBy: [MyTablesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): MyTablesEdge
}

"""All input for the create \`MyTable\` mutation."""
input CreateMyTableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`MyTable\` to be created by this mutation."""
  myTable: MyTableInput!
}

"""An input for mutations affecting \`MyTable\`"""
input MyTableInput {
  id: Int
  jsonData: JSON
}

"""The output of our create \`PersonSecret\` mutation."""
type CreatePersonSecretPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PersonSecret\` that was created by this mutation."""
  personSecret: PersonSecret @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PersonSecret\`. May be used by Relay 1."""
  personSecretEdge(
    """The method to use when ordering \`PersonSecret\`."""
    orderBy: [PersonSecretsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PersonSecretsEdge @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """The \`Person\` this \`PersonSecret\` belongs to."""
  personByPersonId: Person
}

"""All input for the create \`PersonSecret\` mutation."""
input CreatePersonSecretInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`PersonSecret\` to be created by this mutation."""
  personSecret: PersonSecretInput!
}

"""An input for mutations affecting \`PersonSecret\`"""
input PersonSecretInput {
  personId: Int!

  """A secret held by the associated Person"""
  secret: String
}

"""The output of our create \`ViewTable\` mutation."""
type CreateViewTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ViewTable\` that was created by this mutation."""
  viewTable: ViewTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ViewTable\`. May be used by Relay 1."""
  viewTableEdge(
    """The method to use when ordering \`ViewTable\`."""
    orderBy: [ViewTablesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ViewTablesEdge
}

"""All input for the create \`ViewTable\` mutation."""
input CreateViewTableInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`ViewTable\` to be created by this mutation."""
  viewTable: ViewTableInput!
}

"""An input for mutations affecting \`ViewTable\`"""
input ViewTableInput {
  id: Int
  col1: Int
  col2: Int
}

"""The output of our create \`CompoundKey\` mutation."""
type CreateCompoundKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CompoundKey\` that was created by this mutation."""
  compoundKey: CompoundKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CompoundKey\`. May be used by Relay 1."""
  compoundKeyEdge(
    """The method to use when ordering \`CompoundKey\`."""
    orderBy: [CompoundKeysOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CompoundKeysEdge

  """Reads a single \`Person\` that is related to this \`CompoundKey\`."""
  personByPersonId1: Person

  """Reads a single \`Person\` that is related to this \`CompoundKey\`."""
  personByPersonId2: Person
}

"""All input for the create \`CompoundKey\` mutation."""
input CreateCompoundKeyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`CompoundKey\` to be created by this mutation."""
  compoundKey: CompoundKeyInput!
}

"""An input for mutations affecting \`CompoundKey\`"""
input CompoundKeyInput {
  personId2: Int!
  personId1: Int!
  extra: Boolean
}

"""The output of our create \`SimilarTable1\` mutation."""
type CreateSimilarTable1Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable1\` that was created by this mutation."""
  similarTable1: SimilarTable1

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable1\`. May be used by Relay 1."""
  similarTable1Edge(
    """The method to use when ordering \`SimilarTable1\`."""
    orderBy: [SimilarTable1SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable1SEdge
}

"""All input for the create \`SimilarTable1\` mutation."""
input CreateSimilarTable1Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`SimilarTable1\` to be created by this mutation."""
  similarTable1: SimilarTable1Input!
}

"""An input for mutations affecting \`SimilarTable1\`"""
input SimilarTable1Input {
  id: Int
  col1: Int
  col2: Int
  col3: Int!
}

"""The output of our create \`SimilarTable2\` mutation."""
type CreateSimilarTable2Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable2\` that was created by this mutation."""
  similarTable2: SimilarTable2

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable2\`. May be used by Relay 1."""
  similarTable2Edge(
    """The method to use when ordering \`SimilarTable2\`."""
    orderBy: [SimilarTable2SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable2SEdge
}

"""All input for the create \`SimilarTable2\` mutation."""
input CreateSimilarTable2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`SimilarTable2\` to be created by this mutation."""
  similarTable2: SimilarTable2Input!
}

"""An input for mutations affecting \`SimilarTable2\`"""
input SimilarTable2Input {
  id: Int
  col3: Int!
  col4: Int
  col5: Int
}

"""The output of our create \`UpdatableView\` mutation."""
type CreateUpdatableViewPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UpdatableView\` that was created by this mutation."""
  updatableView: UpdatableView

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`UpdatableView\` mutation."""
input CreateUpdatableViewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`UpdatableView\` to be created by this mutation."""
  updatableView: UpdatableViewInput!
}

"""An input for mutations affecting \`UpdatableView\`"""
input UpdatableViewInput {
  x: Int
  name: String
  description: String

  """This is constantly 2"""
  constant: Int
}

"""The output of our create \`NullTestRecord\` mutation."""
type CreateNullTestRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`NullTestRecord\` that was created by this mutation."""
  nullTestRecord: NullTestRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`NullTestRecord\`. May be used by Relay 1."""
  nullTestRecordEdge(
    """The method to use when ordering \`NullTestRecord\`."""
    orderBy: [NullTestRecordsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): NullTestRecordsEdge
}

"""All input for the create \`NullTestRecord\` mutation."""
input CreateNullTestRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`NullTestRecord\` to be created by this mutation."""
  nullTestRecord: NullTestRecordInput!
}

"""An input for mutations affecting \`NullTestRecord\`"""
input NullTestRecordInput {
  id: Int
  nullableText: String
  nullableInt: Int
  nonNullText: String!
}

"""The output of our create \`EdgeCase\` mutation."""
type CreateEdgeCasePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`EdgeCase\` that was created by this mutation."""
  edgeCase: EdgeCase

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create \`EdgeCase\` mutation."""
input CreateEdgeCaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`EdgeCase\` to be created by this mutation."""
  edgeCase: EdgeCaseInput!
}

"""An input for mutations affecting \`EdgeCase\`"""
input EdgeCaseInput {
  notNullHasDefault: Boolean
  wontCastEasy: Int
  rowId: Int
}

"""The output of our create \`LeftArm\` mutation."""
type CreateLeftArmPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`LeftArm\` that was created by this mutation."""
  leftArm: LeftArm

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`LeftArm\`. May be used by Relay 1."""
  leftArmEdge(
    """The method to use when ordering \`LeftArm\`."""
    orderBy: [LeftArmsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LeftArmsEdge

  """Reads a single \`Person\` that is related to this \`LeftArm\`."""
  personByPersonId: Person
}

"""All input for the create \`LeftArm\` mutation."""
input CreateLeftArmInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`LeftArm\` to be created by this mutation."""
  leftArm: LeftArmInput!
}

"""An input for mutations affecting \`LeftArm\`"""
input LeftArmInput {
  id: Int
  personId: Int
  lengthInMetres: Float
  mood: String
}

"""The output of our create \`Issue756\` mutation."""
type CreateIssue756Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Issue756\` that was created by this mutation."""
  issue756: Issue756

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Issue756\`. May be used by Relay 1."""
  issue756Edge(
    """The method to use when ordering \`Issue756\`."""
    orderBy: [Issue756SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): Issue756SEdge
}

"""All input for the create \`Issue756\` mutation."""
input CreateIssue756Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Issue756\` to be created by this mutation."""
  issue756: Issue756Input!
}

"""An input for mutations affecting \`Issue756\`"""
input Issue756Input {
  id: Int
  ts: NotNullTimestamp
}

"""The output of our create \`Post\` mutation."""
type CreatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was created by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostsEdge

  """Reads a single \`Person\` that is related to this \`Post\`."""
  personByAuthorId: Person
}

"""All input for the create \`Post\` mutation."""
input CreatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Post\` to be created by this mutation."""
  post: PostInput!
}

"""The output of our create \`Person\` mutation."""
type CreatePersonPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Person\` that was created by this mutation."""
  person: Person

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Person\`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the create \`Person\` mutation."""
input CreatePersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Person\` to be created by this mutation."""
  person: PersonInput!
}

"""An input for mutations affecting \`Person\`"""
input PersonInput {
  """The primary unique identifier for the person"""
  id: Int

  """The persons name"""
  name: String!
  aliases: [String]
  about: String
  email: Email!
  site: WrappedUrlInput
  config: KeyValueHash
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: String
  userMac: String
  createdAt: Datetime
}

"""The output of our create \`Type\` mutation."""
type CreateTypePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Type\` that was created by this mutation."""
  type: Type

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Type\`. May be used by Relay 1."""
  typeEdge(
    """The method to use when ordering \`Type\`."""
    orderBy: [TypesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TypesEdge

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postBySmallint: Post

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postById: Post
}

"""All input for the create \`Type\` mutation."""
input CreateTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Type\` to be created by this mutation."""
  type: TypeInput!
}

"""An input for mutations affecting \`Type\`"""
input TypeInput {
  id: Int
  smallint: Int!
  bigint: BigInt!
  numeric: BigFloat!
  decimal: BigFloat!
  boolean: Boolean!
  varchar: String!
  enum: Color!
  enumArray: [Color]!
  domain: AnInt!
  domain2: AnotherInt!
  textArray: [String]!
  json: JSON!
  jsonb: JSON!
  nullableRange: BigFloatRangeInput
  numrange: BigFloatRangeInput!
  daterange: DateRangeInput!
  anIntRange: AnIntRangeInput!
  timestamp: Datetime!
  timestamptz: Datetime!
  date: Date!
  time: Time!
  timetz: Time!
  interval: IntervalInput!
  intervalArray: [IntervalInput]!
  money: Float!
  compoundType: CompoundTypeInput!
  nestedCompoundType: NestedCompoundTypeInput!
  nullableCompoundType: CompoundTypeInput
  nullableNestedCompoundType: NestedCompoundTypeInput
  point: PointInput!
  nullablePoint: PointInput
  inet: InternetAddress
  cidr: String
  macaddr: String
  regproc: RegProc
  regprocedure: RegProcedure
  regoper: RegOper
  regoperator: RegOperator
  regclass: RegClass
  regtype: RegType
  regconfig: RegConfig
  regdictionary: RegDictionary
  textArrayDomain: [String]
  int8ArrayDomain: [BigInt]
  bytea: Base64EncodedBinary
  byteaArray: [Base64EncodedBinary]
  ltree: LTree
  ltreeArray: [LTree]
}

"""The output of our update \`Input\` mutation."""
type UpdateInputPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Input\` that was updated by this mutation."""
  input: Input

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Input\`. May be used by Relay 1."""
  inputEdge(
    """The method to use when ordering \`Input\`."""
    orderBy: [InputsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InputsEdge
}

"""All input for the \`updateInputById\` mutation."""
input UpdateInputByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`Input\` being updated.
  """
  inputPatch: InputPatch!
}

"""
Represents an update to a \`Input\`. Fields that are set will be updated.
"""
input InputPatch {
  id: Int
}

"""The output of our update \`Patch\` mutation."""
type UpdatePatchPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Patch\` that was updated by this mutation."""
  patch: Patch

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Patch\`. May be used by Relay 1."""
  patchEdge(
    """The method to use when ordering \`Patch\`."""
    orderBy: [PatchesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PatchesEdge
}

"""All input for the \`updatePatchById\` mutation."""
input UpdatePatchByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`Patch\` being updated.
  """
  patchPatch: PatchPatch!
}

"""
Represents an update to a \`Patch\`. Fields that are set will be updated.
"""
input PatchPatch {
  id: Int
}

"""The output of our update \`Reserved\` mutation."""
type UpdateReservedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Reserved\` that was updated by this mutation."""
  reserved: Reserved

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Reserved\`. May be used by Relay 1."""
  reservedEdge(
    """The method to use when ordering \`Reserved\`."""
    orderBy: [ReservedsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedsEdge
}

"""All input for the \`updateReservedById\` mutation."""
input UpdateReservedByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`Reserved\` being updated.
  """
  reservedPatch: ReservedPatch!
}

"""
Represents an update to a \`Reserved\`. Fields that are set will be updated.
"""
input ReservedPatch {
  id: Int
}

"""The output of our update \`ReservedPatchRecord\` mutation."""
type UpdateReservedPatchRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedPatchRecord\` that was updated by this mutation."""
  reservedPatchRecord: ReservedPatchRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedPatchRecord\`. May be used by Relay 1."""
  reservedPatchRecordEdge(
    """The method to use when ordering \`ReservedPatchRecord\`."""
    orderBy: [ReservedPatchRecordsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedPatchRecordsEdge
}

"""All input for the \`updateReservedPatchRecordById\` mutation."""
input UpdateReservedPatchRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`ReservedPatchRecord\` being updated.
  """
  reservedPatchRecordPatch: ReservedPatchRecordPatch!
}

"""
Represents an update to a \`ReservedPatchRecord\`. Fields that are set will be updated.
"""
input ReservedPatchRecordPatch {
  id: Int
}

"""The output of our update \`ReservedInputRecord\` mutation."""
type UpdateReservedInputRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedInputRecord\` that was updated by this mutation."""
  reservedInputRecord: ReservedInputRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedInputRecord\`. May be used by Relay 1."""
  reservedInputRecordEdge(
    """The method to use when ordering \`ReservedInputRecord\`."""
    orderBy: [ReservedInputRecordsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedInputRecordsEdge
}

"""All input for the \`updateReservedInputRecordById\` mutation."""
input UpdateReservedInputRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`ReservedInputRecord\` being updated.
  """
  reservedInputRecordPatch: ReservedInputRecordPatch!
}

"""
Represents an update to a \`ReservedInputRecord\`. Fields that are set will be updated.
"""
input ReservedInputRecordPatch {
  id: Int
}

"""The output of our update \`DefaultValue\` mutation."""
type UpdateDefaultValuePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`DefaultValue\` that was updated by this mutation."""
  defaultValue: DefaultValue

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`DefaultValue\`. May be used by Relay 1."""
  defaultValueEdge(
    """The method to use when ordering \`DefaultValue\`."""
    orderBy: [DefaultValuesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DefaultValuesEdge
}

"""All input for the \`updateDefaultValueById\` mutation."""
input UpdateDefaultValueByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`DefaultValue\` being updated.
  """
  defaultValuePatch: DefaultValuePatch!
}

"""
Represents an update to a \`DefaultValue\`. Fields that are set will be updated.
"""
input DefaultValuePatch {
  id: Int
  nullValue: String
}

"""The output of our update \`NoPrimaryKey\` mutation."""
type UpdateNoPrimaryKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`NoPrimaryKey\` that was updated by this mutation."""
  noPrimaryKey: NoPrimaryKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`updateNoPrimaryKeyById\` mutation."""
input UpdateNoPrimaryKeyByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`NoPrimaryKey\` being updated.
  """
  noPrimaryKeyPatch: NoPrimaryKeyPatch!
}

"""
Represents an update to a \`NoPrimaryKey\`. Fields that are set will be updated.
"""
input NoPrimaryKeyPatch {
  id: Int
  str: String
}

"""The output of our update \`MyTable\` mutation."""
type UpdateMyTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`MyTable\` that was updated by this mutation."""
  myTable: MyTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`MyTable\`. May be used by Relay 1."""
  myTableEdge(
    """The method to use when ordering \`MyTable\`."""
    orderBy: [MyTablesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): MyTablesEdge
}

"""All input for the \`updateMyTableById\` mutation."""
input UpdateMyTableByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`MyTable\` being updated.
  """
  myTablePatch: MyTablePatch!
}

"""
Represents an update to a \`MyTable\`. Fields that are set will be updated.
"""
input MyTablePatch {
  id: Int
  jsonData: JSON
}

"""The output of our update \`PersonSecret\` mutation."""
type UpdatePersonSecretPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PersonSecret\` that was updated by this mutation."""
  personSecret: PersonSecret

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PersonSecret\`. May be used by Relay 1."""
  personSecretEdge(
    """The method to use when ordering \`PersonSecret\`."""
    orderBy: [PersonSecretsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PersonSecretsEdge @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """The \`Person\` this \`PersonSecret\` belongs to."""
  personByPersonId: Person
}

"""All input for the \`updatePersonSecretByPersonId\` mutation."""
input UpdatePersonSecretByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!

  """
  An object where the defined keys will be set on the \`PersonSecret\` being updated.
  """
  personSecretPatch: PersonSecretPatch!
}

"""
Represents an update to a \`PersonSecret\`. Fields that are set will be updated.
"""
input PersonSecretPatch {
  personId: Int

  """A secret held by the associated Person"""
  secret: String
}

"""The output of our update \`ViewTable\` mutation."""
type UpdateViewTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ViewTable\` that was updated by this mutation."""
  viewTable: ViewTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ViewTable\`. May be used by Relay 1."""
  viewTableEdge(
    """The method to use when ordering \`ViewTable\`."""
    orderBy: [ViewTablesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ViewTablesEdge
}

"""All input for the \`updateViewTableById\` mutation."""
input UpdateViewTableByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`ViewTable\` being updated.
  """
  viewTablePatch: ViewTablePatch!
}

"""
Represents an update to a \`ViewTable\`. Fields that are set will be updated.
"""
input ViewTablePatch {
  id: Int
  col1: Int
  col2: Int
}

"""The output of our update \`CompoundKey\` mutation."""
type UpdateCompoundKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CompoundKey\` that was updated by this mutation."""
  compoundKey: CompoundKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CompoundKey\`. May be used by Relay 1."""
  compoundKeyEdge(
    """The method to use when ordering \`CompoundKey\`."""
    orderBy: [CompoundKeysOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CompoundKeysEdge

  """Reads a single \`Person\` that is related to this \`CompoundKey\`."""
  personByPersonId1: Person

  """Reads a single \`Person\` that is related to this \`CompoundKey\`."""
  personByPersonId2: Person
}

"""All input for the \`updateCompoundKeyByPersonId1AndPersonId2\` mutation."""
input UpdateCompoundKeyByPersonId1AndPersonId2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId1: Int!
  personId2: Int!

  """
  An object where the defined keys will be set on the \`CompoundKey\` being updated.
  """
  compoundKeyPatch: CompoundKeyPatch!
}

"""
Represents an update to a \`CompoundKey\`. Fields that are set will be updated.
"""
input CompoundKeyPatch {
  personId2: Int
  personId1: Int
  extra: Boolean
}

"""The output of our update \`SimilarTable1\` mutation."""
type UpdateSimilarTable1Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable1\` that was updated by this mutation."""
  similarTable1: SimilarTable1

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable1\`. May be used by Relay 1."""
  similarTable1Edge(
    """The method to use when ordering \`SimilarTable1\`."""
    orderBy: [SimilarTable1SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable1SEdge
}

"""All input for the \`updateSimilarTable1ById\` mutation."""
input UpdateSimilarTable1ByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`SimilarTable1\` being updated.
  """
  similarTable1Patch: SimilarTable1Patch!
}

"""
Represents an update to a \`SimilarTable1\`. Fields that are set will be updated.
"""
input SimilarTable1Patch {
  id: Int
  col1: Int
  col2: Int
  col3: Int
}

"""The output of our update \`SimilarTable2\` mutation."""
type UpdateSimilarTable2Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable2\` that was updated by this mutation."""
  similarTable2: SimilarTable2

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable2\`. May be used by Relay 1."""
  similarTable2Edge(
    """The method to use when ordering \`SimilarTable2\`."""
    orderBy: [SimilarTable2SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable2SEdge
}

"""All input for the \`updateSimilarTable2ById\` mutation."""
input UpdateSimilarTable2ByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`SimilarTable2\` being updated.
  """
  similarTable2Patch: SimilarTable2Patch!
}

"""
Represents an update to a \`SimilarTable2\`. Fields that are set will be updated.
"""
input SimilarTable2Patch {
  id: Int
  col3: Int
  col4: Int
  col5: Int
}

"""The output of our update \`NullTestRecord\` mutation."""
type UpdateNullTestRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`NullTestRecord\` that was updated by this mutation."""
  nullTestRecord: NullTestRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`NullTestRecord\`. May be used by Relay 1."""
  nullTestRecordEdge(
    """The method to use when ordering \`NullTestRecord\`."""
    orderBy: [NullTestRecordsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): NullTestRecordsEdge
}

"""All input for the \`updateNullTestRecordById\` mutation."""
input UpdateNullTestRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`NullTestRecord\` being updated.
  """
  nullTestRecordPatch: NullTestRecordPatch!
}

"""
Represents an update to a \`NullTestRecord\`. Fields that are set will be updated.
"""
input NullTestRecordPatch {
  id: Int
  nullableText: String
  nullableInt: Int
  nonNullText: String
}

"""The output of our update \`LeftArm\` mutation."""
type UpdateLeftArmPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`LeftArm\` that was updated by this mutation."""
  leftArm: LeftArm

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`LeftArm\`. May be used by Relay 1."""
  leftArmEdge(
    """The method to use when ordering \`LeftArm\`."""
    orderBy: [LeftArmsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LeftArmsEdge

  """Reads a single \`Person\` that is related to this \`LeftArm\`."""
  personByPersonId: Person
}

"""All input for the \`updateLeftArmById\` mutation."""
input UpdateLeftArmByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`LeftArm\` being updated.
  """
  leftArmPatch: LeftArmPatch!
}

"""
Represents an update to a \`LeftArm\`. Fields that are set will be updated.
"""
input LeftArmPatch {
  id: Int
  personId: Int
  lengthInMetres: Float
  mood: String
}

"""All input for the \`updateLeftArmByPersonId\` mutation."""
input UpdateLeftArmByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!

  """
  An object where the defined keys will be set on the \`LeftArm\` being updated.
  """
  leftArmPatch: LeftArmPatch!
}

"""The output of our update \`Issue756\` mutation."""
type UpdateIssue756Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Issue756\` that was updated by this mutation."""
  issue756: Issue756

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Issue756\`. May be used by Relay 1."""
  issue756Edge(
    """The method to use when ordering \`Issue756\`."""
    orderBy: [Issue756SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): Issue756SEdge
}

"""All input for the \`updateIssue756ById\` mutation."""
input UpdateIssue756ByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`Issue756\` being updated.
  """
  issue756Patch: Issue756Patch!
}

"""
Represents an update to a \`Issue756\`. Fields that are set will be updated.
"""
input Issue756Patch {
  id: Int
  ts: NotNullTimestamp
}

"""The output of our update \`Post\` mutation."""
type UpdatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was updated by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostsEdge

  """Reads a single \`Person\` that is related to this \`Post\`."""
  personByAuthorId: Person
}

"""All input for the \`updatePostById\` mutation."""
input UpdatePostByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`Post\` being updated.
  """
  postPatch: PostPatch!
}

"""Represents an update to a \`Post\`. Fields that are set will be updated."""
input PostPatch {
  id: Int
  headline: String
  body: String
  authorId: Int
  enums: [AnEnum]
  comptypes: [ComptypeInput]
}

"""The output of our update \`Person\` mutation."""
type UpdatePersonPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Person\` that was updated by this mutation."""
  person: Person

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Person\`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the \`updatePersonById\` mutation."""
input UpdatePersonByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The primary unique identifier for the person"""
  id: Int!

  """
  An object where the defined keys will be set on the \`Person\` being updated.
  """
  personPatch: PersonPatch!
}

"""
Represents an update to a \`Person\`. Fields that are set will be updated.
"""
input PersonPatch {
  """The primary unique identifier for the person"""
  id: Int

  """The persons name"""
  name: String
  aliases: [String]
  about: String
  email: Email
  site: WrappedUrlInput
  config: KeyValueHash
  lastLoginFromIp: InternetAddress
  lastLoginFromSubnet: String
  userMac: String
  createdAt: Datetime
}

"""All input for the \`updatePersonByEmail\` mutation."""
input UpdatePersonByEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: Email!

  """
  An object where the defined keys will be set on the \`Person\` being updated.
  """
  personPatch: PersonPatch!
}

"""The output of our update \`Type\` mutation."""
type UpdateTypePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Type\` that was updated by this mutation."""
  type: Type

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Type\`. May be used by Relay 1."""
  typeEdge(
    """The method to use when ordering \`Type\`."""
    orderBy: [TypesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TypesEdge

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postBySmallint: Post

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postById: Post
}

"""All input for the \`updateTypeById\` mutation."""
input UpdateTypeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the \`Type\` being updated.
  """
  typePatch: TypePatch!
}

"""Represents an update to a \`Type\`. Fields that are set will be updated."""
input TypePatch {
  id: Int
  smallint: Int
  bigint: BigInt
  numeric: BigFloat
  decimal: BigFloat
  boolean: Boolean
  varchar: String
  enum: Color
  enumArray: [Color]
  domain: AnInt
  domain2: AnotherInt
  textArray: [String]
  json: JSON
  jsonb: JSON
  nullableRange: BigFloatRangeInput
  numrange: BigFloatRangeInput
  daterange: DateRangeInput
  anIntRange: AnIntRangeInput
  timestamp: Datetime
  timestamptz: Datetime
  date: Date
  time: Time
  timetz: Time
  interval: IntervalInput
  intervalArray: [IntervalInput]
  money: Float
  compoundType: CompoundTypeInput
  nestedCompoundType: NestedCompoundTypeInput
  nullableCompoundType: CompoundTypeInput
  nullableNestedCompoundType: NestedCompoundTypeInput
  point: PointInput
  nullablePoint: PointInput
  inet: InternetAddress
  cidr: String
  macaddr: String
  regproc: RegProc
  regprocedure: RegProcedure
  regoper: RegOper
  regoperator: RegOperator
  regclass: RegClass
  regtype: RegType
  regconfig: RegConfig
  regdictionary: RegDictionary
  textArrayDomain: [String]
  int8ArrayDomain: [BigInt]
  bytea: Base64EncodedBinary
  byteaArray: [Base64EncodedBinary]
  ltree: LTree
  ltreeArray: [LTree]
}

"""The output of our delete \`Input\` mutation."""
type DeleteInputPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Input\` that was deleted by this mutation."""
  input: Input

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Input\`. May be used by Relay 1."""
  inputEdge(
    """The method to use when ordering \`Input\`."""
    orderBy: [InputsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InputsEdge
}

"""All input for the \`deleteInputById\` mutation."""
input DeleteInputByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`Patch\` mutation."""
type DeletePatchPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Patch\` that was deleted by this mutation."""
  patch: Patch

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Patch\`. May be used by Relay 1."""
  patchEdge(
    """The method to use when ordering \`Patch\`."""
    orderBy: [PatchesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PatchesEdge
}

"""All input for the \`deletePatchById\` mutation."""
input DeletePatchByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`Reserved\` mutation."""
type DeleteReservedPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Reserved\` that was deleted by this mutation."""
  reserved: Reserved

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Reserved\`. May be used by Relay 1."""
  reservedEdge(
    """The method to use when ordering \`Reserved\`."""
    orderBy: [ReservedsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedsEdge
}

"""All input for the \`deleteReservedById\` mutation."""
input DeleteReservedByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`ReservedPatchRecord\` mutation."""
type DeleteReservedPatchRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedPatchRecord\` that was deleted by this mutation."""
  reservedPatchRecord: ReservedPatchRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedPatchRecord\`. May be used by Relay 1."""
  reservedPatchRecordEdge(
    """The method to use when ordering \`ReservedPatchRecord\`."""
    orderBy: [ReservedPatchRecordsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedPatchRecordsEdge
}

"""All input for the \`deleteReservedPatchRecordById\` mutation."""
input DeleteReservedPatchRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`ReservedInputRecord\` mutation."""
type DeleteReservedInputRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ReservedInputRecord\` that was deleted by this mutation."""
  reservedInputRecord: ReservedInputRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ReservedInputRecord\`. May be used by Relay 1."""
  reservedInputRecordEdge(
    """The method to use when ordering \`ReservedInputRecord\`."""
    orderBy: [ReservedInputRecordsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ReservedInputRecordsEdge
}

"""All input for the \`deleteReservedInputRecordById\` mutation."""
input DeleteReservedInputRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`DefaultValue\` mutation."""
type DeleteDefaultValuePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`DefaultValue\` that was deleted by this mutation."""
  defaultValue: DefaultValue

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`DefaultValue\`. May be used by Relay 1."""
  defaultValueEdge(
    """The method to use when ordering \`DefaultValue\`."""
    orderBy: [DefaultValuesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DefaultValuesEdge
}

"""All input for the \`deleteDefaultValueById\` mutation."""
input DeleteDefaultValueByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`NoPrimaryKey\` mutation."""
type DeleteNoPrimaryKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`NoPrimaryKey\` that was deleted by this mutation."""
  noPrimaryKey: NoPrimaryKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the \`deleteNoPrimaryKeyById\` mutation."""
input DeleteNoPrimaryKeyByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`MyTable\` mutation."""
type DeleteMyTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`MyTable\` that was deleted by this mutation."""
  myTable: MyTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`MyTable\`. May be used by Relay 1."""
  myTableEdge(
    """The method to use when ordering \`MyTable\`."""
    orderBy: [MyTablesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): MyTablesEdge
}

"""All input for the \`deleteMyTableById\` mutation."""
input DeleteMyTableByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`PersonSecret\` mutation."""
type DeletePersonSecretPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PersonSecret\` that was deleted by this mutation."""
  personSecret: PersonSecret

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PersonSecret\`. May be used by Relay 1."""
  personSecretEdge(
    """The method to use when ordering \`PersonSecret\`."""
    orderBy: [PersonSecretsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PersonSecretsEdge @deprecated(reason: "This is deprecated (comment on table c.person_secret).")

  """The \`Person\` this \`PersonSecret\` belongs to."""
  personByPersonId: Person
}

"""All input for the \`deletePersonSecretByPersonId\` mutation."""
input DeletePersonSecretByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!
}

"""The output of our delete \`ViewTable\` mutation."""
type DeleteViewTablePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`ViewTable\` that was deleted by this mutation."""
  viewTable: ViewTable

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`ViewTable\`. May be used by Relay 1."""
  viewTableEdge(
    """The method to use when ordering \`ViewTable\`."""
    orderBy: [ViewTablesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ViewTablesEdge
}

"""All input for the \`deleteViewTableById\` mutation."""
input DeleteViewTableByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`CompoundKey\` mutation."""
type DeleteCompoundKeyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`CompoundKey\` that was deleted by this mutation."""
  compoundKey: CompoundKey

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`CompoundKey\`. May be used by Relay 1."""
  compoundKeyEdge(
    """The method to use when ordering \`CompoundKey\`."""
    orderBy: [CompoundKeysOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CompoundKeysEdge

  """Reads a single \`Person\` that is related to this \`CompoundKey\`."""
  personByPersonId1: Person

  """Reads a single \`Person\` that is related to this \`CompoundKey\`."""
  personByPersonId2: Person
}

"""All input for the \`deleteCompoundKeyByPersonId1AndPersonId2\` mutation."""
input DeleteCompoundKeyByPersonId1AndPersonId2Input {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId1: Int!
  personId2: Int!
}

"""The output of our delete \`SimilarTable1\` mutation."""
type DeleteSimilarTable1Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable1\` that was deleted by this mutation."""
  similarTable1: SimilarTable1

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable1\`. May be used by Relay 1."""
  similarTable1Edge(
    """The method to use when ordering \`SimilarTable1\`."""
    orderBy: [SimilarTable1SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable1SEdge
}

"""All input for the \`deleteSimilarTable1ById\` mutation."""
input DeleteSimilarTable1ByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`SimilarTable2\` mutation."""
type DeleteSimilarTable2Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SimilarTable2\` that was deleted by this mutation."""
  similarTable2: SimilarTable2

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SimilarTable2\`. May be used by Relay 1."""
  similarTable2Edge(
    """The method to use when ordering \`SimilarTable2\`."""
    orderBy: [SimilarTable2SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SimilarTable2SEdge
}

"""All input for the \`deleteSimilarTable2ById\` mutation."""
input DeleteSimilarTable2ByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`NullTestRecord\` mutation."""
type DeleteNullTestRecordPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`NullTestRecord\` that was deleted by this mutation."""
  nullTestRecord: NullTestRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`NullTestRecord\`. May be used by Relay 1."""
  nullTestRecordEdge(
    """The method to use when ordering \`NullTestRecord\`."""
    orderBy: [NullTestRecordsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): NullTestRecordsEdge
}

"""All input for the \`deleteNullTestRecordById\` mutation."""
input DeleteNullTestRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`LeftArm\` mutation."""
type DeleteLeftArmPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`LeftArm\` that was deleted by this mutation."""
  leftArm: LeftArm

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`LeftArm\`. May be used by Relay 1."""
  leftArmEdge(
    """The method to use when ordering \`LeftArm\`."""
    orderBy: [LeftArmsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LeftArmsEdge

  """Reads a single \`Person\` that is related to this \`LeftArm\`."""
  personByPersonId: Person
}

"""All input for the \`deleteLeftArmById\` mutation."""
input DeleteLeftArmByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""All input for the \`deleteLeftArmByPersonId\` mutation."""
input DeleteLeftArmByPersonIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: Int!
}

"""The output of our delete \`Issue756\` mutation."""
type DeleteIssue756Payload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Issue756\` that was deleted by this mutation."""
  issue756: Issue756

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Issue756\`. May be used by Relay 1."""
  issue756Edge(
    """The method to use when ordering \`Issue756\`."""
    orderBy: [Issue756SOrderBy!]! = [PRIMARY_KEY_ASC]
  ): Issue756SEdge
}

"""All input for the \`deleteIssue756ById\` mutation."""
input DeleteIssue756ByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`Post\` mutation."""
type DeletePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was deleted by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostsOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostsEdge

  """Reads a single \`Person\` that is related to this \`Post\`."""
  personByAuthorId: Person
}

"""All input for the \`deletePostById\` mutation."""
input DeletePostByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete \`Person\` mutation."""
type DeletePersonPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Person\` that was deleted by this mutation."""
  person: Person

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Person\`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering \`Person\`."""
    orderBy: [PeopleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the \`deletePersonById\` mutation."""
input DeletePersonByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The primary unique identifier for the person"""
  id: Int!
}

"""All input for the \`deletePersonByEmail\` mutation."""
input DeletePersonByEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: Email!
}

"""The output of our delete \`Type\` mutation."""
type DeleteTypePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Type\` that was deleted by this mutation."""
  type: Type

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Type\`. May be used by Relay 1."""
  typeEdge(
    """The method to use when ordering \`Type\`."""
    orderBy: [TypesOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TypesEdge

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postBySmallint: Post

  """Reads a single \`Post\` that is related to this \`Type\`."""
  postById: Post
}

"""All input for the \`deleteTypeById\` mutation."""
input DeleteTypeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}`;
export const plans = {
  Query: {
    __assertStep() {
      return true;
    },
    query: Query_queryPlan,
    inputById: {
      plan(_$root, args) {
        return resource_inputsPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    patchById: {
      plan(_$root, args) {
        return resource_patchsPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    reservedById: {
      plan(_$root, args) {
        return resource_reservedPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    reservedPatchRecordById: {
      plan(_$root, args) {
        return resource_reservedPatchsPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    reservedInputRecordById: {
      plan(_$root, args) {
        return resource_reserved_inputPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    defaultValueById: {
      plan(_$root, args) {
        return resource_default_valuePgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    noPrimaryKeyById: {
      plan(_$root, args) {
        return resource_no_primary_keyPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    uniqueForeignKeyByCompoundKey1AndCompoundKey2: {
      plan(_$root, args) {
        return resource_unique_foreign_keyPgResource.get({
          compound_key_1: args.get("compoundKey1"),
          compound_key_2: args.get("compoundKey2")
        });
      },
      args: {
        compoundKey1: undefined,
        compoundKey2: undefined
      }
    },
    myTableById: {
      plan(_$root, args) {
        return resource_my_tablePgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    personSecretByPersonId: {
      plan(_$root, args) {
        return resource_person_secretPgResource.get({
          person_id: args.get("personId")
        });
      },
      args: {
        personId: undefined
      }
    },
    viewTableById: {
      plan(_$root, args) {
        return resource_view_tablePgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    compoundKeyByPersonId1AndPersonId2: {
      plan(_$root, args) {
        return resource_compound_keyPgResource.get({
          person_id_1: args.get("personId1"),
          person_id_2: args.get("personId2")
        });
      },
      args: {
        personId1: undefined,
        personId2: undefined
      }
    },
    similarTable1ById: {
      plan(_$root, args) {
        return resource_similar_table_1PgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    similarTable2ById: {
      plan(_$root, args) {
        return resource_similar_table_2PgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    nullTestRecordById: {
      plan(_$root, args) {
        return resource_null_test_recordPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    leftArmById: {
      plan(_$root, args) {
        return resource_left_armPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    leftArmByPersonId: {
      plan(_$root, args) {
        return resource_left_armPgResource.get({
          person_id: args.get("personId")
        });
      },
      args: {
        personId: undefined
      }
    },
    issue756ById: {
      plan(_$root, args) {
        return resource_issue756PgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    postById: {
      plan(_$root, args) {
        return resource_postPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    personById: {
      plan(_$root, args) {
        return resource_personPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    personByEmail: {
      plan(_$root, args) {
        return resource_personPgResource.get({
          email: args.get("email")
        });
      },
      args: {
        email: undefined
      }
    },
    typeById: {
      plan(_$root, args) {
        return resource_typesPgResource.get({
          id: args.get("id")
        });
      },
      args: {
        id: undefined
      }
    },
    currentUserId($root, args, _info) {
      const selectArgs = makeArgs(args);
      return resource_current_user_idPgResource.execute(selectArgs);
    },
    funcOut($root, args, _info) {
      const selectArgs = makeArgs2(args);
      return resource_func_outPgResource.execute(selectArgs);
    },
    funcOutSetof: {
      plan: Query_funcOutSetofPlan,
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutSetof_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutSetof_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutSetof_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutSetof_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutSetof_after_applyPlan
        }
      }
    },
    funcOutUnnamed($root, args, _info) {
      const selectArgs = makeArgs4(args);
      return resource_func_out_unnamedPgResource.execute(selectArgs);
    },
    noArgsQuery($root, args, _info) {
      const selectArgs = makeArgs5(args);
      return resource_no_args_queryPgResource.execute(selectArgs);
    },
    queryIntervalSet: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs2($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_queryIntervalSet_after_applyPlan
        }
      }
    },
    staticBigInteger: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs3($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_staticBigInteger_after_applyPlan
        }
      }
    },
    funcInOut: {
      plan($root, args, _info) {
        const selectArgs = makeArgs8(args);
        return resource_func_in_outPgResource.execute(selectArgs);
      },
      args: {
        i: undefined
      }
    },
    funcReturnsTableOneCol: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs4($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        i: undefined,
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableOneCol_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableOneCol_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableOneCol_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableOneCol_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableOneCol_after_applyPlan
        }
      }
    },
    jsonIdentity: {
      plan($root, args, _info) {
        const selectArgs = makeArgs10(args);
        return resource_json_identityPgResource.execute(selectArgs);
      },
      args: {
        json: undefined
      }
    },
    jsonbIdentity: {
      plan($root, args, _info) {
        const selectArgs = makeArgs11(args);
        return resource_jsonb_identityPgResource.execute(selectArgs);
      },
      args: {
        json: undefined
      }
    },
    add1Query: {
      plan($root, args, _info) {
        const selectArgs = makeArgs12(args);
        return resource_add_1_queryPgResource.execute(selectArgs);
      },
      args: {
        arg0: undefined,
        arg1: undefined
      }
    },
    add2Query: {
      plan($root, args, _info) {
        const selectArgs = makeArgs13(args);
        return resource_add_2_queryPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined
      }
    },
    add3Query: {
      plan($root, args, _info) {
        const selectArgs = makeArgs14(args);
        return resource_add_3_queryPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        arg1: undefined
      }
    },
    add4Query: {
      plan($root, args, _info) {
        const selectArgs = makeArgs15(args);
        return resource_add_4_queryPgResource.execute(selectArgs);
      },
      args: {
        arg0: undefined,
        b: undefined
      }
    },
    funcInInout: {
      plan($root, args, _info) {
        const selectArgs = makeArgs16(args);
        return resource_func_in_inoutPgResource.execute(selectArgs);
      },
      args: {
        i: undefined,
        ino: undefined
      }
    },
    funcOutOut($root, args, _info) {
      const selectArgs = makeArgs17(args);
      return resource_func_out_outPgResource.execute(selectArgs);
    },
    funcOutOutSetof: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs5($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutOutSetof_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutOutSetof_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutOutSetof_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutOutSetof_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutOutSetof_after_applyPlan
        }
      }
    },
    funcOutOutUnnamed($root, args, _info) {
      const selectArgs = makeArgs19(args);
      return resource_func_out_out_unnamedPgResource.execute(selectArgs);
    },
    searchTestSummariesList: {
      plan($root, args, _info) {
        const selectArgs = makeArgs20(args);
        return resource_search_test_summariesPgResource.execute(selectArgs);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_searchTestSummariesList_first_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_searchTestSummariesList_offset_applyPlan
        }
      }
    },
    optionalMissingMiddle1: {
      plan($root, args, _info) {
        const selectArgs = makeArgs21(args);
        return resource_optional_missing_middle_1PgResource.execute(selectArgs);
      },
      args: {
        arg0: undefined,
        b: undefined,
        c: undefined
      }
    },
    optionalMissingMiddle2: {
      plan($root, args, _info) {
        const selectArgs = makeArgs22(args);
        return resource_optional_missing_middle_2PgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined,
        c: undefined
      }
    },
    optionalMissingMiddle3: {
      plan($root, args, _info) {
        const selectArgs = makeArgs23(args);
        return resource_optional_missing_middle_3PgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        arg1: undefined,
        c: undefined
      }
    },
    optionalMissingMiddle4: {
      plan($root, args, _info) {
        const selectArgs = makeArgs24(args);
        return resource_optional_missing_middle_4PgResource.execute(selectArgs);
      },
      args: {
        arg0: undefined,
        b: undefined,
        arg2: undefined
      }
    },
    optionalMissingMiddle5: {
      plan($root, args, _info) {
        const selectArgs = makeArgs25(args);
        return resource_optional_missing_middle_5PgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        arg1: undefined,
        arg2: undefined
      }
    },
    funcOutUnnamedOutOutUnnamed($root, args, _info) {
      const selectArgs = makeArgs26(args);
      return resource_func_out_unnamed_out_out_unnamedPgResource.execute(selectArgs);
    },
    funcReturnsTableMultiCol: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs6($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        i: undefined,
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableMultiCol_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableMultiCol_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableMultiCol_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableMultiCol_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcReturnsTableMultiCol_after_applyPlan
        }
      }
    },
    intSetQuery: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs7($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        x: undefined,
        y: undefined,
        z: undefined,
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_intSetQuery_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_intSetQuery_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_intSetQuery_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_intSetQuery_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_intSetQuery_after_applyPlan
        }
      }
    },
    queryIntervalArray($root, args, _info) {
      const selectArgs = makeArgs29(args);
      return resource_query_interval_arrayPgResource.execute(selectArgs);
    },
    queryTextArray($root, args, _info) {
      const selectArgs = makeArgs30(args);
      return resource_query_text_arrayPgResource.execute(selectArgs);
    },
    returnTableWithoutGrants($root, args, _info) {
      const selectArgs = makeArgs31(args);
      return resource_return_table_without_grantsPgResource.execute(selectArgs);
    },
    typesQuery: {
      plan($root, args, _info) {
        const selectArgs = makeArgs32(args);
        return resource_types_queryPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined,
        c: undefined,
        d: undefined,
        e: undefined,
        f: undefined
      }
    },
    funcOutOutCompoundType: {
      plan($root, args, _info) {
        const selectArgs = makeArgs33(args);
        return resource_func_out_out_compound_typePgResource.execute(selectArgs);
      },
      args: {
        i1: undefined
      }
    },
    queryOutputTwoRows: {
      plan($root, args, _info) {
        const selectArgs = makeArgs34(args);
        return resource_query_output_two_rowsPgResource.execute(selectArgs);
      },
      args: {
        leftArmId: undefined,
        postId: undefined,
        txt: undefined
      }
    },
    compoundTypeSetQuery: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs8($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_compoundTypeSetQuery_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_compoundTypeSetQuery_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_compoundTypeSetQuery_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_compoundTypeSetQuery_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_compoundTypeSetQuery_after_applyPlan
        }
      }
    },
    compoundTypeQuery: {
      plan($root, args, _info) {
        const selectArgs = makeArgs36(args);
        return resource_compound_type_queryPgResource.execute(selectArgs);
      },
      args: {
        object: undefined
      }
    },
    tableQuery: {
      plan($root, args, _info) {
        const selectArgs = makeArgs37(args);
        return resource_table_queryPgResource.execute(selectArgs);
      },
      args: {
        id: undefined
      }
    },
    queryCompoundTypeArray: {
      plan($root, args, _info) {
        const selectArgs = makeArgs38(args);
        return resource_query_compound_type_arrayPgResource.execute(selectArgs);
      },
      args: {
        object: undefined
      }
    },
    compoundTypeArrayQuery: {
      plan($root, args, _info) {
        const selectArgs = makeArgs39(args);
        return resource_compound_type_array_queryPgResource.execute(selectArgs);
      },
      args: {
        object: undefined
      }
    },
    funcOutComplex: {
      plan($root, args, _info) {
        const selectArgs = makeArgs40(args);
        return resource_func_out_complexPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined
      }
    },
    funcOutComplexSetof: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs9($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        a: undefined,
        b: undefined,
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutComplexSetof_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutComplexSetof_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutComplexSetof_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutComplexSetof_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutComplexSetof_after_applyPlan
        }
      }
    },
    badlyBehavedFunction: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs10($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_badlyBehavedFunction_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_badlyBehavedFunction_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_badlyBehavedFunction_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_badlyBehavedFunction_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_badlyBehavedFunction_after_applyPlan
        }
      }
    },
    funcOutTable($root, args, _info) {
      const selectArgs = makeArgs43(args);
      return resource_func_out_tablePgResource.execute(selectArgs);
    },
    funcOutTableSetof: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs11($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutTableSetof_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutTableSetof_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutTableSetof_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutTableSetof_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_funcOutTableSetof_after_applyPlan
        }
      }
    },
    tableSetQuery: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs12($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQuery_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQuery_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQuery_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQuery_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQuery_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    tableSetQueryPlpgsql: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs13($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQueryPlpgsql_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQueryPlpgsql_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQueryPlpgsql_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQueryPlpgsql_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_tableSetQueryPlpgsql_after_applyPlan
        }
      }
    },
    typeFunctionConnection: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs14($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_typeFunctionConnection_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_typeFunctionConnection_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_typeFunctionConnection_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_typeFunctionConnection_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_typeFunctionConnection_after_applyPlan
        }
      }
    },
    typeFunction: {
      plan($root, args, _info) {
        const selectArgs = makeArgs48(args);
        return resource_type_functionPgResource.execute(selectArgs);
      },
      args: {
        id: undefined
      }
    },
    typeFunctionList($root, args, _info) {
      const selectArgs = makeArgs49(args);
      return resource_type_function_listPgResource.execute(selectArgs);
    },
    allNonUpdatableViews: {
      plan() {
        return connection(resource_non_updatable_viewPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNonUpdatableViews_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("NonUpdatableViewsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allInputs: {
      plan() {
        return connection(resource_inputsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allInputs_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("InputsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allPatches: {
      plan() {
        return connection(resource_patchsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPatches_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PatchesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allReserveds: {
      plan() {
        return connection(resource_reservedPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReserveds_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ReservedsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allReservedPatchRecords: {
      plan() {
        return connection(resource_reservedPatchsPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedPatchRecords_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ReservedPatchRecordsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allReservedInputRecords: {
      plan() {
        return connection(resource_reserved_inputPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allReservedInputRecords_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ReservedInputRecordsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allDefaultValues: {
      plan() {
        return connection(resource_default_valuePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allDefaultValues_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("DefaultValuesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allForeignKeys: {
      plan() {
        return connection(resource_foreign_keyPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allForeignKeys_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ForeignKeysOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allNoPrimaryKeys: {
      plan() {
        return connection(resource_no_primary_keyPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNoPrimaryKeys_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("NoPrimaryKeysOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allTestviews: {
      plan() {
        return connection(resource_testviewPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTestviews_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("TestviewsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allMyTables: {
      plan() {
        return connection(resource_my_tablePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allMyTables_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allMyTables_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allMyTables_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allMyTables_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allMyTables_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("MyTablesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allPersonSecrets: {
      plan() {
        return connection(resource_person_secretPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPersonSecrets_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPersonSecrets_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPersonSecrets_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPersonSecrets_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPersonSecrets_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PersonSecretsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allViewTables: {
      plan() {
        return connection(resource_view_tablePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allViewTables_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ViewTablesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allCompoundKeys: {
      plan() {
        return connection(resource_compound_keyPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCompoundKeys_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCompoundKeys_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCompoundKeys_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCompoundKeys_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allCompoundKeys_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CompoundKeysOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allSimilarTable1S: {
      plan() {
        return connection(resource_similar_table_1PgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable1S_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SimilarTable1SOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allSimilarTable2S: {
      plan() {
        return connection(resource_similar_table_2PgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allSimilarTable2S_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("SimilarTable2SOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allUpdatableViews: {
      plan() {
        return connection(resource_updatable_viewPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUpdatableViews_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUpdatableViews_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUpdatableViews_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUpdatableViews_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allUpdatableViews_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("UpdatableViewsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allNullTestRecords: {
      plan() {
        return connection(resource_null_test_recordPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNullTestRecords_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNullTestRecords_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNullTestRecords_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNullTestRecords_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allNullTestRecords_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("NullTestRecordsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allEdgeCases: {
      plan() {
        return connection(resource_edge_casePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allEdgeCases_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allEdgeCases_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allEdgeCases_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allEdgeCases_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allEdgeCases_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("EdgeCasesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allLeftArms: {
      plan() {
        return connection(resource_left_armPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLeftArms_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLeftArms_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLeftArms_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLeftArms_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allLeftArms_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("LeftArmsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allIssue756S: {
      plan() {
        return connection(resource_issue756PgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allIssue756S_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allIssue756S_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allIssue756S_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allIssue756S_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allIssue756S_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("Issue756SOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allPosts: {
      plan() {
        return connection(resource_postPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPosts_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allPeople: {
      plan() {
        return connection(resource_personPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allPeople_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    allTypes: {
      plan() {
        return connection(resource_typesPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTypes_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTypes_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTypes_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTypes_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Query_allTypes_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("TypesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  Input: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    }
  },
  Patch: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    }
  },
  Reserved: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    }
  },
  ReservedPatchRecord: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    }
  },
  ReservedInputRecord: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    }
  },
  DefaultValue: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    nullValue($record) {
      return $record.get("null_value");
    }
  },
  NoPrimaryKey: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    str($record) {
      return $record.get("str");
    }
  },
  UniqueForeignKey: {
    __assertStep: assertPgClassSingleStep,
    compoundKey1($record) {
      return $record.get("compound_key_1");
    },
    compoundKey2($record) {
      return $record.get("compound_key_2");
    },
    compoundKeyByCompoundKey1AndCompoundKey2($record) {
      return resource_compound_keyPgResource.get({
        person_id_1: $record.get("compound_key_1"),
        person_id_2: $record.get("compound_key_2")
      });
    }
  },
  CompoundKey: {
    __assertStep: assertPgClassSingleStep,
    personId2($record) {
      return $record.get("person_id_2");
    },
    personId1($record) {
      return $record.get("person_id_1");
    },
    extra($record) {
      return $record.get("extra");
    },
    personByPersonId1($record) {
      return resource_personPgResource.get({
        id: $record.get("person_id_1")
      });
    },
    personByPersonId2($record) {
      return resource_personPgResource.get({
        id: $record.get("person_id_2")
      });
    },
    foreignKeysByCompoundKey1AndCompoundKey2: {
      plan($record) {
        const $records = resource_foreign_keyPgResource.find({
          compound_key_1: $record.get("person_id_1"),
          compound_key_2: $record.get("person_id_2")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: CompoundKey_foreignKeysByCompoundKey1AndCompoundKey2_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ForeignKeysOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    uniqueForeignKeyByCompoundKey1AndCompoundKey2($record) {
      return resource_unique_foreign_keyPgResource.get({
        compound_key_1: $record.get("person_id_1"),
        compound_key_2: $record.get("person_id_2")
      });
    }
  },
  Person: {
    __assertStep: assertPgClassSingleStep,
    computedOut($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs50(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_person_computed_outPgResource.isUnique && !resource_person_computed_outPgResource.codec.attributes && typeof resource_person_computed_outPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_person_computed_outPgResource.codec)`${resource_person_computed_outPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_person_computed_outPgResource.execute(selectArgs);
    },
    firstName($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs51(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_person_first_namePgResource.isUnique && !resource_person_first_namePgResource.codec.attributes && typeof resource_person_first_namePgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_person_first_namePgResource.codec)`${resource_person_first_namePgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_person_first_namePgResource.execute(selectArgs);
    },
    computedOutOut($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs52(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_person_computed_out_outPgResource.isUnique && !resource_person_computed_out_outPgResource.codec.attributes && typeof resource_person_computed_out_outPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_person_computed_out_outPgResource.codec)`${resource_person_computed_out_outPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_person_computed_out_outPgResource.execute(selectArgs);
    },
    computedInout: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs53(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_person_computed_inoutPgResource.isUnique && !resource_person_computed_inoutPgResource.codec.attributes && typeof resource_person_computed_inoutPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_person_computed_inoutPgResource.codec)`${resource_person_computed_inoutPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_person_computed_inoutPgResource.execute(selectArgs);
      },
      args: {
        ino: undefined
      }
    },
    computedInoutOut: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs54(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_person_computed_inout_outPgResource.isUnique && !resource_person_computed_inout_outPgResource.codec.attributes && typeof resource_person_computed_inout_outPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_person_computed_inout_outPgResource.codec)`${resource_person_computed_inout_outPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_person_computed_inout_outPgResource.execute(selectArgs);
      },
      args: {
        ino: undefined
      }
    },
    exists: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs55(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_person_existsPgResource.isUnique && !resource_person_existsPgResource.codec.attributes && typeof resource_person_existsPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_person_existsPgResource.codec)`${resource_person_existsPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_person_existsPgResource.execute(selectArgs);
      },
      args: {
        email: undefined
      }
    },
    computedFirstArgInoutOut($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs56(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_person_computed_first_arg_inout_outPgResource.isUnique && !resource_person_computed_first_arg_inout_outPgResource.codec.attributes && typeof resource_person_computed_first_arg_inout_outPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_person_computed_first_arg_inout_outPgResource.codec)`${resource_person_computed_first_arg_inout_outPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_person_computed_first_arg_inout_outPgResource.execute(selectArgs);
    },
    computedComplex: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs57(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_person_computed_complexPgResource.isUnique && !resource_person_computed_complexPgResource.codec.attributes && typeof resource_person_computed_complexPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_person_computed_complexPgResource.codec)`${resource_person_computed_complexPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_person_computed_complexPgResource.execute(selectArgs);
      },
      args: {
        a: undefined,
        b: undefined
      }
    },
    firstPost($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs58(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_person_first_postPgResource.isUnique && !resource_person_first_postPgResource.codec.attributes && typeof resource_person_first_postPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_person_first_postPgResource.codec)`${resource_person_first_postPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_person_first_postPgResource.execute(selectArgs);
    },
    computedFirstArgInout($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs59(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_person_computed_first_arg_inoutPgResource.isUnique && !resource_person_computed_first_arg_inoutPgResource.codec.attributes && typeof resource_person_computed_first_arg_inoutPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_person_computed_first_arg_inoutPgResource.codec)`${resource_person_computed_first_arg_inoutPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_person_computed_first_arg_inoutPgResource.execute(selectArgs);
    },
    friends: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs15($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_friends_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_friends_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_friends_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_friends_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_friends_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
            return null;
          }
        }
      }
    },
    typeFunctionConnection: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs16($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_typeFunctionConnection_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_typeFunctionConnection_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_typeFunctionConnection_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_typeFunctionConnection_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_typeFunctionConnection_after_applyPlan
        }
      }
    },
    typeFunction: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs62(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_person_type_functionPgResource.isUnique && !resource_person_type_functionPgResource.codec.attributes && typeof resource_person_type_functionPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_person_type_functionPgResource.codec)`${resource_person_type_functionPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_person_type_functionPgResource.execute(selectArgs);
      },
      args: {
        id: undefined
      }
    },
    typeFunctionList($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs63(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_person_type_function_listPgResource.isUnique && !resource_person_type_function_listPgResource.codec.attributes && typeof resource_person_type_function_listPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_person_type_function_listPgResource.codec)`${resource_person_type_function_listPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_person_type_function_listPgResource.execute(selectArgs);
    },
    id($record) {
      return $record.get("id");
    },
    name($record) {
      return $record.get("person_full_name");
    },
    aliases($record) {
      return $record.get("aliases");
    },
    about($record) {
      return $record.get("about");
    },
    email($record) {
      return $record.get("email");
    },
    site($record) {
      const $plan = $record.get("site");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_wrappedUrlPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    config($record) {
      return $record.get("config");
    },
    lastLoginFromIp($record) {
      return $record.get("last_login_from_ip");
    },
    lastLoginFromSubnet($record) {
      return $record.get("last_login_from_subnet");
    },
    userMac($record) {
      return $record.get("user_mac");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    postsByAuthorId: {
      plan($record) {
        const $records = resource_postPgResource.find({
          author_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_postsByAuthorId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_postsByAuthorId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_postsByAuthorId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_postsByAuthorId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_postsByAuthorId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostsOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    foreignKeysByPersonId: {
      plan($record) {
        const $records = resource_foreign_keyPgResource.find({
          person_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_foreignKeysByPersonId_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_foreignKeysByPersonId_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_foreignKeysByPersonId_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_foreignKeysByPersonId_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_foreignKeysByPersonId_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ForeignKeysOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    personSecretByPersonId($record) {
      return resource_person_secretPgResource.get({
        person_id: $record.get("id")
      });
    },
    leftArmByPersonId($record) {
      return resource_left_armPgResource.get({
        person_id: $record.get("id")
      });
    },
    compoundKeysByPersonId1: {
      plan($record) {
        const $records = resource_compound_keyPgResource.find({
          person_id_1: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId1_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId1_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId1_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId1_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId1_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CompoundKeysOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    compoundKeysByPersonId2: {
      plan($record) {
        const $records = resource_compound_keyPgResource.find({
          person_id_2: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId2_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId2_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId2_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId2_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Person_compoundKeysByPersonId2_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CompoundKeysOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    }
  },
  PersonComputedOutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      return $record.get("o2");
    }
  },
  PersonComputedInoutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    ino($record) {
      return $record.get("ino");
    },
    o($record) {
      return $record.get("o");
    }
  },
  PersonComputedFirstArgInoutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    person($record) {
      const $plan = $record.get("person");
      const $select = pgSelectSingleFromRecord(resource_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    o($record) {
      return $record.get("o");
    }
  },
  PersonComputedComplexRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CompoundType: {
    __assertStep: assertPgClassSingleStep,
    computedField($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs64(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_compound_type_computed_fieldPgResource.isUnique && !resource_compound_type_computed_fieldPgResource.codec.attributes && typeof resource_compound_type_computed_fieldPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_compound_type_computed_fieldPgResource.codec)`${resource_compound_type_computed_fieldPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_compound_type_computed_fieldPgResource.execute(selectArgs);
    },
    a($record) {
      return $record.get("a");
    },
    b($record) {
      return $record.get("b");
    },
    c($record) {
      return $record.get("c");
    },
    d($record) {
      return $record.get("d");
    },
    e($record) {
      return $record.get("e");
    },
    f($record) {
      return $record.get("f");
    },
    g($record) {
      return $record.get("g");
    },
    fooBar($record) {
      return $record.get("foo_bar");
    }
  },
  Color: {
    RED: {
      value: "red"
    },
    GREEN: {
      value: "green"
    },
    BLUE: {
      value: "blue"
    }
  },
  EnumCaps: {
    _0_BAR: {
      value: "0_BAR"
    }
  },
  EnumWithEmptyString: {
    _EMPTY_: {
      value: ""
    },
    ONE: {
      value: "one"
    },
    TWO: {
      value: "two"
    }
  },
  Interval: {
    __assertStep: assertExecutableStep,
    seconds: Interval_secondsPlan,
    minutes: Interval_minutesPlan,
    hours: Interval_hoursPlan,
    days: Interval_daysPlan,
    months: Interval_monthsPlan,
    years: Interval_yearsPlan
  },
  Post: {
    __assertStep: assertPgClassSingleStep,
    computedIntervalSet: {
      plan($parent, args, info) {
        const $select = getSelectPlanFromParentAndArgs17($parent, args, info);
        return connection($select, $item => $item, $item => $item.getParentStep ? $item.getParentStep().cursor() : $item.cursor());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_computedIntervalSet_after_applyPlan
        }
      }
    },
    computedIntervalArray($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs66(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_post_computed_interval_arrayPgResource.isUnique && !resource_post_computed_interval_arrayPgResource.codec.attributes && typeof resource_post_computed_interval_arrayPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_post_computed_interval_arrayPgResource.codec)`${resource_post_computed_interval_arrayPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_post_computed_interval_arrayPgResource.execute(selectArgs);
    },
    computedTextArray($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs67(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_post_computed_text_arrayPgResource.isUnique && !resource_post_computed_text_arrayPgResource.codec.attributes && typeof resource_post_computed_text_arrayPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_post_computed_text_arrayPgResource.codec)`${resource_post_computed_text_arrayPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_post_computed_text_arrayPgResource.execute(selectArgs);
    },
    computedWithOptionalArg: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs68(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_computed_with_optional_argPgResource.isUnique && !resource_post_computed_with_optional_argPgResource.codec.attributes && typeof resource_post_computed_with_optional_argPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_computed_with_optional_argPgResource.codec)`${resource_post_computed_with_optional_argPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_computed_with_optional_argPgResource.execute(selectArgs);
      },
      args: {
        i: undefined
      }
    },
    computedWithRequiredArg: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs69(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_computed_with_required_argPgResource.isUnique && !resource_post_computed_with_required_argPgResource.codec.attributes && typeof resource_post_computed_with_required_argPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_computed_with_required_argPgResource.codec)`${resource_post_computed_with_required_argPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_computed_with_required_argPgResource.execute(selectArgs);
      },
      args: {
        i: undefined
      }
    },
    headlineTrimmed: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs70(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_headline_trimmedPgResource.isUnique && !resource_post_headline_trimmedPgResource.codec.attributes && typeof resource_post_headline_trimmedPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_headline_trimmedPgResource.codec)`${resource_post_headline_trimmedPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_headline_trimmedPgResource.execute(selectArgs);
      },
      args: {
        length: undefined,
        omission: undefined
      }
    },
    headlineTrimmedNoDefaults: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs71(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_headline_trimmed_no_defaultsPgResource.isUnique && !resource_post_headline_trimmed_no_defaultsPgResource.codec.attributes && typeof resource_post_headline_trimmed_no_defaultsPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_headline_trimmed_no_defaultsPgResource.codec)`${resource_post_headline_trimmed_no_defaultsPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_headline_trimmed_no_defaultsPgResource.execute(selectArgs);
      },
      args: {
        length: undefined,
        omission: undefined
      }
    },
    headlineTrimmedStrict: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs72(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_headline_trimmed_strictPgResource.isUnique && !resource_post_headline_trimmed_strictPgResource.codec.attributes && typeof resource_post_headline_trimmed_strictPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_headline_trimmed_strictPgResource.codec)`${resource_post_headline_trimmed_strictPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_headline_trimmed_strictPgResource.execute(selectArgs);
      },
      args: {
        length: undefined,
        omission: undefined
      }
    },
    computedCompoundTypeArray: {
      plan($in, args, _info) {
        if (!hasRecord($in)) {
          throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
        }
        const extraSelectArgs = makeArgs73(args);
        /**
         * An optimisation - if all our dependencies are
         * compatible with the expression's class plan then we
         * can inline ourselves into that, otherwise we must
         * issue the query separately.
         */
        const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
        const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
        const selectArgs = [{
          step: $row.record()
        }, ...extraSelectArgs];
        if (resource_post_computed_compound_type_arrayPgResource.isUnique && !resource_post_computed_compound_type_arrayPgResource.codec.attributes && typeof resource_post_computed_compound_type_arrayPgResource.from === "function") {
          // This is a scalar computed attribute, let's inline the expression
          const placeholders = selectArgs.map((arg, i) => {
            if (i === 0) {
              return $row.getClassStep().alias;
            } else if ("pgCodec" in arg && arg.pgCodec) {
              return $row.placeholder(arg.step, arg.pgCodec);
            } else {
              return $row.placeholder(arg.step);
            }
          });
          return pgClassExpression($row, resource_post_computed_compound_type_arrayPgResource.codec)`${resource_post_computed_compound_type_arrayPgResource.from(...placeholders.map(placeholder => ({
            placeholder
          })))}`;
        }
        // PERF: or here, if scalar add select to `$row`?
        return resource_post_computed_compound_type_arrayPgResource.execute(selectArgs);
      },
      args: {
        object: undefined
      }
    },
    id($record) {
      return $record.get("id");
    },
    headline($record) {
      return $record.get("headline");
    },
    body($record) {
      return $record.get("body");
    },
    authorId($record) {
      return $record.get("author_id");
    },
    enums($record) {
      return $record.get("enums");
    },
    comptypes($record) {
      const $val = $record.get("comptypes");
      const $select = pgSelectFromRecords(resource_frmcdc_comptypePgResource, $val);
      $select.setTrusted();
      return $select;
    },
    personByAuthorId($record) {
      return resource_personPgResource.get({
        id: $record.get("author_id")
      });
    },
    typesBySmallint: {
      plan($record) {
        const $records = resource_typesPgResource.find({
          smallint: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_typesBySmallint_first_applyPlan
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_typesBySmallint_last_applyPlan
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_typesBySmallint_offset_applyPlan
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_typesBySmallint_before_applyPlan
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan: Post_typesBySmallint_after_applyPlan
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw();
            const $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("TypesOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            const $select = $connection.getSubplan();
            return $select.wherePlan();
          }
        }
      }
    },
    typeById($record) {
      return resource_typesPgResource.get({
        id: $record.get("id")
      });
    }
  },
  PostComputedIntervalSetConnection: {
    __assertStep: ConnectionStep,
    nodes: PostComputedIntervalSetConnection_nodesPlan,
    edges: PostComputedIntervalSetConnection_edgesPlan,
    pageInfo: PostComputedIntervalSetConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PostComputedIntervalSetEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PageInfo: {
    __assertStep: assertPageInfoCapableStep,
    hasNextPage: PageInfo_hasNextPagePlan,
    hasPreviousPage: PageInfo_hasPreviousPagePlan,
    startCursor($pageInfo) {
      return $pageInfo.startCursor();
    },
    endCursor($pageInfo) {
      return $pageInfo.endCursor();
    }
  },
  CompoundTypeInput: {
    a: {
      applyPlan($insert, val) {
        $insert.set("a", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    b: {
      applyPlan($insert, val) {
        $insert.set("b", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    c: {
      applyPlan($insert, val) {
        $insert.set("c", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    d: {
      applyPlan($insert, val) {
        $insert.set("d", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    e: {
      applyPlan($insert, val) {
        $insert.set("e", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    f: {
      applyPlan($insert, val) {
        $insert.set("f", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    g: {
      applyPlan($insert, val) {
        $insert.set("g", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    fooBar: {
      applyPlan($insert, val) {
        $insert.set("foo_bar", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  IntervalInput: {
    seconds: undefined,
    minutes: undefined,
    hours: undefined,
    days: undefined,
    months: undefined,
    years: undefined
  },
  AnEnum: {
    AWAITING: {
      value: "awaiting"
    },
    REJECTED: {
      value: "rejected"
    },
    PUBLISHED: {
      value: "published"
    },
    ASTERISK: {
      value: "*"
    },
    ASTERISK_ASTERISK: {
      value: "**"
    },
    ASTERISK_ASTERISK_ASTERISK: {
      value: "***"
    },
    FOO_ASTERISK: {
      value: "foo*"
    },
    FOO_ASTERISK_: {
      value: "foo*_"
    },
    _FOO_ASTERISK: {
      value: "_foo*"
    },
    ASTERISK_BAR: {
      value: "*bar"
    },
    ASTERISK_BAR_: {
      value: "*bar_"
    },
    _ASTERISK_BAR_: {
      value: "_*bar_"
    },
    ASTERISK_BAZ_ASTERISK: {
      value: "*baz*"
    },
    _ASTERISK_BAZ_ASTERISK_: {
      value: "_*baz*_"
    },
    PERCENT: {
      value: "%"
    },
    GREATER_THAN_OR_EQUAL: {
      value: ">="
    },
    LIKE: {
      value: "~~"
    },
    DOLLAR: {
      value: "$"
    }
  },
  Comptype: {
    __assertStep: assertPgClassSingleStep,
    schedule($record) {
      return $record.get("schedule");
    },
    isOptimised($record) {
      return $record.get("is_optimised");
    }
  },
  TypesConnection: {
    __assertStep: ConnectionStep,
    nodes: TypesConnection_nodesPlan,
    edges: TypesConnection_edgesPlan,
    pageInfo: TypesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  Type: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    smallint($record) {
      return $record.get("smallint");
    },
    bigint($record) {
      return $record.get("bigint");
    },
    numeric($record) {
      return $record.get("numeric");
    },
    decimal($record) {
      return $record.get("decimal");
    },
    boolean($record) {
      return $record.get("boolean");
    },
    varchar($record) {
      return $record.get("varchar");
    },
    enum($record) {
      return $record.get("enum");
    },
    enumArray($record) {
      return $record.get("enum_array");
    },
    domain($record) {
      return $record.get("domain");
    },
    domain2($record) {
      return $record.get("domain2");
    },
    textArray($record) {
      return $record.get("text_array");
    },
    json($record) {
      return $record.get("json");
    },
    jsonb($record) {
      return $record.get("jsonb");
    },
    nullableRange($record) {
      return $record.get("nullable_range");
    },
    numrange($record) {
      return $record.get("numrange");
    },
    daterange($record) {
      return $record.get("daterange");
    },
    anIntRange($record) {
      return $record.get("an_int_range");
    },
    timestamp($record) {
      return $record.get("timestamp");
    },
    timestamptz($record) {
      return $record.get("timestamptz");
    },
    date($record) {
      return $record.get("date");
    },
    time($record) {
      return $record.get("time");
    },
    timetz($record) {
      return $record.get("timetz");
    },
    interval($record) {
      return $record.get("interval");
    },
    intervalArray($record) {
      return $record.get("interval_array");
    },
    money($record) {
      return $record.get("money");
    },
    compoundType($record) {
      const $plan = $record.get("compound_type");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (true) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    nestedCompoundType($record) {
      const $plan = $record.get("nested_compound_type");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_nestedCompoundTypePgResource, $plan);
      if (true) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    nullableCompoundType($record) {
      const $plan = $record.get("nullable_compound_type");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    nullableNestedCompoundType($record) {
      const $plan = $record.get("nullable_nested_compound_type");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_nestedCompoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    point($record) {
      return $record.get("point");
    },
    nullablePoint($record) {
      return $record.get("nullablePoint");
    },
    inet($record) {
      return $record.get("inet");
    },
    cidr($record) {
      return $record.get("cidr");
    },
    macaddr($record) {
      return $record.get("macaddr");
    },
    regproc($record) {
      return $record.get("regproc");
    },
    regprocedure($record) {
      return $record.get("regprocedure");
    },
    regoper($record) {
      return $record.get("regoper");
    },
    regoperator($record) {
      return $record.get("regoperator");
    },
    regclass($record) {
      return $record.get("regclass");
    },
    regtype($record) {
      return $record.get("regtype");
    },
    regconfig($record) {
      return $record.get("regconfig");
    },
    regdictionary($record) {
      return $record.get("regdictionary");
    },
    textArrayDomain($record) {
      return $record.get("text_array_domain");
    },
    int8ArrayDomain($record) {
      return $record.get("int8_array_domain");
    },
    bytea($record) {
      return $record.get("bytea");
    },
    byteaArray($record) {
      return $record.get("bytea_array");
    },
    ltree($record) {
      return $record.get("ltree");
    },
    ltreeArray($record) {
      return $record.get("ltree_array");
    },
    postBySmallint($record) {
      return resource_postPgResource.get({
        id: $record.get("smallint")
      });
    },
    postById($record) {
      return resource_postPgResource.get({
        id: $record.get("id")
      });
    }
  },
  BigFloatRange: {},
  BigFloatRangeBound: {},
  DateRange: {},
  DateRangeBound: {},
  AnIntRange: {},
  AnIntRangeBound: {},
  NestedCompoundType: {
    __assertStep: assertPgClassSingleStep,
    a($record) {
      const $plan = $record.get("a");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    b($record) {
      const $plan = $record.get("b");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    bazBuz($record) {
      return $record.get("baz_buz");
    }
  },
  Point: {},
  TypesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  TypesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques28[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_types_types.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques28[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_types_types.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    SMALLINT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "smallint",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    SMALLINT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "smallint",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BIGINT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "bigint",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BIGINT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "bigint",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NUMERIC_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "numeric",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NUMERIC_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "numeric",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DECIMAL_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "decimal",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DECIMAL_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "decimal",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BOOLEAN_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "boolean",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BOOLEAN_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "boolean",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    VARCHAR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "varchar",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    VARCHAR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "varchar",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ENUM_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "enum",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ENUM_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "enum",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DOMAIN_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "domain",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DOMAIN_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "domain",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DOMAIN2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "domain2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DOMAIN2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "domain2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSON_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "json",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSON_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "json",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSONB_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "jsonb",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSONB_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "jsonb",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMESTAMP_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timestamp",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMESTAMP_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timestamp",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMESTAMPTZ_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timestamptz",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMESTAMPTZ_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timestamptz",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DATE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "date",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DATE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "date",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "time",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "time",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMETZ_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timetz",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TIMETZ_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "timetz",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    INTERVAL_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "interval",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    INTERVAL_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "interval",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MONEY_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "money",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MONEY_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "money",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NESTED_COMPOUND_TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nested_compound_type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NESTED_COMPOUND_TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nested_compound_type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_COMPOUND_TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_compound_type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_COMPOUND_TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_compound_type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_NESTED_COMPOUND_TYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_nested_compound_type",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_NESTED_COMPOUND_TYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_nested_compound_type",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POINT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "point",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    POINT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "point",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_POINT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullablePoint",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_POINT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullablePoint",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    INET_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "inet",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    INET_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "inet",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CIDR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cidr",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CIDR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "cidr",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MACADDR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "macaddr",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MACADDR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "macaddr",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGPROC_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regproc",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGPROC_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regproc",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGPROCEDURE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regprocedure",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGPROCEDURE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regprocedure",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGOPER_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regoper",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGOPER_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regoper",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGOPERATOR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regoperator",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGOPERATOR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regoperator",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGCLASS_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regclass",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGCLASS_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regclass",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGTYPE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regtype",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGTYPE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regtype",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGCONFIG_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regconfig",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGCONFIG_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regconfig",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGDICTIONARY_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regdictionary",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    REGDICTIONARY_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "regdictionary",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LTREE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "ltree",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LTREE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "ltree",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  TypeCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    smallint: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "smallint",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "smallint",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.smallint.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bigint: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "bigint",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "bigint",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.bigint.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numeric: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "numeric",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "numeric",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.numeric.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    decimal: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "decimal",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "decimal",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.decimal.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    boolean: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "boolean",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "boolean",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.boolean.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    varchar: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "varchar",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "varchar",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.varchar.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enum: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "enum",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "enum",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.enum.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enumArray: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "enum_array",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "enum_array",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.enum_array.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "domain",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "domain",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.domain.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "domain2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "domain2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.domain2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArray: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "text_array",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "text_array",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.text_array.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    json: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "json",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "json",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.json.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonb: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "jsonb",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "jsonb",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.jsonb.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableRange: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nullable_range",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nullable_range",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.nullable_range.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numrange: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "numrange",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "numrange",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.numrange.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    daterange: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "daterange",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "daterange",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.daterange.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    anIntRange: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "an_int_range",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "an_int_range",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.an_int_range.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamp: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "timestamp",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "timestamp",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.timestamp.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamptz: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "timestamptz",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "timestamptz",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.timestamptz.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    date: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "date",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "date",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.date.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    time: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "time",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "time",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.time.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timetz: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "timetz",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "timetz",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.timetz.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    interval: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "interval",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "interval",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.interval.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    intervalArray: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "interval_array",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "interval_array",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.interval_array.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    money: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "money",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "money",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.money.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundType: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "compound_type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "compound_type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.compound_type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nestedCompoundType: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nested_compound_type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nested_compound_type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.nested_compound_type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableCompoundType: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nullable_compound_type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nullable_compound_type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.nullable_compound_type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableNestedCompoundType: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nullable_nested_compound_type",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nullable_nested_compound_type",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.nullable_nested_compound_type.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    point: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "point",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "point",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.point.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullablePoint: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nullablePoint",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nullablePoint",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.nullablePoint.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    inet: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "inet",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "inet",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.inet.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cidr: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "cidr",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "cidr",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.cidr.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    macaddr: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "macaddr",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "macaddr",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.macaddr.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regproc: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regproc",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regproc",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regproc.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regprocedure: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regprocedure",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regprocedure",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regprocedure.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoper: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regoper",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regoper",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regoper.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoperator: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regoperator",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regoperator",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regoperator.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regclass: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regclass",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regclass",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regclass.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regtype: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regtype",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regtype",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regtype.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regconfig: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regconfig",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regconfig",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regconfig.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regdictionary: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "regdictionary",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "regdictionary",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.regdictionary.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArrayDomain: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "text_array_domain",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "text_array_domain",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.text_array_domain.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    int8ArrayDomain: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "int8_array_domain",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "int8_array_domain",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.int8_array_domain.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltree: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "ltree",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "ltree",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.ltree.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltreeArray: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "ltree_array",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "ltree_array",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes51.ltree_array.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  BigFloatRangeInput: {
    start: undefined,
    end: undefined
  },
  BigFloatRangeBoundInput: {
    value: undefined,
    inclusive: undefined
  },
  DateRangeInput: {
    start: undefined,
    end: undefined
  },
  DateRangeBoundInput: {
    value: undefined,
    inclusive: undefined
  },
  AnIntRangeInput: {
    start: undefined,
    end: undefined
  },
  AnIntRangeBoundInput: {
    value: undefined,
    inclusive: undefined
  },
  NestedCompoundTypeInput: {
    a: {
      applyPlan($insert, val) {
        $insert.set("a", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    b: {
      applyPlan($insert, val) {
        $insert.set("b", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bazBuz: {
      applyPlan($insert, val) {
        $insert.set("baz_buz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PointInput: {
    x: undefined,
    y: undefined
  },
  PeopleConnection: {
    __assertStep: ConnectionStep,
    nodes: PeopleConnection_nodesPlan,
    edges: PeopleConnection_edgesPlan,
    pageInfo: PeopleConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PeopleEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PeopleOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    COMPUTED_OUT_ASC: {
      applyPlan(step) {
        if (typeof resource_person_computed_outPgResource.from !== "function") {
          throw new Error("Invalid computed attribute 'from'");
        }
        const expression = sql`${resource_person_computed_outPgResource.from({
          placeholder: step.alias
        })}`;
        step.orderBy({
          codec: resource_person_computed_outPgResource.codec,
          fragment: expression,
          direction: "asc".toUpperCase()
        });
      }
    },
    COMPUTED_OUT_DESC: {
      applyPlan(step) {
        if (typeof resource_person_computed_outPgResource.from !== "function") {
          throw new Error("Invalid computed attribute 'from'");
        }
        const expression = sql`${resource_person_computed_outPgResource.from({
          placeholder: step.alias
        })}`;
        step.orderBy({
          codec: resource_person_computed_outPgResource.codec,
          fragment: expression,
          direction: "desc".toUpperCase()
        });
      }
    },
    FIRST_NAME_ASC: {
      applyPlan(step) {
        if (typeof resource_person_first_namePgResource.from !== "function") {
          throw new Error("Invalid computed attribute 'from'");
        }
        const expression = sql`${resource_person_first_namePgResource.from({
          placeholder: step.alias
        })}`;
        step.orderBy({
          codec: resource_person_first_namePgResource.codec,
          fragment: expression,
          direction: "asc".toUpperCase()
        });
      }
    },
    FIRST_NAME_DESC: {
      applyPlan(step) {
        if (typeof resource_person_first_namePgResource.from !== "function") {
          throw new Error("Invalid computed attribute 'from'");
        }
        const expression = sql`${resource_person_first_namePgResource.from({
          placeholder: step.alias
        })}`;
        step.orderBy({
          codec: resource_person_first_namePgResource.codec,
          fragment: expression,
          direction: "desc".toUpperCase()
        });
      }
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques27[0].attributes.forEach(attributeName => {
          const attribute = attributes_person_codec_person.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques27[0].attributes.forEach(attributeName => {
          const attribute = attributes_person_codec_person.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_full_name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_full_name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ABOUT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "about",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ABOUT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "about",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    EMAIL_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "email",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    EMAIL_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "email",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    SITE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "site",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    SITE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "site",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CONFIG_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "config",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CONFIG_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "config",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_LOGIN_FROM_IP_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_login_from_ip",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_LOGIN_FROM_IP_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_login_from_ip",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_LOGIN_FROM_SUBNET_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_login_from_subnet",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LAST_LOGIN_FROM_SUBNET_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "last_login_from_subnet",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    USER_MAC_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "user_mac",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    USER_MAC_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "user_mac",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  WrappedUrl: {
    __assertStep: assertPgClassSingleStep,
    url($record) {
      return $record.get("url");
    }
  },
  PostsConnection: {
    __assertStep: ConnectionStep,
    nodes: PostsConnection_nodesPlan,
    edges: PostsConnection_edgesPlan,
    pageInfo: PostsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PostsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PostsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    COMPUTED_WITH_OPTIONAL_ARG_ASC: {
      applyPlan(step) {
        if (typeof resource_post_computed_with_optional_argPgResource.from !== "function") {
          throw new Error("Invalid computed attribute 'from'");
        }
        const expression = sql`${resource_post_computed_with_optional_argPgResource.from({
          placeholder: step.alias
        })}`;
        step.orderBy({
          codec: resource_post_computed_with_optional_argPgResource.codec,
          fragment: expression,
          direction: "asc".toUpperCase()
        });
      }
    },
    COMPUTED_WITH_OPTIONAL_ARG_DESC: {
      applyPlan(step) {
        if (typeof resource_post_computed_with_optional_argPgResource.from !== "function") {
          throw new Error("Invalid computed attribute 'from'");
        }
        const expression = sql`${resource_post_computed_with_optional_argPgResource.from({
          placeholder: step.alias
        })}`;
        step.orderBy({
          codec: resource_post_computed_with_optional_argPgResource.codec,
          fragment: expression,
          direction: "desc".toUpperCase()
        });
      }
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques25[0].attributes.forEach(attributeName => {
          const attribute = attributes_post_codec_post.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques25[0].attributes.forEach(attributeName => {
          const attribute = attributes_post_codec_post.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    HEADLINE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "headline",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    HEADLINE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "headline",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BODY_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "body",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    BODY_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "body",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    AUTHOR_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "author_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  PostCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    headline: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "headline",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "headline",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.headline.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    body: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "body",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "body",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.body.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "author_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.author_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enums: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "enums",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "enums",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.enums.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    comptypes: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "comptypes",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "comptypes",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes39.comptypes.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    computedWithOptionalArg: {
      applyPlan($condition, val) {
        if (typeof resource_post_computed_with_optional_argPgResource.from !== "function") {
          throw new Error("Invalid computed attribute 'from'");
        }
        const expression = sql`${resource_post_computed_with_optional_argPgResource.from({
          placeholder: $condition.alias
        })}`;
        if (val.getRaw().evalIs(null)) {
          $condition.where(sql`${expression} is null`);
        } else {
          $condition.where(sql`${expression} = ${$condition.placeholder(val.get(), resource_post_computed_with_optional_argPgResource.codec)}`);
        }
      }
    }
  },
  ComptypeInput: {
    schedule: {
      applyPlan($insert, val) {
        $insert.set("schedule", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isOptimised: {
      applyPlan($insert, val) {
        $insert.set("is_optimised", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ForeignKeysConnection: {
    __assertStep: ConnectionStep,
    nodes: ForeignKeysConnection_nodesPlan,
    edges: ForeignKeysConnection_edgesPlan,
    pageInfo: ForeignKeysConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ForeignKey: {
    __assertStep: assertPgClassSingleStep,
    personId($record) {
      return $record.get("person_id");
    },
    compoundKey1($record) {
      return $record.get("compound_key_1");
    },
    compoundKey2($record) {
      return $record.get("compound_key_2");
    },
    compoundKeyByCompoundKey1AndCompoundKey2($record) {
      return resource_compound_keyPgResource.get({
        person_id_1: $record.get("compound_key_1"),
        person_id_2: $record.get("compound_key_2")
      });
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("person_id")
      });
    }
  },
  ForeignKeysEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ForeignKeysOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COMPOUND_KEY_2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "compound_key_2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ForeignKeyCondition: {
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes19.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes19.compound_key_1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "compound_key_2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes19.compound_key_2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PersonSecret: {
    __assertStep: assertPgClassSingleStep,
    personId($record) {
      return $record.get("person_id");
    },
    secret($record) {
      return $record.get("sekrit");
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("person_id")
      });
    }
  },
  LeftArm: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    personId($record) {
      return $record.get("person_id");
    },
    lengthInMetres($record) {
      return $record.get("length_in_metres");
    },
    mood($record) {
      return $record.get("mood");
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("person_id")
      });
    }
  },
  CompoundKeysConnection: {
    __assertStep: ConnectionStep,
    nodes: CompoundKeysConnection_nodesPlan,
    edges: CompoundKeysConnection_edgesPlan,
    pageInfo: CompoundKeysConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CompoundKeysEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CompoundKeysOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques15[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_compoundKey_compoundKey.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques15[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_compoundKey_compoundKey.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PERSON_ID_2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id_2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id_2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id_1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id_1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    EXTRA_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "extra",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    EXTRA_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "extra",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  CompoundKeyCondition: {
    personId2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id_2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id_2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes26.person_id_2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id_1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id_1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes26.person_id_1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    extra: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "extra",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "extra",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes26.extra.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MyTable: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    jsonData($record) {
      return $record.get("json_data");
    }
  },
  ViewTable: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    }
  },
  SimilarTable1: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    },
    col3($record) {
      return $record.get("col3");
    }
  },
  SimilarTable2: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    col3($record) {
      return $record.get("col3");
    },
    col4($record) {
      return $record.get("col4");
    },
    col5($record) {
      return $record.get("col5");
    }
  },
  NullTestRecord: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    nullableText($record) {
      return $record.get("nullable_text");
    },
    nullableInt($record) {
      return $record.get("nullable_int");
    },
    nonNullText($record) {
      return $record.get("non_null_text");
    }
  },
  Issue756: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    ts($record) {
      return $record.get("ts");
    }
  },
  FuncOutSetofConnection: {
    __assertStep: ConnectionStep,
    nodes: FuncOutSetofConnection_nodesPlan,
    edges: FuncOutSetofConnection_edgesPlan,
    pageInfo: FuncOutSetofConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  FuncOutSetofEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  QueryIntervalSetConnection: {
    __assertStep: ConnectionStep,
    nodes: QueryIntervalSetConnection_nodesPlan,
    edges: QueryIntervalSetConnection_edgesPlan,
    pageInfo: QueryIntervalSetConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  QueryIntervalSetEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  StaticBigIntegerConnection: {
    __assertStep: ConnectionStep,
    nodes: StaticBigIntegerConnection_nodesPlan,
    edges: StaticBigIntegerConnection_edgesPlan,
    pageInfo: StaticBigIntegerConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  StaticBigIntegerEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  FuncReturnsTableOneColConnection: {
    __assertStep: ConnectionStep,
    nodes: FuncReturnsTableOneColConnection_nodesPlan,
    edges: FuncReturnsTableOneColConnection_edgesPlan,
    pageInfo: FuncReturnsTableOneColConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  FuncReturnsTableOneColEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  FuncOutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    firstOut($record) {
      return $record.get("first_out");
    },
    secondOut($record) {
      return $record.get("second_out");
    }
  },
  FuncOutOutSetofConnection: {
    __assertStep: ConnectionStep,
    nodes: FuncOutOutSetofConnection_nodesPlan,
    edges: FuncOutOutSetofConnection_edgesPlan,
    pageInfo: FuncOutOutSetofConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  FuncOutOutSetofRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      return $record.get("o2");
    }
  },
  FuncOutOutSetofEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  FuncOutOutUnnamedRecord: {
    __assertStep: assertPgClassSingleStep,
    arg1($record) {
      return $record.get("column1");
    },
    arg2($record) {
      return $record.get("column2");
    }
  },
  SearchTestSummariesRecord: {
    __assertStep: assertPgClassSingleStep,
    id($record) {
      return $record.get("id");
    },
    totalDuration($record) {
      return $record.get("total_duration");
    }
  },
  FuncOutUnnamedOutOutUnnamedRecord: {
    __assertStep: assertPgClassSingleStep,
    arg1($record) {
      return $record.get("column1");
    },
    o2($record) {
      return $record.get("o2");
    },
    arg3($record) {
      return $record.get("column3");
    }
  },
  FuncReturnsTableMultiColConnection: {
    __assertStep: ConnectionStep,
    nodes: FuncReturnsTableMultiColConnection_nodesPlan,
    edges: FuncReturnsTableMultiColConnection_edgesPlan,
    pageInfo: FuncReturnsTableMultiColConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  FuncReturnsTableMultiColRecord: {
    __assertStep: assertPgClassSingleStep,
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    }
  },
  FuncReturnsTableMultiColEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  IntSetQueryConnection: {
    __assertStep: ConnectionStep,
    nodes: IntSetQueryConnection_nodesPlan,
    edges: IntSetQueryConnection_edgesPlan,
    pageInfo: IntSetQueryConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  IntSetQueryEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  FloatRangeInput: {
    start: undefined,
    end: undefined
  },
  FloatRangeBoundInput: {
    value: undefined,
    inclusive: undefined
  },
  FuncOutOutCompoundTypeRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      const $plan = $record.get("o2");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  QueryOutputTwoRowsRecord: {
    __assertStep: assertPgClassSingleStep,
    txt($record) {
      return $record.get("txt");
    },
    leftArm($record) {
      const $plan = $record.get("left_arm");
      const $select = pgSelectSingleFromRecord(resource_left_armPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    post($record) {
      const $plan = $record.get("post");
      const $select = pgSelectSingleFromRecord(resource_postPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  CompoundTypesConnection: {
    __assertStep: ConnectionStep,
    nodes: CompoundTypesConnection_nodesPlan,
    edges: CompoundTypesConnection_edgesPlan,
    pageInfo: CompoundTypesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  CompoundTypesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  FuncOutComplexRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  FuncOutComplexSetofConnection: {
    __assertStep: ConnectionStep,
    nodes: FuncOutComplexSetofConnection_nodesPlan,
    edges: FuncOutComplexSetofConnection_edgesPlan,
    pageInfo: FuncOutComplexSetofConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  FuncOutComplexSetofRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  FuncOutComplexSetofEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PersonCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_full_name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_full_name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.person_full_name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    aliases: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "aliases",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "aliases",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.aliases.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    about: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "about",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "about",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.about.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "email",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "email",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.email.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    site: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "site",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "site",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.site.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    config: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "config",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "config",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.config.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromIp: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "last_login_from_ip",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "last_login_from_ip",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.last_login_from_ip.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromSubnet: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "last_login_from_subnet",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "last_login_from_subnet",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.last_login_from_subnet.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userMac: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "user_mac",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "user_mac",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.user_mac.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "created_at",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes44.created_at.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    computedOut: {
      applyPlan($condition, val) {
        if (typeof resource_person_computed_outPgResource.from !== "function") {
          throw new Error("Invalid computed attribute 'from'");
        }
        const expression = sql`${resource_person_computed_outPgResource.from({
          placeholder: $condition.alias
        })}`;
        if (val.getRaw().evalIs(null)) {
          $condition.where(sql`${expression} is null`);
        } else {
          $condition.where(sql`${expression} = ${$condition.placeholder(val.get(), resource_person_computed_outPgResource.codec)}`);
        }
      }
    }
  },
  WrappedUrlInput: {
    url: {
      applyPlan($insert, val) {
        $insert.set("url", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  NonUpdatableViewsConnection: {
    __assertStep: ConnectionStep,
    nodes: NonUpdatableViewsConnection_nodesPlan,
    edges: NonUpdatableViewsConnection_edgesPlan,
    pageInfo: NonUpdatableViewsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  NonUpdatableView: {
    __assertStep: assertPgClassSingleStep,
    column($record) {
      return $record.get("?column?");
    }
  },
  NonUpdatableViewsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  NonUpdatableViewsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    COLUMN_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "?column?",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COLUMN_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "?column?",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  NonUpdatableViewCondition: {
    column: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "?column?",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "?column?",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes12["?column?"].codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  InputsConnection: {
    __assertStep: ConnectionStep,
    nodes: InputsConnection_nodesPlan,
    edges: InputsConnection_edgesPlan,
    pageInfo: InputsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  InputsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  InputsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques2[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_inputs_inputs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques2[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_inputs_inputs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  InputCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes13.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PatchesConnection: {
    __assertStep: ConnectionStep,
    nodes: PatchesConnection_nodesPlan,
    edges: PatchesConnection_edgesPlan,
    pageInfo: PatchesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PatchesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PatchesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques3[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_patchs_patchs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques3[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_patchs_patchs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  PatchCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes14.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedsConnection: {
    __assertStep: ConnectionStep,
    nodes: ReservedsConnection_nodesPlan,
    edges: ReservedsConnection_edgesPlan,
    pageInfo: ReservedsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ReservedsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ReservedsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques4[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reserved_reserved.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques4[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reserved_reserved.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ReservedCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes15.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedPatchRecordsConnection: {
    __assertStep: ConnectionStep,
    nodes: ReservedPatchRecordsConnection_nodesPlan,
    edges: ReservedPatchRecordsConnection_edgesPlan,
    pageInfo: ReservedPatchRecordsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ReservedPatchRecordsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ReservedPatchRecordsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques5[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reservedPatchs_reservedPatchs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques5[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reservedPatchs_reservedPatchs.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ReservedPatchRecordCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes16.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedInputRecordsConnection: {
    __assertStep: ConnectionStep,
    nodes: ReservedInputRecordsConnection_nodesPlan,
    edges: ReservedInputRecordsConnection_edgesPlan,
    pageInfo: ReservedInputRecordsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ReservedInputRecordsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ReservedInputRecordsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques6[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reservedInput_reservedInput.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques6[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_reservedInput_reservedInput.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ReservedInputRecordCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes17.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  DefaultValuesConnection: {
    __assertStep: ConnectionStep,
    nodes: DefaultValuesConnection_nodesPlan,
    edges: DefaultValuesConnection_edgesPlan,
    pageInfo: DefaultValuesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  DefaultValuesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  DefaultValuesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques7[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_defaultValue_defaultValue.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques7[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_defaultValue_defaultValue.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULL_VALUE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "null_value",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULL_VALUE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "null_value",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  DefaultValueCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullValue: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "null_value",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "null_value",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes18.null_value.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  NoPrimaryKeysConnection: {
    __assertStep: ConnectionStep,
    nodes: NoPrimaryKeysConnection_nodesPlan,
    edges: NoPrimaryKeysConnection_edgesPlan,
    pageInfo: NoPrimaryKeysConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  NoPrimaryKeysEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  NoPrimaryKeysOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    STR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "str",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    STR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "str",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  NoPrimaryKeyCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes20.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    str: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "str",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "str",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes20.str.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  TestviewsConnection: {
    __assertStep: ConnectionStep,
    nodes: TestviewsConnection_nodesPlan,
    edges: TestviewsConnection_edgesPlan,
    pageInfo: TestviewsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  Testview: {
    __assertStep: assertPgClassSingleStep,
    testviewid($record) {
      return $record.get("testviewid");
    },
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    }
  },
  TestviewsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  TestviewsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    TESTVIEWID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "testviewid",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TESTVIEWID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "testviewid",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  TestviewCondition: {
    testviewid: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "testviewid",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "testviewid",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes21.testviewid.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes21.col1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes21.col2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MyTablesConnection: {
    __assertStep: ConnectionStep,
    nodes: MyTablesConnection_nodesPlan,
    edges: MyTablesConnection_edgesPlan,
    pageInfo: MyTablesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  MyTablesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  MyTablesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques12[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_myTable_myTable.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques12[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_myTable_myTable.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSON_DATA_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "json_data",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    JSON_DATA_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "json_data",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  MyTableCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes23.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonData: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "json_data",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "json_data",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes23.json_data.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PersonSecretsConnection: {
    __assertStep: ConnectionStep,
    nodes: PersonSecretsConnection_nodesPlan,
    edges: PersonSecretsConnection_edgesPlan,
    pageInfo: PersonSecretsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  PersonSecretsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PersonSecretsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques13[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_personSecret_personSecret.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques13[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_personSecret_personSecret.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    SECRET_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "sekrit",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    SECRET_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "sekrit",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  PersonSecretCondition: {
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes24.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    secret: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "sekrit",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "sekrit",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes24.sekrit.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ViewTablesConnection: {
    __assertStep: ConnectionStep,
    nodes: ViewTablesConnection_nodesPlan,
    edges: ViewTablesConnection_edgesPlan,
    pageInfo: ViewTablesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  ViewTablesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  ViewTablesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques14[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_viewTable_viewTable.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques14[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_viewTable_viewTable.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  ViewTableCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes25.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes25.col1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes25.col2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SimilarTable1SConnection: {
    __assertStep: ConnectionStep,
    nodes: SimilarTable1SConnection_nodesPlan,
    edges: SimilarTable1SConnection_edgesPlan,
    pageInfo: SimilarTable1SConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  SimilarTable1SEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  SimilarTable1SOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques16[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_similarTable1_similarTable1.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques16[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_similarTable1_similarTable1.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL1_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col1",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL2_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col2",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL3_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col3",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL3_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col3",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  SimilarTable1Condition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes27.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col1",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes27.col1.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col2",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes27.col2.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col3",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col3",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes27.col3.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SimilarTable2SConnection: {
    __assertStep: ConnectionStep,
    nodes: SimilarTable2SConnection_nodesPlan,
    edges: SimilarTable2SConnection_edgesPlan,
    pageInfo: SimilarTable2SConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  SimilarTable2SEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  SimilarTable2SOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques17[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_similarTable2_similarTable2.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques17[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_similarTable2_similarTable2.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL3_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col3",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL3_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col3",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL4_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col4",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL4_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col4",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL5_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col5",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    COL5_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "col5",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  SimilarTable2Condition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes28.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col3",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col3",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes28.col3.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col4: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col4",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col4",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes28.col4.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col5: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "col5",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "col5",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes28.col5.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatableViewsConnection: {
    __assertStep: ConnectionStep,
    nodes: UpdatableViewsConnection_nodesPlan,
    edges: UpdatableViewsConnection_edgesPlan,
    pageInfo: UpdatableViewsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  UpdatableView: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    name($record) {
      return $record.get("name");
    },
    description($record) {
      return $record.get("description");
    },
    constant($record) {
      return $record.get("constant");
    }
  },
  UpdatableViewsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  UpdatableViewsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    X_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "x",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    X_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "x",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DESCRIPTION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "description",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    DESCRIPTION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "description",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CONSTANT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "constant",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    CONSTANT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "constant",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  UpdatableViewCondition: {
    x: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "x",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "x",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.x.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "name",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.name.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "description",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "description",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.description.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    constant: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "constant",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "constant",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes_object_Object_.constant.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  NullTestRecordsConnection: {
    __assertStep: ConnectionStep,
    nodes: NullTestRecordsConnection_nodesPlan,
    edges: NullTestRecordsConnection_edgesPlan,
    pageInfo: NullTestRecordsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  NullTestRecordsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  NullTestRecordsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques19[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_nullTestRecord_nullTestRecord.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques19[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_nullTestRecord_nullTestRecord.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_TEXT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_text",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_TEXT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_text",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_INT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_int",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NULLABLE_INT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "nullable_int",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NON_NULL_TEXT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "non_null_text",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NON_NULL_TEXT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "non_null_text",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  NullTestRecordCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes29.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableText: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nullable_text",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nullable_text",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes29.nullable_text.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableInt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "nullable_int",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "nullable_int",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes29.nullable_int.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nonNullText: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "non_null_text",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "non_null_text",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes29.non_null_text.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  EdgeCasesConnection: {
    __assertStep: ConnectionStep,
    nodes: EdgeCasesConnection_nodesPlan,
    edges: EdgeCasesConnection_edgesPlan,
    pageInfo: EdgeCasesConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  EdgeCase: {
    __assertStep: assertPgClassSingleStep,
    computed($in, args, _info) {
      if (!hasRecord($in)) {
        throw new Error(`Invalid plan, exepcted 'PgSelectSingleStep', 'PgInsertSingleStep', 'PgUpdateSingleStep' or 'PgDeleteSingleStep', but found ${$in}`);
      }
      const extraSelectArgs = makeArgs74(args);
      /**
       * An optimisation - if all our dependencies are
       * compatible with the expression's class plan then we
       * can inline ourselves into that, otherwise we must
       * issue the query separately.
       */
      const canUseExpressionDirectly = $in instanceof PgSelectSingleStep && extraSelectArgs.every(a => stepAMayDependOnStepB($in.getClassStep(), a.step));
      const $row = canUseExpressionDirectly ? $in : pgSelectSingleFromRecord($in.resource, $in.record());
      const selectArgs = [{
        step: $row.record()
      }, ...extraSelectArgs];
      if (resource_edge_case_computedPgResource.isUnique && !resource_edge_case_computedPgResource.codec.attributes && typeof resource_edge_case_computedPgResource.from === "function") {
        // This is a scalar computed attribute, let's inline the expression
        const placeholders = selectArgs.map((arg, i) => {
          if (i === 0) {
            return $row.getClassStep().alias;
          } else if ("pgCodec" in arg && arg.pgCodec) {
            return $row.placeholder(arg.step, arg.pgCodec);
          } else {
            return $row.placeholder(arg.step);
          }
        });
        return pgClassExpression($row, resource_edge_case_computedPgResource.codec)`${resource_edge_case_computedPgResource.from(...placeholders.map(placeholder => ({
          placeholder
        })))}`;
      }
      // PERF: or here, if scalar add select to `$row`?
      return resource_edge_case_computedPgResource.execute(selectArgs);
    },
    notNullHasDefault($record) {
      return $record.get("not_null_has_default");
    },
    wontCastEasy($record) {
      return $record.get("wont_cast_easy");
    },
    rowId($record) {
      return $record.get("row_id");
    }
  },
  EdgeCasesEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  EdgeCasesOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    NOT_NULL_HAS_DEFAULT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "not_null_has_default",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    NOT_NULL_HAS_DEFAULT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "not_null_has_default",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    WONT_CAST_EASY_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "wont_cast_easy",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    WONT_CAST_EASY_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "wont_cast_easy",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "row_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "row_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  EdgeCaseCondition: {
    notNullHasDefault: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "not_null_has_default",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "not_null_has_default",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes30.not_null_has_default.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    wontCastEasy: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "wont_cast_easy",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "wont_cast_easy",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes30.wont_cast_easy.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "row_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "row_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes30.row_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  LeftArmsConnection: {
    __assertStep: ConnectionStep,
    nodes: LeftArmsConnection_nodesPlan,
    edges: LeftArmsConnection_edgesPlan,
    pageInfo: LeftArmsConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  LeftArmsEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  LeftArmsOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques21[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_leftArm_leftArm.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques21[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_leftArm_leftArm.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    PERSON_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "person_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    LENGTH_IN_METRES_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "length_in_metres",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    LENGTH_IN_METRES_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "length_in_metres",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MOOD_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "mood",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    MOOD_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "mood",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  LeftArmCondition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes31.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "person_id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes31.person_id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lengthInMetres: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "length_in_metres",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "length_in_metres",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes31.length_in_metres.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    mood: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "mood",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "mood",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes31.mood.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  Issue756SConnection: {
    __assertStep: ConnectionStep,
    nodes: Issue756SConnection_nodesPlan,
    edges: Issue756SConnection_edgesPlan,
    pageInfo: Issue756SConnection_pageInfoPlan,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint);
    }
  },
  Issue756SEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  Issue756SOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        uniques23[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_issue756_issue756.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        uniques23[0].attributes.forEach(attributeName => {
          const attribute = registryConfig_pgCodecs_issue756_issue756.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step.alias}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) {
          plan.setOrderIsUnique();
        }
      }
    },
    TS_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "ts",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    },
    TS_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) {
          throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        }
        plan.orderBy({
          attribute: "ts",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) {
          plan.setOrderIsUnique();
        }
      }
    }
  },
  Issue756Condition: {
    id: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "id",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes33.id.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ts: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) {
          $condition.where({
            type: "attribute",
            attribute: "ts",
            callback(expression) {
              return sql`${expression} is null`;
            }
          });
        } else {
          $condition.where({
            type: "attribute",
            attribute: "ts",
            callback(expression) {
              return sql`${expression} = ${$condition.placeholder(val.get(), attributes33.ts.codec)}`;
            }
          });
        }
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  Mutation: {
    __assertStep: __ValueStep,
    mutationOut: {
      plan($root, args, _info) {
        const selectArgs = makeArgs75(args, ["input"]);
        const $result = resource_mutation_outPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOut_input_applyPlan
        }
      }
    },
    mutationOutSetof: {
      plan($root, args, _info) {
        const selectArgs = makeArgs76(args, ["input"]);
        const $result = resource_mutation_out_setofPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutSetof_input_applyPlan
        }
      }
    },
    mutationOutUnnamed: {
      plan($root, args, _info) {
        const selectArgs = makeArgs77(args, ["input"]);
        const $result = resource_mutation_out_unnamedPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutUnnamed_input_applyPlan
        }
      }
    },
    noArgsMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs78(args, ["input"]);
        const $result = resource_no_args_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_noArgsMutation_input_applyPlan
        }
      }
    },
    returnVoidMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs79(args, ["input"]);
        const $result = resource_return_void_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_returnVoidMutation_input_applyPlan
        }
      }
    },
    mutationIntervalSet: {
      plan($root, args, _info) {
        const selectArgs = makeArgs80(args, ["input"]);
        const $result = resource_mutation_interval_setPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationIntervalSet_input_applyPlan
        }
      }
    },
    mutationInOut: {
      plan($root, args, _info) {
        const selectArgs = makeArgs81(args, ["input"]);
        const $result = resource_mutation_in_outPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationInOut_input_applyPlan
        }
      }
    },
    mutationReturnsTableOneCol: {
      plan($root, args, _info) {
        const selectArgs = makeArgs82(args, ["input"]);
        const $result = resource_mutation_returns_table_one_colPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationReturnsTableOneCol_input_applyPlan
        }
      }
    },
    jsonIdentityMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs83(args, ["input"]);
        const $result = resource_json_identity_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_jsonIdentityMutation_input_applyPlan
        }
      }
    },
    jsonbIdentityMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs84(args, ["input"]);
        const $result = resource_jsonb_identity_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_jsonbIdentityMutation_input_applyPlan
        }
      }
    },
    jsonbIdentityMutationPlpgsql: {
      plan($root, args, _info) {
        const selectArgs = makeArgs85(args, ["input"]);
        const $result = resource_jsonb_identity_mutation_plpgsqlPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_jsonbIdentityMutationPlpgsql_input_applyPlan
        }
      }
    },
    jsonbIdentityMutationPlpgsqlWithDefault: {
      plan($root, args, _info) {
        const selectArgs = makeArgs86(args, ["input"]);
        const $result = resource_jsonb_identity_mutation_plpgsql_with_defaultPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_jsonbIdentityMutationPlpgsqlWithDefault_input_applyPlan
        }
      }
    },
    add1Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs87(args, ["input"]);
        const $result = resource_add_1_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add1Mutation_input_applyPlan
        }
      }
    },
    add2Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs88(args, ["input"]);
        const $result = resource_add_2_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add2Mutation_input_applyPlan
        }
      }
    },
    add3Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs89(args, ["input"]);
        const $result = resource_add_3_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add3Mutation_input_applyPlan
        }
      }
    },
    add4Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs90(args, ["input"]);
        const $result = resource_add_4_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add4Mutation_input_applyPlan
        }
      }
    },
    add4MutationError: {
      plan($root, args, _info) {
        const selectArgs = makeArgs91(args, ["input"]);
        const $result = resource_add_4_mutation_errorPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_add4MutationError_input_applyPlan
        }
      }
    },
    mult1: {
      plan($root, args, _info) {
        const selectArgs = makeArgs92(args, ["input"]);
        const $result = resource_mult_1PgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mult1_input_applyPlan
        }
      }
    },
    mult2: {
      plan($root, args, _info) {
        const selectArgs = makeArgs93(args, ["input"]);
        const $result = resource_mult_2PgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mult2_input_applyPlan
        }
      }
    },
    mult3: {
      plan($root, args, _info) {
        const selectArgs = makeArgs94(args, ["input"]);
        const $result = resource_mult_3PgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mult3_input_applyPlan
        }
      }
    },
    mult4: {
      plan($root, args, _info) {
        const selectArgs = makeArgs95(args, ["input"]);
        const $result = resource_mult_4PgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mult4_input_applyPlan
        }
      }
    },
    mutationInInout: {
      plan($root, args, _info) {
        const selectArgs = makeArgs96(args, ["input"]);
        const $result = resource_mutation_in_inoutPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationInInout_input_applyPlan
        }
      }
    },
    mutationOutOut: {
      plan($root, args, _info) {
        const selectArgs = makeArgs97(args, ["input"]);
        const $result = resource_mutation_out_outPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutOut_input_applyPlan
        }
      }
    },
    mutationOutOutSetof: {
      plan($root, args, _info) {
        const selectArgs = makeArgs98(args, ["input"]);
        const $result = resource_mutation_out_out_setofPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutOutSetof_input_applyPlan
        }
      }
    },
    mutationOutOutUnnamed: {
      plan($root, args, _info) {
        const selectArgs = makeArgs99(args, ["input"]);
        const $result = resource_mutation_out_out_unnamedPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutOutUnnamed_input_applyPlan
        }
      }
    },
    intSetMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs100(args, ["input"]);
        const $result = resource_int_set_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_intSetMutation_input_applyPlan
        }
      }
    },
    mutationOutUnnamedOutOutUnnamed: {
      plan($root, args, _info) {
        const selectArgs = makeArgs101(args, ["input"]);
        const $result = resource_mutation_out_unnamed_out_out_unnamedPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutUnnamedOutOutUnnamed_input_applyPlan
        }
      }
    },
    mutationReturnsTableMultiCol: {
      plan($root, args, _info) {
        const selectArgs = makeArgs102(args, ["input"]);
        const $result = resource_mutation_returns_table_multi_colPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationReturnsTableMultiCol_input_applyPlan
        }
      }
    },
    guidFn: {
      plan($root, args, _info) {
        const selectArgs = makeArgs103(args, ["input"]);
        const $result = resource_guid_fnPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_guidFn_input_applyPlan
        }
      }
    },
    mutationIntervalArray: {
      plan($root, args, _info) {
        const selectArgs = makeArgs104(args, ["input"]);
        const $result = resource_mutation_interval_arrayPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationIntervalArray_input_applyPlan
        }
      }
    },
    mutationTextArray: {
      plan($root, args, _info) {
        const selectArgs = makeArgs105(args, ["input"]);
        const $result = resource_mutation_text_arrayPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationTextArray_input_applyPlan
        }
      }
    },
    listBdeMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs106(args, ["input"]);
        const $result = resource_list_bde_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_listBdeMutation_input_applyPlan
        }
      }
    },
    authenticateFail: {
      plan($root, args, _info) {
        const selectArgs = makeArgs107(args, ["input"]);
        const $result = resource_authenticate_failPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_authenticateFail_input_applyPlan
        }
      }
    },
    authenticate: {
      plan($root, args, _info) {
        const selectArgs = makeArgs108(args, ["input"]);
        const $result = resource_authenticatePgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_authenticate_input_applyPlan
        }
      }
    },
    leftArmIdentity: {
      plan($root, args, _info) {
        const selectArgs = makeArgs109(args, ["input"]);
        const $result = resource_left_arm_identityPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_leftArmIdentity_input_applyPlan
        }
      }
    },
    issue756Mutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs110(args, ["input"]);
        const $result = resource_issue756_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_issue756Mutation_input_applyPlan
        }
      }
    },
    issue756SetMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs111(args, ["input"]);
        const $result = resource_issue756_set_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_issue756SetMutation_input_applyPlan
        }
      }
    },
    authenticateMany: {
      plan($root, args, _info) {
        const selectArgs = makeArgs112(args, ["input"]);
        const $result = resource_authenticate_manyPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_authenticateMany_input_applyPlan
        }
      }
    },
    authenticatePayload: {
      plan($root, args, _info) {
        const selectArgs = makeArgs113(args, ["input"]);
        const $result = resource_authenticate_payloadPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_authenticatePayload_input_applyPlan
        }
      }
    },
    typesMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs114(args, ["input"]);
        const $result = resource_types_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_typesMutation_input_applyPlan
        }
      }
    },
    mutationOutOutCompoundType: {
      plan($root, args, _info) {
        const selectArgs = makeArgs115(args, ["input"]);
        const $result = resource_mutation_out_out_compound_typePgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutOutCompoundType_input_applyPlan
        }
      }
    },
    compoundTypeMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs116(args, ["input"]);
        const $result = resource_compound_type_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_compoundTypeMutation_input_applyPlan
        }
      }
    },
    compoundTypeSetMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs117(args, ["input"]);
        const $result = resource_compound_type_set_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_compoundTypeSetMutation_input_applyPlan
        }
      }
    },
    tableMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs118(args, ["input"]);
        const $result = resource_table_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_tableMutation_input_applyPlan
        }
      }
    },
    postWithSuffix: {
      plan($root, args, _info) {
        const selectArgs = makeArgs119(args, ["input"]);
        const $result = resource_post_with_suffixPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_postWithSuffix_input_applyPlan
        }
      }
    },
    mutationCompoundTypeArray: {
      plan($root, args, _info) {
        const selectArgs = makeArgs120(args, ["input"]);
        const $result = resource_mutation_compound_type_arrayPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationCompoundTypeArray_input_applyPlan
        }
      }
    },
    compoundTypeArrayMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs121(args, ["input"]);
        const $result = resource_compound_type_array_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_compoundTypeArrayMutation_input_applyPlan
        }
      }
    },
    postMany: {
      plan($root, args, _info) {
        const selectArgs = makeArgs122(args, ["input"]);
        const $result = resource_post_manyPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_postMany_input_applyPlan
        }
      }
    },
    mutationOutComplex: {
      plan($root, args, _info) {
        const selectArgs = makeArgs123(args, ["input"]);
        const $result = resource_mutation_out_complexPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutComplex_input_applyPlan
        }
      }
    },
    mutationOutComplexSetof: {
      plan($root, args, _info) {
        const selectArgs = makeArgs124(args, ["input"]);
        const $result = resource_mutation_out_complex_setofPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutComplexSetof_input_applyPlan
        }
      }
    },
    mutationOutTable: {
      plan($root, args, _info) {
        const selectArgs = makeArgs125(args, ["input"]);
        const $result = resource_mutation_out_tablePgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutTable_input_applyPlan
        }
      }
    },
    mutationOutTableSetof: {
      plan($root, args, _info) {
        const selectArgs = makeArgs126(args, ["input"]);
        const $result = resource_mutation_out_table_setofPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_mutationOutTableSetof_input_applyPlan
        }
      }
    },
    tableSetMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs127(args, ["input"]);
        const $result = resource_table_set_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_tableSetMutation_input_applyPlan
        }
      }
    },
    typeFunctionConnectionMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs128(args, ["input"]);
        const $result = resource_type_function_connection_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_typeFunctionConnectionMutation_input_applyPlan
        }
      }
    },
    typeFunctionMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs129(args, ["input"]);
        const $result = resource_type_function_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_typeFunctionMutation_input_applyPlan
        }
      }
    },
    typeFunctionListMutation: {
      plan($root, args, _info) {
        const selectArgs = makeArgs130(args, ["input"]);
        const $result = resource_type_function_list_mutationPgResource.execute(selectArgs, "mutation");
        return object({
          result: $result
        });
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_typeFunctionListMutation_input_applyPlan
        }
      }
    },
    createInput: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_inputsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createInput_input_applyPlan
        }
      }
    },
    createPatch: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_patchsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createPatch_input_applyPlan
        }
      }
    },
    createReserved: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_reservedPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createReserved_input_applyPlan
        }
      }
    },
    createReservedPatchRecord: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_reservedPatchsPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createReservedPatchRecord_input_applyPlan
        }
      }
    },
    createReservedInputRecord: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_reserved_inputPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createReservedInputRecord_input_applyPlan
        }
      }
    },
    createDefaultValue: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_default_valuePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createDefaultValue_input_applyPlan
        }
      }
    },
    createForeignKey: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_foreign_keyPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createForeignKey_input_applyPlan
        }
      }
    },
    createNoPrimaryKey: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_no_primary_keyPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createNoPrimaryKey_input_applyPlan
        }
      }
    },
    createTestview: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_testviewPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createTestview_input_applyPlan
        }
      }
    },
    createMyTable: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_my_tablePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createMyTable_input_applyPlan
        }
      }
    },
    createPersonSecret: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_person_secretPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createPersonSecret_input_applyPlan
        }
      }
    },
    createViewTable: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_view_tablePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createViewTable_input_applyPlan
        }
      }
    },
    createCompoundKey: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_compound_keyPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createCompoundKey_input_applyPlan
        }
      }
    },
    createSimilarTable1: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_similar_table_1PgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createSimilarTable1_input_applyPlan
        }
      }
    },
    createSimilarTable2: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_similar_table_2PgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createSimilarTable2_input_applyPlan
        }
      }
    },
    createUpdatableView: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_updatable_viewPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createUpdatableView_input_applyPlan
        }
      }
    },
    createNullTestRecord: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_null_test_recordPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createNullTestRecord_input_applyPlan
        }
      }
    },
    createEdgeCase: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_edge_casePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createEdgeCase_input_applyPlan
        }
      }
    },
    createLeftArm: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_left_armPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createLeftArm_input_applyPlan
        }
      }
    },
    createIssue756: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_issue756PgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createIssue756_input_applyPlan
        }
      }
    },
    createPost: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_postPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createPost_input_applyPlan
        }
      }
    },
    createPerson: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_personPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createPerson_input_applyPlan
        }
      }
    },
    createType: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_typesPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan: Mutation_createType_input_applyPlan
        }
      }
    },
    updateInputById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_inputsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateInputById_input_applyPlan
        }
      }
    },
    updatePatchById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_patchsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePatchById_input_applyPlan
        }
      }
    },
    updateReservedById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_reservedPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateReservedById_input_applyPlan
        }
      }
    },
    updateReservedPatchRecordById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_reservedPatchsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateReservedPatchRecordById_input_applyPlan
        }
      }
    },
    updateReservedInputRecordById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_reserved_inputPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateReservedInputRecordById_input_applyPlan
        }
      }
    },
    updateDefaultValueById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_default_valuePgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateDefaultValueById_input_applyPlan
        }
      }
    },
    updateNoPrimaryKeyById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_no_primary_keyPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateNoPrimaryKeyById_input_applyPlan
        }
      }
    },
    updateMyTableById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_my_tablePgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateMyTableById_input_applyPlan
        }
      }
    },
    updatePersonSecretByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_person_secretPgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePersonSecretByPersonId_input_applyPlan
        }
      }
    },
    updateViewTableById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_view_tablePgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateViewTableById_input_applyPlan
        }
      }
    },
    updateCompoundKeyByPersonId1AndPersonId2: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_compound_keyPgResource, {
            person_id_1: args.get(['input', "personId1"]),
            person_id_2: args.get(['input', "personId2"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateCompoundKeyByPersonId1AndPersonId2_input_applyPlan
        }
      }
    },
    updateSimilarTable1ById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_similar_table_1PgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateSimilarTable1ById_input_applyPlan
        }
      }
    },
    updateSimilarTable2ById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_similar_table_2PgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateSimilarTable2ById_input_applyPlan
        }
      }
    },
    updateNullTestRecordById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_null_test_recordPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateNullTestRecordById_input_applyPlan
        }
      }
    },
    updateLeftArmById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_left_armPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateLeftArmById_input_applyPlan
        }
      }
    },
    updateLeftArmByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_left_armPgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateLeftArmByPersonId_input_applyPlan
        }
      }
    },
    updateIssue756ById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_issue756PgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateIssue756ById_input_applyPlan
        }
      }
    },
    updatePostById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_postPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePostById_input_applyPlan
        }
      }
    },
    updatePersonById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_personPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePersonById_input_applyPlan
        }
      }
    },
    updatePersonByEmail: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_personPgResource, {
            email: args.get(['input', "email"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updatePersonByEmail_input_applyPlan
        }
      }
    },
    updateTypeById: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_typesPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_updateTypeById_input_applyPlan
        }
      }
    },
    deleteInputById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_inputsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteInputById_input_applyPlan
        }
      }
    },
    deletePatchById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_patchsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePatchById_input_applyPlan
        }
      }
    },
    deleteReservedById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_reservedPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteReservedById_input_applyPlan
        }
      }
    },
    deleteReservedPatchRecordById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_reservedPatchsPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteReservedPatchRecordById_input_applyPlan
        }
      }
    },
    deleteReservedInputRecordById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_reserved_inputPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteReservedInputRecordById_input_applyPlan
        }
      }
    },
    deleteDefaultValueById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_default_valuePgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteDefaultValueById_input_applyPlan
        }
      }
    },
    deleteNoPrimaryKeyById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_no_primary_keyPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteNoPrimaryKeyById_input_applyPlan
        }
      }
    },
    deleteMyTableById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_my_tablePgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteMyTableById_input_applyPlan
        }
      }
    },
    deletePersonSecretByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_person_secretPgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePersonSecretByPersonId_input_applyPlan
        }
      }
    },
    deleteViewTableById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_view_tablePgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteViewTableById_input_applyPlan
        }
      }
    },
    deleteCompoundKeyByPersonId1AndPersonId2: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_compound_keyPgResource, {
            person_id_1: args.get(['input', "personId1"]),
            person_id_2: args.get(['input', "personId2"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteCompoundKeyByPersonId1AndPersonId2_input_applyPlan
        }
      }
    },
    deleteSimilarTable1ById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_similar_table_1PgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteSimilarTable1ById_input_applyPlan
        }
      }
    },
    deleteSimilarTable2ById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_similar_table_2PgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteSimilarTable2ById_input_applyPlan
        }
      }
    },
    deleteNullTestRecordById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_null_test_recordPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteNullTestRecordById_input_applyPlan
        }
      }
    },
    deleteLeftArmById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_left_armPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteLeftArmById_input_applyPlan
        }
      }
    },
    deleteLeftArmByPersonId: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_left_armPgResource, {
            person_id: args.get(['input', "personId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteLeftArmByPersonId_input_applyPlan
        }
      }
    },
    deleteIssue756ById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_issue756PgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteIssue756ById_input_applyPlan
        }
      }
    },
    deletePostById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_postPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePostById_input_applyPlan
        }
      }
    },
    deletePersonById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_personPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePersonById_input_applyPlan
        }
      }
    },
    deletePersonByEmail: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_personPgResource, {
            email: args.get(['input', "email"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deletePersonByEmail_input_applyPlan
        }
      }
    },
    deleteTypeById: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_typesPgResource, {
            id: args.get(['input', "id"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan: Mutation_deleteTypeById_input_applyPlan
        }
      }
    }
  },
  MutationOutPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutPayload_clientMutationIdPlan,
    o($object) {
      return $object.get("result");
    },
    query: MutationOutPayload_queryPlan
  },
  MutationOutInput: {
    clientMutationId: {
      applyPlan: MutationOutInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationOutSetofPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutSetofPayload_clientMutationIdPlan,
    os($object) {
      return $object.get("result");
    },
    query: MutationOutSetofPayload_queryPlan
  },
  MutationOutSetofInput: {
    clientMutationId: {
      applyPlan: MutationOutSetofInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationOutUnnamedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutUnnamedPayload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: MutationOutUnnamedPayload_queryPlan
  },
  MutationOutUnnamedInput: {
    clientMutationId: {
      applyPlan: MutationOutUnnamedInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  NoArgsMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: NoArgsMutationPayload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: NoArgsMutationPayload_queryPlan
  },
  NoArgsMutationInput: {
    clientMutationId: {
      applyPlan: NoArgsMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReturnVoidMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: ReturnVoidMutationPayload_clientMutationIdPlan,
    query: ReturnVoidMutationPayload_queryPlan
  },
  ReturnVoidMutationInput: {
    clientMutationId: {
      applyPlan: ReturnVoidMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationIntervalSetPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationIntervalSetPayload_clientMutationIdPlan,
    intervals($object) {
      return $object.get("result");
    },
    query: MutationIntervalSetPayload_queryPlan
  },
  MutationIntervalSetInput: {
    clientMutationId: {
      applyPlan: MutationIntervalSetInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationInOutPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationInOutPayload_clientMutationIdPlan,
    o($object) {
      return $object.get("result");
    },
    query: MutationInOutPayload_queryPlan
  },
  MutationInOutInput: {
    clientMutationId: {
      applyPlan: MutationInOutInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i: undefined
  },
  MutationReturnsTableOneColPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationReturnsTableOneColPayload_clientMutationIdPlan,
    col1S($object) {
      return $object.get("result");
    },
    query: MutationReturnsTableOneColPayload_queryPlan
  },
  MutationReturnsTableOneColInput: {
    clientMutationId: {
      applyPlan: MutationReturnsTableOneColInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i: undefined
  },
  JsonIdentityMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: JsonIdentityMutationPayload_clientMutationIdPlan,
    json($object) {
      return $object.get("result");
    },
    query: JsonIdentityMutationPayload_queryPlan
  },
  JsonIdentityMutationInput: {
    clientMutationId: {
      applyPlan: JsonIdentityMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    json: undefined
  },
  JsonbIdentityMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: JsonbIdentityMutationPayload_clientMutationIdPlan,
    json($object) {
      return $object.get("result");
    },
    query: JsonbIdentityMutationPayload_queryPlan
  },
  JsonbIdentityMutationInput: {
    clientMutationId: {
      applyPlan: JsonbIdentityMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    json: undefined
  },
  JsonbIdentityMutationPlpgsqlPayload: {
    __assertStep: ObjectStep,
    clientMutationId: JsonbIdentityMutationPlpgsqlPayload_clientMutationIdPlan,
    json($object) {
      return $object.get("result");
    },
    query: JsonbIdentityMutationPlpgsqlPayload_queryPlan
  },
  JsonbIdentityMutationPlpgsqlInput: {
    clientMutationId: {
      applyPlan: JsonbIdentityMutationPlpgsqlInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    _theJson: undefined
  },
  JsonbIdentityMutationPlpgsqlWithDefaultPayload: {
    __assertStep: ObjectStep,
    clientMutationId: JsonbIdentityMutationPlpgsqlWithDefaultPayload_clientMutationIdPlan,
    json($object) {
      return $object.get("result");
    },
    query: JsonbIdentityMutationPlpgsqlWithDefaultPayload_queryPlan
  },
  JsonbIdentityMutationPlpgsqlWithDefaultInput: {
    clientMutationId: {
      applyPlan: JsonbIdentityMutationPlpgsqlWithDefaultInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    _theJson: undefined
  },
  Add1MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add1MutationPayload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: Add1MutationPayload_queryPlan
  },
  Add1MutationInput: {
    clientMutationId: {
      applyPlan: Add1MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  Add2MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add2MutationPayload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: Add2MutationPayload_queryPlan
  },
  Add2MutationInput: {
    clientMutationId: {
      applyPlan: Add2MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined
  },
  Add3MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add3MutationPayload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: Add3MutationPayload_queryPlan
  },
  Add3MutationInput: {
    clientMutationId: {
      applyPlan: Add3MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    arg1: undefined
  },
  Add4MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add4MutationPayload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: Add4MutationPayload_queryPlan
  },
  Add4MutationInput: {
    clientMutationId: {
      applyPlan: Add4MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    b: undefined
  },
  Add4MutationErrorPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Add4MutationErrorPayload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: Add4MutationErrorPayload_queryPlan
  },
  Add4MutationErrorInput: {
    clientMutationId: {
      applyPlan: Add4MutationErrorInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    b: undefined
  },
  Mult1Payload: {
    __assertStep: ObjectStep,
    clientMutationId: Mult1Payload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: Mult1Payload_queryPlan
  },
  Mult1Input: {
    clientMutationId: {
      applyPlan: Mult1Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  Mult2Payload: {
    __assertStep: ObjectStep,
    clientMutationId: Mult2Payload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: Mult2Payload_queryPlan
  },
  Mult2Input: {
    clientMutationId: {
      applyPlan: Mult2Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  Mult3Payload: {
    __assertStep: ObjectStep,
    clientMutationId: Mult3Payload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: Mult3Payload_queryPlan
  },
  Mult3Input: {
    clientMutationId: {
      applyPlan: Mult3Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  Mult4Payload: {
    __assertStep: ObjectStep,
    clientMutationId: Mult4Payload_clientMutationIdPlan,
    integer($object) {
      return $object.get("result");
    },
    query: Mult4Payload_queryPlan
  },
  Mult4Input: {
    clientMutationId: {
      applyPlan: Mult4Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    arg0: undefined,
    arg1: undefined
  },
  MutationInInoutPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationInInoutPayload_clientMutationIdPlan,
    ino($object) {
      return $object.get("result");
    },
    query: MutationInInoutPayload_queryPlan
  },
  MutationInInoutInput: {
    clientMutationId: {
      applyPlan: MutationInInoutInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i: undefined,
    ino: undefined
  },
  MutationOutOutPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutOutPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: MutationOutOutPayload_queryPlan
  },
  MutationOutOutRecord: {
    __assertStep: assertPgClassSingleStep,
    firstOut($record) {
      return $record.get("first_out");
    },
    secondOut($record) {
      return $record.get("second_out");
    }
  },
  MutationOutOutInput: {
    clientMutationId: {
      applyPlan: MutationOutOutInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationOutOutSetofPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutOutSetofPayload_clientMutationIdPlan,
    results($object) {
      return $object.get("result");
    },
    query: MutationOutOutSetofPayload_queryPlan
  },
  MutationOutOutSetofRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      return $record.get("o2");
    }
  },
  MutationOutOutSetofInput: {
    clientMutationId: {
      applyPlan: MutationOutOutSetofInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationOutOutUnnamedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutOutUnnamedPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: MutationOutOutUnnamedPayload_queryPlan
  },
  MutationOutOutUnnamedRecord: {
    __assertStep: assertPgClassSingleStep,
    arg1($record) {
      return $record.get("column1");
    },
    arg2($record) {
      return $record.get("column2");
    }
  },
  MutationOutOutUnnamedInput: {
    clientMutationId: {
      applyPlan: MutationOutOutUnnamedInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  IntSetMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: IntSetMutationPayload_clientMutationIdPlan,
    integers($object) {
      return $object.get("result");
    },
    query: IntSetMutationPayload_queryPlan
  },
  IntSetMutationInput: {
    clientMutationId: {
      applyPlan: IntSetMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    x: undefined,
    y: undefined,
    z: undefined
  },
  MutationOutUnnamedOutOutUnnamedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutUnnamedOutOutUnnamedPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: MutationOutUnnamedOutOutUnnamedPayload_queryPlan
  },
  MutationOutUnnamedOutOutUnnamedRecord: {
    __assertStep: assertPgClassSingleStep,
    arg1($record) {
      return $record.get("column1");
    },
    o2($record) {
      return $record.get("o2");
    },
    arg3($record) {
      return $record.get("column3");
    }
  },
  MutationOutUnnamedOutOutUnnamedInput: {
    clientMutationId: {
      applyPlan: MutationOutUnnamedOutOutUnnamedInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationReturnsTableMultiColPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationReturnsTableMultiColPayload_clientMutationIdPlan,
    results($object) {
      return $object.get("result");
    },
    query: MutationReturnsTableMultiColPayload_queryPlan
  },
  MutationReturnsTableMultiColRecord: {
    __assertStep: assertPgClassSingleStep,
    col1($record) {
      return $record.get("col1");
    },
    col2($record) {
      return $record.get("col2");
    }
  },
  MutationReturnsTableMultiColInput: {
    clientMutationId: {
      applyPlan: MutationReturnsTableMultiColInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i: undefined
  },
  GuidFnPayload: {
    __assertStep: ObjectStep,
    clientMutationId: GuidFnPayload_clientMutationIdPlan,
    guid($object) {
      return $object.get("result");
    },
    query: GuidFnPayload_queryPlan
  },
  GuidFnInput: {
    clientMutationId: {
      applyPlan: GuidFnInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    g: undefined
  },
  MutationIntervalArrayPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationIntervalArrayPayload_clientMutationIdPlan,
    intervals($object) {
      return $object.get("result");
    },
    query: MutationIntervalArrayPayload_queryPlan
  },
  MutationIntervalArrayInput: {
    clientMutationId: {
      applyPlan: MutationIntervalArrayInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationTextArrayPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationTextArrayPayload_clientMutationIdPlan,
    strings($object) {
      return $object.get("result");
    },
    query: MutationTextArrayPayload_queryPlan
  },
  MutationTextArrayInput: {
    clientMutationId: {
      applyPlan: MutationTextArrayInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ListBdeMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: ListBdeMutationPayload_clientMutationIdPlan,
    uuids($object) {
      return $object.get("result");
    },
    query: ListBdeMutationPayload_queryPlan
  },
  ListBdeMutationInput: {
    clientMutationId: {
      applyPlan: ListBdeMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    b: undefined,
    d: undefined,
    e: undefined
  },
  AuthenticateFailPayload: {
    __assertStep: ObjectStep,
    clientMutationId: AuthenticateFailPayload_clientMutationIdPlan,
    jwtToken($object) {
      return $object.get("result");
    },
    query: AuthenticateFailPayload_queryPlan
  },
  JwtToken: {
    __assertStep: assertPgClassSingleStep,
    role($record) {
      return $record.get("role");
    },
    exp($record) {
      return $record.get("exp");
    },
    a($record) {
      return $record.get("a");
    },
    b($record) {
      return $record.get("b");
    },
    c($record) {
      return $record.get("c");
    }
  },
  AuthenticateFailInput: {
    clientMutationId: {
      applyPlan: AuthenticateFailInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  AuthenticatePayload: {
    __assertStep: ObjectStep,
    clientMutationId: AuthenticatePayload_clientMutationIdPlan,
    jwtToken($object) {
      return $object.get("result");
    },
    query: AuthenticatePayload_queryPlan
  },
  AuthenticateInput: {
    clientMutationId: {
      applyPlan: AuthenticateInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined,
    c: undefined
  },
  LeftArmIdentityPayload: {
    __assertStep: ObjectStep,
    clientMutationId: LeftArmIdentityPayload_clientMutationIdPlan,
    leftArm($object) {
      return $object.get("result");
    },
    query: LeftArmIdentityPayload_queryPlan,
    leftArmEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_left_armPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("LeftArmsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id")
      });
    }
  },
  LeftArmIdentityInput: {
    clientMutationId: {
      applyPlan: LeftArmIdentityInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    leftArm: undefined
  },
  LeftArmBaseInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lengthInMetres: {
      applyPlan($insert, val) {
        $insert.set("length_in_metres", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    mood: {
      applyPlan($insert, val) {
        $insert.set("mood", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  Issue756MutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Issue756MutationPayload_clientMutationIdPlan,
    issue756($object) {
      return $object.get("result");
    },
    query: Issue756MutationPayload_queryPlan,
    issue756Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques23[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_issue756PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("Issue756SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  Issue756MutationInput: {
    clientMutationId: {
      applyPlan: Issue756MutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  Issue756SetMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: Issue756SetMutationPayload_clientMutationIdPlan,
    issue756S($object) {
      return $object.get("result");
    },
    query: Issue756SetMutationPayload_queryPlan
  },
  Issue756SetMutationInput: {
    clientMutationId: {
      applyPlan: Issue756SetMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  AuthenticateManyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: AuthenticateManyPayload_clientMutationIdPlan,
    jwtTokens($object) {
      return $object.get("result");
    },
    query: AuthenticateManyPayload_queryPlan
  },
  AuthenticateManyInput: {
    clientMutationId: {
      applyPlan: AuthenticateManyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined,
    c: undefined
  },
  AuthenticatePayloadPayload: {
    __assertStep: ObjectStep,
    clientMutationId: AuthenticatePayloadPayload_clientMutationIdPlan,
    authPayload($object) {
      return $object.get("result");
    },
    query: AuthenticatePayloadPayload_queryPlan,
    personById($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("id")
      });
    }
  },
  AuthPayload: {
    __assertStep: assertPgClassSingleStep,
    jwt($record) {
      const $plan = $record.get("jwt");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_jwtTokenPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    id($record) {
      return $record.get("id");
    },
    admin($record) {
      return $record.get("admin");
    },
    personById($record) {
      return resource_personPgResource.get({
        id: $record.get("id")
      });
    }
  },
  AuthenticatePayloadInput: {
    clientMutationId: {
      applyPlan: AuthenticatePayloadInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined,
    c: undefined
  },
  TypesMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: TypesMutationPayload_clientMutationIdPlan,
    boolean($object) {
      return $object.get("result");
    },
    query: TypesMutationPayload_queryPlan
  },
  TypesMutationInput: {
    clientMutationId: {
      applyPlan: TypesMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined,
    c: undefined,
    d: undefined,
    e: undefined,
    f: undefined
  },
  MutationOutOutCompoundTypePayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutOutCompoundTypePayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: MutationOutOutCompoundTypePayload_queryPlan
  },
  MutationOutOutCompoundTypeRecord: {
    __assertStep: assertPgClassSingleStep,
    o1($record) {
      return $record.get("o1");
    },
    o2($record) {
      const $plan = $record.get("o2");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  MutationOutOutCompoundTypeInput: {
    clientMutationId: {
      applyPlan: MutationOutOutCompoundTypeInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    i1: undefined
  },
  CompoundTypeMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CompoundTypeMutationPayload_clientMutationIdPlan,
    compoundType($object) {
      return $object.get("result");
    },
    query: CompoundTypeMutationPayload_queryPlan
  },
  CompoundTypeMutationInput: {
    clientMutationId: {
      applyPlan: CompoundTypeMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    object: undefined
  },
  CompoundTypeSetMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CompoundTypeSetMutationPayload_clientMutationIdPlan,
    compoundTypes($object) {
      return $object.get("result");
    },
    query: CompoundTypeSetMutationPayload_queryPlan
  },
  CompoundTypeSetMutationInput: {
    clientMutationId: {
      applyPlan: CompoundTypeSetMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    object: undefined
  },
  TableMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: TableMutationPayload_clientMutationIdPlan,
    post($object) {
      return $object.get("result");
    },
    query: TableMutationPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByAuthorId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("author_id")
      });
    }
  },
  TableMutationInput: {
    clientMutationId: {
      applyPlan: TableMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    id: undefined
  },
  PostWithSuffixPayload: {
    __assertStep: ObjectStep,
    clientMutationId: PostWithSuffixPayload_clientMutationIdPlan,
    post($object) {
      return $object.get("result");
    },
    query: PostWithSuffixPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByAuthorId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("author_id")
      });
    }
  },
  PostWithSuffixInput: {
    clientMutationId: {
      applyPlan: PostWithSuffixInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    post: undefined,
    suffix: undefined
  },
  PostInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    headline: {
      applyPlan($insert, val) {
        $insert.set("headline", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    body: {
      applyPlan($insert, val) {
        $insert.set("body", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($insert, val) {
        $insert.set("author_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enums: {
      applyPlan($insert, val) {
        $insert.set("enums", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    comptypes: {
      applyPlan($insert, val) {
        $insert.set("comptypes", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationCompoundTypeArrayPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationCompoundTypeArrayPayload_clientMutationIdPlan,
    compoundTypes($object) {
      return $object.get("result");
    },
    query: MutationCompoundTypeArrayPayload_queryPlan
  },
  MutationCompoundTypeArrayInput: {
    clientMutationId: {
      applyPlan: MutationCompoundTypeArrayInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    object: undefined
  },
  CompoundTypeArrayMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: CompoundTypeArrayMutationPayload_clientMutationIdPlan,
    compoundTypes($object) {
      return $object.get("result");
    },
    query: CompoundTypeArrayMutationPayload_queryPlan
  },
  CompoundTypeArrayMutationInput: {
    clientMutationId: {
      applyPlan: CompoundTypeArrayMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    object: undefined
  },
  PostManyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: PostManyPayload_clientMutationIdPlan,
    posts($object) {
      return $object.get("result");
    },
    query: PostManyPayload_queryPlan
  },
  PostManyInput: {
    clientMutationId: {
      applyPlan: PostManyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    posts: undefined
  },
  MutationOutComplexPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutComplexPayload_clientMutationIdPlan,
    result($object) {
      return $object.get("result");
    },
    query: MutationOutComplexPayload_queryPlan
  },
  MutationOutComplexRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  MutationOutComplexInput: {
    clientMutationId: {
      applyPlan: MutationOutComplexInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined
  },
  MutationOutComplexSetofPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutComplexSetofPayload_clientMutationIdPlan,
    results($object) {
      return $object.get("result");
    },
    query: MutationOutComplexSetofPayload_queryPlan
  },
  MutationOutComplexSetofRecord: {
    __assertStep: assertPgClassSingleStep,
    x($record) {
      return $record.get("x");
    },
    y($record) {
      const $plan = $record.get("y");
      const $select = pgSelectSingleFromRecord(resource_frmcdc_compoundTypePgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    },
    z($record) {
      const $plan = $record.get("z");
      const $select = pgSelectSingleFromRecord(resource_personPgResource, $plan);
      if (undefined) {
        $select.coalesceToEmptyObject();
      }
      $select.getClassStep().setTrusted();
      return $select;
    }
  },
  MutationOutComplexSetofInput: {
    clientMutationId: {
      applyPlan: MutationOutComplexSetofInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    a: undefined,
    b: undefined
  },
  MutationOutTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutTablePayload_clientMutationIdPlan,
    person($object) {
      return $object.get("result");
    },
    query: MutationOutTablePayload_queryPlan,
    personEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques27[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_personPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  MutationOutTableInput: {
    clientMutationId: {
      applyPlan: MutationOutTableInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MutationOutTableSetofPayload: {
    __assertStep: ObjectStep,
    clientMutationId: MutationOutTableSetofPayload_clientMutationIdPlan,
    people($object) {
      return $object.get("result");
    },
    query: MutationOutTableSetofPayload_queryPlan
  },
  MutationOutTableSetofInput: {
    clientMutationId: {
      applyPlan: MutationOutTableSetofInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  TableSetMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: TableSetMutationPayload_clientMutationIdPlan,
    people($object) {
      return $object.get("result");
    },
    query: TableSetMutationPayload_queryPlan
  },
  TableSetMutationInput: {
    clientMutationId: {
      applyPlan: TableSetMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  TypeFunctionConnectionMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: TypeFunctionConnectionMutationPayload_clientMutationIdPlan,
    types($object) {
      return $object.get("result");
    },
    query: TypeFunctionConnectionMutationPayload_queryPlan
  },
  TypeFunctionConnectionMutationInput: {
    clientMutationId: {
      applyPlan: TypeFunctionConnectionMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  TypeFunctionMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: TypeFunctionMutationPayload_clientMutationIdPlan,
    type($object) {
      return $object.get("result");
    },
    query: TypeFunctionMutationPayload_queryPlan,
    typeEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques28[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_typesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("TypesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    postBySmallint($record) {
      return resource_postPgResource.get({
        id: $record.get("result").get("smallint")
      });
    },
    postById($record) {
      return resource_postPgResource.get({
        id: $record.get("result").get("id")
      });
    }
  },
  TypeFunctionMutationInput: {
    clientMutationId: {
      applyPlan: TypeFunctionMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    id: undefined
  },
  TypeFunctionListMutationPayload: {
    __assertStep: ObjectStep,
    clientMutationId: TypeFunctionListMutationPayload_clientMutationIdPlan,
    types($object) {
      return $object.get("result");
    },
    query: TypeFunctionListMutationPayload_queryPlan
  },
  TypeFunctionListMutationInput: {
    clientMutationId: {
      applyPlan: TypeFunctionListMutationInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateInputPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateInputPayload_clientMutationIdPlan,
    input: CreateInputPayload_inputPlan,
    query: CreateInputPayload_queryPlan,
    inputEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques2[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_inputsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("InputsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateInputInput: {
    clientMutationId: {
      applyPlan: CreateInputInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    input: {
      applyPlan: CreateInputInput_input_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  InputInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreatePatchPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreatePatchPayload_clientMutationIdPlan,
    patch: CreatePatchPayload_patchPlan,
    query: CreatePatchPayload_queryPlan,
    patchEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques3[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_patchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PatchesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreatePatchInput: {
    clientMutationId: {
      applyPlan: CreatePatchInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    patch: {
      applyPlan: CreatePatchInput_patch_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PatchInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateReservedPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateReservedPayload_clientMutationIdPlan,
    reserved: CreateReservedPayload_reservedPlan,
    query: CreateReservedPayload_queryPlan,
    reservedEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques4[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateReservedInput: {
    clientMutationId: {
      applyPlan: CreateReservedInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    reserved: {
      applyPlan: CreateReservedInput_reserved_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateReservedPatchRecordPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateReservedPatchRecordPayload_clientMutationIdPlan,
    reservedPatchRecord: CreateReservedPatchRecordPayload_reservedPatchRecordPlan,
    query: CreateReservedPatchRecordPayload_queryPlan,
    reservedPatchRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques5[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPatchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedPatchRecordsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateReservedPatchRecordInput: {
    clientMutationId: {
      applyPlan: CreateReservedPatchRecordInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    reservedPatchRecord: {
      applyPlan: CreateReservedPatchRecordInput_reservedPatchRecord_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedPatchRecordInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateReservedInputRecordPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateReservedInputRecordPayload_clientMutationIdPlan,
    reservedInputRecord: CreateReservedInputRecordPayload_reservedInputRecordPlan,
    query: CreateReservedInputRecordPayload_queryPlan,
    reservedInputRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques6[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reserved_inputPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedInputRecordsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateReservedInputRecordInput: {
    clientMutationId: {
      applyPlan: CreateReservedInputRecordInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    reservedInputRecord: {
      applyPlan: CreateReservedInputRecordInput_reservedInputRecord_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ReservedInputRecordInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateDefaultValuePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateDefaultValuePayload_clientMutationIdPlan,
    defaultValue: CreateDefaultValuePayload_defaultValuePlan,
    query: CreateDefaultValuePayload_queryPlan,
    defaultValueEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques7[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_default_valuePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("DefaultValuesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateDefaultValueInput: {
    clientMutationId: {
      applyPlan: CreateDefaultValueInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    defaultValue: {
      applyPlan: CreateDefaultValueInput_defaultValue_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  DefaultValueInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullValue: {
      applyPlan($insert, val) {
        $insert.set("null_value", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateForeignKeyPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateForeignKeyPayload_clientMutationIdPlan,
    foreignKey: CreateForeignKeyPayload_foreignKeyPlan,
    query: CreateForeignKeyPayload_queryPlan,
    compoundKeyByCompoundKey1AndCompoundKey2($record) {
      return resource_compound_keyPgResource.get({
        person_id_1: $record.get("result").get("compound_key_1"),
        person_id_2: $record.get("result").get("compound_key_2")
      });
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id")
      });
    }
  },
  CreateForeignKeyInput: {
    clientMutationId: {
      applyPlan: CreateForeignKeyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    foreignKey: {
      applyPlan: CreateForeignKeyInput_foreignKey_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ForeignKeyInput: {
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey1: {
      applyPlan($insert, val) {
        $insert.set("compound_key_1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey2: {
      applyPlan($insert, val) {
        $insert.set("compound_key_2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateNoPrimaryKeyPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateNoPrimaryKeyPayload_clientMutationIdPlan,
    noPrimaryKey: CreateNoPrimaryKeyPayload_noPrimaryKeyPlan,
    query: CreateNoPrimaryKeyPayload_queryPlan
  },
  CreateNoPrimaryKeyInput: {
    clientMutationId: {
      applyPlan: CreateNoPrimaryKeyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    noPrimaryKey: {
      applyPlan: CreateNoPrimaryKeyInput_noPrimaryKey_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  NoPrimaryKeyInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    str: {
      applyPlan($insert, val) {
        $insert.set("str", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateTestviewPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateTestviewPayload_clientMutationIdPlan,
    testview: CreateTestviewPayload_testviewPlan,
    query: CreateTestviewPayload_queryPlan
  },
  CreateTestviewInput: {
    clientMutationId: {
      applyPlan: CreateTestviewInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    testview: {
      applyPlan: CreateTestviewInput_testview_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  TestviewInput: {
    testviewid: {
      applyPlan($insert, val) {
        $insert.set("testviewid", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateMyTablePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateMyTablePayload_clientMutationIdPlan,
    myTable: CreateMyTablePayload_myTablePlan,
    query: CreateMyTablePayload_queryPlan,
    myTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques12[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_my_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("MyTablesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateMyTableInput: {
    clientMutationId: {
      applyPlan: CreateMyTableInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    myTable: {
      applyPlan: CreateMyTableInput_myTable_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MyTableInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonData: {
      applyPlan($insert, val) {
        $insert.set("json_data", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreatePersonSecretPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreatePersonSecretPayload_clientMutationIdPlan,
    personSecret: CreatePersonSecretPayload_personSecretPlan,
    query: CreatePersonSecretPayload_queryPlan,
    personSecretEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques13[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_person_secretPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PersonSecretsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id")
      });
    }
  },
  CreatePersonSecretInput: {
    clientMutationId: {
      applyPlan: CreatePersonSecretInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    personSecret: {
      applyPlan: CreatePersonSecretInput_personSecret_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PersonSecretInput: {
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    secret: {
      applyPlan($insert, val) {
        $insert.set("sekrit", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateViewTablePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateViewTablePayload_clientMutationIdPlan,
    viewTable: CreateViewTablePayload_viewTablePlan,
    query: CreateViewTablePayload_queryPlan,
    viewTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques14[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_view_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ViewTablesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateViewTableInput: {
    clientMutationId: {
      applyPlan: CreateViewTableInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    viewTable: {
      applyPlan: CreateViewTableInput_viewTable_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ViewTableInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCompoundKeyPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateCompoundKeyPayload_clientMutationIdPlan,
    compoundKey: CreateCompoundKeyPayload_compoundKeyPlan,
    query: CreateCompoundKeyPayload_queryPlan,
    compoundKeyEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques15[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_compound_keyPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CompoundKeysOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId1($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id_1")
      });
    },
    personByPersonId2($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id_2")
      });
    }
  },
  CreateCompoundKeyInput: {
    clientMutationId: {
      applyPlan: CreateCompoundKeyInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    compoundKey: {
      applyPlan: CreateCompoundKeyInput_compoundKey_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CompoundKeyInput: {
    personId2: {
      applyPlan($insert, val) {
        $insert.set("person_id_2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId1: {
      applyPlan($insert, val) {
        $insert.set("person_id_1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    extra: {
      applyPlan($insert, val) {
        $insert.set("extra", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateSimilarTable1Payload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateSimilarTable1Payload_clientMutationIdPlan,
    similarTable1: CreateSimilarTable1Payload_similarTable1Plan,
    query: CreateSimilarTable1Payload_queryPlan,
    similarTable1Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques16[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_1PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable1SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateSimilarTable1Input: {
    clientMutationId: {
      applyPlan: CreateSimilarTable1Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    similarTable1: {
      applyPlan: CreateSimilarTable1Input_similarTable1_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SimilarTable1Input: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($insert, val) {
        $insert.set("col3", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateSimilarTable2Payload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateSimilarTable2Payload_clientMutationIdPlan,
    similarTable2: CreateSimilarTable2Payload_similarTable2Plan,
    query: CreateSimilarTable2Payload_queryPlan,
    similarTable2Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques17[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_2PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable2SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateSimilarTable2Input: {
    clientMutationId: {
      applyPlan: CreateSimilarTable2Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    similarTable2: {
      applyPlan: CreateSimilarTable2Input_similarTable2_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  SimilarTable2Input: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($insert, val) {
        $insert.set("col3", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col4: {
      applyPlan($insert, val) {
        $insert.set("col4", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col5: {
      applyPlan($insert, val) {
        $insert.set("col5", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateUpdatableViewPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateUpdatableViewPayload_clientMutationIdPlan,
    updatableView: CreateUpdatableViewPayload_updatableViewPlan,
    query: CreateUpdatableViewPayload_queryPlan
  },
  CreateUpdatableViewInput: {
    clientMutationId: {
      applyPlan: CreateUpdatableViewInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    updatableView: {
      applyPlan: CreateUpdatableViewInput_updatableView_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatableViewInput: {
    x: {
      applyPlan($insert, val) {
        $insert.set("x", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($insert, val) {
        $insert.set("description", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    constant: {
      applyPlan($insert, val) {
        $insert.set("constant", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateNullTestRecordPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateNullTestRecordPayload_clientMutationIdPlan,
    nullTestRecord: CreateNullTestRecordPayload_nullTestRecordPlan,
    query: CreateNullTestRecordPayload_queryPlan,
    nullTestRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques19[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_null_test_recordPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("NullTestRecordsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateNullTestRecordInput: {
    clientMutationId: {
      applyPlan: CreateNullTestRecordInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    nullTestRecord: {
      applyPlan: CreateNullTestRecordInput_nullTestRecord_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  NullTestRecordInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableText: {
      applyPlan($insert, val) {
        $insert.set("nullable_text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableInt: {
      applyPlan($insert, val) {
        $insert.set("nullable_int", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nonNullText: {
      applyPlan($insert, val) {
        $insert.set("non_null_text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateEdgeCasePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateEdgeCasePayload_clientMutationIdPlan,
    edgeCase: CreateEdgeCasePayload_edgeCasePlan,
    query: CreateEdgeCasePayload_queryPlan
  },
  CreateEdgeCaseInput: {
    clientMutationId: {
      applyPlan: CreateEdgeCaseInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    edgeCase: {
      applyPlan: CreateEdgeCaseInput_edgeCase_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  EdgeCaseInput: {
    notNullHasDefault: {
      applyPlan($insert, val) {
        $insert.set("not_null_has_default", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    wontCastEasy: {
      applyPlan($insert, val) {
        $insert.set("wont_cast_easy", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("row_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateLeftArmPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateLeftArmPayload_clientMutationIdPlan,
    leftArm: CreateLeftArmPayload_leftArmPlan,
    query: CreateLeftArmPayload_queryPlan,
    leftArmEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_left_armPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("LeftArmsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id")
      });
    }
  },
  CreateLeftArmInput: {
    clientMutationId: {
      applyPlan: CreateLeftArmInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    leftArm: {
      applyPlan: CreateLeftArmInput_leftArm_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  LeftArmInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lengthInMetres: {
      applyPlan($insert, val) {
        $insert.set("length_in_metres", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    mood: {
      applyPlan($insert, val) {
        $insert.set("mood", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateIssue756Payload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateIssue756Payload_clientMutationIdPlan,
    issue756: CreateIssue756Payload_issue756Plan,
    query: CreateIssue756Payload_queryPlan,
    issue756Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques23[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_issue756PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("Issue756SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateIssue756Input: {
    clientMutationId: {
      applyPlan: CreateIssue756Input_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    issue756: {
      applyPlan: CreateIssue756Input_issue756_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  Issue756Input: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ts: {
      applyPlan($insert, val) {
        $insert.set("ts", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreatePostPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreatePostPayload_clientMutationIdPlan,
    post: CreatePostPayload_postPlan,
    query: CreatePostPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByAuthorId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("author_id")
      });
    }
  },
  CreatePostInput: {
    clientMutationId: {
      applyPlan: CreatePostInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    post: {
      applyPlan: CreatePostInput_post_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreatePersonPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreatePersonPayload_clientMutationIdPlan,
    person: CreatePersonPayload_personPlan,
    query: CreatePersonPayload_queryPlan,
    personEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques27[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_personPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreatePersonInput: {
    clientMutationId: {
      applyPlan: CreatePersonInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    person: {
      applyPlan: CreatePersonInput_person_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PersonInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("person_full_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    aliases: {
      applyPlan($insert, val) {
        $insert.set("aliases", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    about: {
      applyPlan($insert, val) {
        $insert.set("about", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($insert, val) {
        $insert.set("email", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    site: {
      applyPlan($insert, val) {
        $insert.set("site", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    config: {
      applyPlan($insert, val) {
        $insert.set("config", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromIp: {
      applyPlan($insert, val) {
        $insert.set("last_login_from_ip", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromSubnet: {
      applyPlan($insert, val) {
        $insert.set("last_login_from_subnet", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userMac: {
      applyPlan($insert, val) {
        $insert.set("user_mac", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateTypePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId: CreateTypePayload_clientMutationIdPlan,
    type: CreateTypePayload_typePlan,
    query: CreateTypePayload_queryPlan,
    typeEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques28[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_typesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("TypesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    postBySmallint($record) {
      return resource_postPgResource.get({
        id: $record.get("result").get("smallint")
      });
    },
    postById($record) {
      return resource_postPgResource.get({
        id: $record.get("result").get("id")
      });
    }
  },
  CreateTypeInput: {
    clientMutationId: {
      applyPlan: CreateTypeInput_clientMutationId_applyPlan,
      autoApplyAfterParentApplyPlan: true
    },
    type: {
      applyPlan: CreateTypeInput_type_applyPlan,
      autoApplyAfterParentApplyPlan: true
    }
  },
  TypeInput: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    smallint: {
      applyPlan($insert, val) {
        $insert.set("smallint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bigint: {
      applyPlan($insert, val) {
        $insert.set("bigint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numeric: {
      applyPlan($insert, val) {
        $insert.set("numeric", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    decimal: {
      applyPlan($insert, val) {
        $insert.set("decimal", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    boolean: {
      applyPlan($insert, val) {
        $insert.set("boolean", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    varchar: {
      applyPlan($insert, val) {
        $insert.set("varchar", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enum: {
      applyPlan($insert, val) {
        $insert.set("enum", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enumArray: {
      applyPlan($insert, val) {
        $insert.set("enum_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain: {
      applyPlan($insert, val) {
        $insert.set("domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain2: {
      applyPlan($insert, val) {
        $insert.set("domain2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArray: {
      applyPlan($insert, val) {
        $insert.set("text_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    json: {
      applyPlan($insert, val) {
        $insert.set("json", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonb: {
      applyPlan($insert, val) {
        $insert.set("jsonb", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableRange: {
      applyPlan($insert, val) {
        $insert.set("nullable_range", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numrange: {
      applyPlan($insert, val) {
        $insert.set("numrange", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    daterange: {
      applyPlan($insert, val) {
        $insert.set("daterange", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    anIntRange: {
      applyPlan($insert, val) {
        $insert.set("an_int_range", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamp: {
      applyPlan($insert, val) {
        $insert.set("timestamp", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamptz: {
      applyPlan($insert, val) {
        $insert.set("timestamptz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    date: {
      applyPlan($insert, val) {
        $insert.set("date", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    time: {
      applyPlan($insert, val) {
        $insert.set("time", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timetz: {
      applyPlan($insert, val) {
        $insert.set("timetz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    interval: {
      applyPlan($insert, val) {
        $insert.set("interval", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    intervalArray: {
      applyPlan($insert, val) {
        $insert.set("interval_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    money: {
      applyPlan($insert, val) {
        $insert.set("money", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundType: {
      applyPlan($insert, val) {
        $insert.set("compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nestedCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nested_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nullable_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableNestedCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nullable_nested_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    point: {
      applyPlan($insert, val) {
        $insert.set("point", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullablePoint: {
      applyPlan($insert, val) {
        $insert.set("nullablePoint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    inet: {
      applyPlan($insert, val) {
        $insert.set("inet", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cidr: {
      applyPlan($insert, val) {
        $insert.set("cidr", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    macaddr: {
      applyPlan($insert, val) {
        $insert.set("macaddr", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regproc: {
      applyPlan($insert, val) {
        $insert.set("regproc", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regprocedure: {
      applyPlan($insert, val) {
        $insert.set("regprocedure", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoper: {
      applyPlan($insert, val) {
        $insert.set("regoper", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoperator: {
      applyPlan($insert, val) {
        $insert.set("regoperator", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regclass: {
      applyPlan($insert, val) {
        $insert.set("regclass", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regtype: {
      applyPlan($insert, val) {
        $insert.set("regtype", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regconfig: {
      applyPlan($insert, val) {
        $insert.set("regconfig", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regdictionary: {
      applyPlan($insert, val) {
        $insert.set("regdictionary", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArrayDomain: {
      applyPlan($insert, val) {
        $insert.set("text_array_domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    int8ArrayDomain: {
      applyPlan($insert, val) {
        $insert.set("int8_array_domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bytea: {
      applyPlan($insert, val) {
        $insert.set("bytea", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    byteaArray: {
      applyPlan($insert, val) {
        $insert.set("bytea_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltree: {
      applyPlan($insert, val) {
        $insert.set("ltree", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltreeArray: {
      applyPlan($insert, val) {
        $insert.set("ltree_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateInputPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateInputPayload_clientMutationIdPlan,
    input: UpdateInputPayload_inputPlan,
    query: UpdateInputPayload_queryPlan,
    inputEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques2[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_inputsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("InputsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateInputByIdInput: {
    clientMutationId: {
      applyPlan: UpdateInputByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    inputPatch: {
      applyPlan: UpdateInputByIdInput_inputPatch_applyPlan
    }
  },
  InputPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePatchPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdatePatchPayload_clientMutationIdPlan,
    patch: UpdatePatchPayload_patchPlan,
    query: UpdatePatchPayload_queryPlan,
    patchEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques3[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_patchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PatchesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdatePatchByIdInput: {
    clientMutationId: {
      applyPlan: UpdatePatchByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    patchPatch: {
      applyPlan: UpdatePatchByIdInput_patchPatch_applyPlan
    }
  },
  PatchPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateReservedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateReservedPayload_clientMutationIdPlan,
    reserved: UpdateReservedPayload_reservedPlan,
    query: UpdateReservedPayload_queryPlan,
    reservedEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques4[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateReservedByIdInput: {
    clientMutationId: {
      applyPlan: UpdateReservedByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    reservedPatch: {
      applyPlan: UpdateReservedByIdInput_reservedPatch_applyPlan
    }
  },
  ReservedPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateReservedPatchRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateReservedPatchRecordPayload_clientMutationIdPlan,
    reservedPatchRecord: UpdateReservedPatchRecordPayload_reservedPatchRecordPlan,
    query: UpdateReservedPatchRecordPayload_queryPlan,
    reservedPatchRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques5[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPatchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedPatchRecordsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateReservedPatchRecordByIdInput: {
    clientMutationId: {
      applyPlan: UpdateReservedPatchRecordByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    reservedPatchRecordPatch: {
      applyPlan: UpdateReservedPatchRecordByIdInput_reservedPatchRecordPatch_applyPlan
    }
  },
  ReservedPatchRecordPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateReservedInputRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateReservedInputRecordPayload_clientMutationIdPlan,
    reservedInputRecord: UpdateReservedInputRecordPayload_reservedInputRecordPlan,
    query: UpdateReservedInputRecordPayload_queryPlan,
    reservedInputRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques6[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reserved_inputPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedInputRecordsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateReservedInputRecordByIdInput: {
    clientMutationId: {
      applyPlan: UpdateReservedInputRecordByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    reservedInputRecordPatch: {
      applyPlan: UpdateReservedInputRecordByIdInput_reservedInputRecordPatch_applyPlan
    }
  },
  ReservedInputRecordPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateDefaultValuePayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateDefaultValuePayload_clientMutationIdPlan,
    defaultValue: UpdateDefaultValuePayload_defaultValuePlan,
    query: UpdateDefaultValuePayload_queryPlan,
    defaultValueEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques7[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_default_valuePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("DefaultValuesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateDefaultValueByIdInput: {
    clientMutationId: {
      applyPlan: UpdateDefaultValueByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    defaultValuePatch: {
      applyPlan: UpdateDefaultValueByIdInput_defaultValuePatch_applyPlan
    }
  },
  DefaultValuePatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullValue: {
      applyPlan($insert, val) {
        $insert.set("null_value", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateNoPrimaryKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateNoPrimaryKeyPayload_clientMutationIdPlan,
    noPrimaryKey: UpdateNoPrimaryKeyPayload_noPrimaryKeyPlan,
    query: UpdateNoPrimaryKeyPayload_queryPlan
  },
  UpdateNoPrimaryKeyByIdInput: {
    clientMutationId: {
      applyPlan: UpdateNoPrimaryKeyByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    noPrimaryKeyPatch: {
      applyPlan: UpdateNoPrimaryKeyByIdInput_noPrimaryKeyPatch_applyPlan
    }
  },
  NoPrimaryKeyPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    str: {
      applyPlan($insert, val) {
        $insert.set("str", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateMyTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateMyTablePayload_clientMutationIdPlan,
    myTable: UpdateMyTablePayload_myTablePlan,
    query: UpdateMyTablePayload_queryPlan,
    myTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques12[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_my_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("MyTablesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateMyTableByIdInput: {
    clientMutationId: {
      applyPlan: UpdateMyTableByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    myTablePatch: {
      applyPlan: UpdateMyTableByIdInput_myTablePatch_applyPlan
    }
  },
  MyTablePatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonData: {
      applyPlan($insert, val) {
        $insert.set("json_data", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePersonSecretPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdatePersonSecretPayload_clientMutationIdPlan,
    personSecret: UpdatePersonSecretPayload_personSecretPlan,
    query: UpdatePersonSecretPayload_queryPlan,
    personSecretEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques13[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_person_secretPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PersonSecretsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id")
      });
    }
  },
  UpdatePersonSecretByPersonIdInput: {
    clientMutationId: {
      applyPlan: UpdatePersonSecretByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined,
    personSecretPatch: {
      applyPlan: UpdatePersonSecretByPersonIdInput_personSecretPatch_applyPlan
    }
  },
  PersonSecretPatch: {
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    secret: {
      applyPlan($insert, val) {
        $insert.set("sekrit", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateViewTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateViewTablePayload_clientMutationIdPlan,
    viewTable: UpdateViewTablePayload_viewTablePlan,
    query: UpdateViewTablePayload_queryPlan,
    viewTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques14[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_view_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ViewTablesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateViewTableByIdInput: {
    clientMutationId: {
      applyPlan: UpdateViewTableByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    viewTablePatch: {
      applyPlan: UpdateViewTableByIdInput_viewTablePatch_applyPlan
    }
  },
  ViewTablePatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCompoundKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateCompoundKeyPayload_clientMutationIdPlan,
    compoundKey: UpdateCompoundKeyPayload_compoundKeyPlan,
    query: UpdateCompoundKeyPayload_queryPlan,
    compoundKeyEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques15[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_compound_keyPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CompoundKeysOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId1($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id_1")
      });
    },
    personByPersonId2($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id_2")
      });
    }
  },
  UpdateCompoundKeyByPersonId1AndPersonId2Input: {
    clientMutationId: {
      applyPlan: UpdateCompoundKeyByPersonId1AndPersonId2Input_clientMutationId_applyPlan
    },
    personId1: undefined,
    personId2: undefined,
    compoundKeyPatch: {
      applyPlan: UpdateCompoundKeyByPersonId1AndPersonId2Input_compoundKeyPatch_applyPlan
    }
  },
  CompoundKeyPatch: {
    personId2: {
      applyPlan($insert, val) {
        $insert.set("person_id_2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId1: {
      applyPlan($insert, val) {
        $insert.set("person_id_1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    extra: {
      applyPlan($insert, val) {
        $insert.set("extra", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateSimilarTable1Payload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateSimilarTable1Payload_clientMutationIdPlan,
    similarTable1: UpdateSimilarTable1Payload_similarTable1Plan,
    query: UpdateSimilarTable1Payload_queryPlan,
    similarTable1Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques16[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_1PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable1SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateSimilarTable1ByIdInput: {
    clientMutationId: {
      applyPlan: UpdateSimilarTable1ByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    similarTable1Patch: {
      applyPlan: UpdateSimilarTable1ByIdInput_similarTable1Patch_applyPlan
    }
  },
  SimilarTable1Patch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col1: {
      applyPlan($insert, val) {
        $insert.set("col1", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col2: {
      applyPlan($insert, val) {
        $insert.set("col2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($insert, val) {
        $insert.set("col3", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateSimilarTable2Payload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateSimilarTable2Payload_clientMutationIdPlan,
    similarTable2: UpdateSimilarTable2Payload_similarTable2Plan,
    query: UpdateSimilarTable2Payload_queryPlan,
    similarTable2Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques17[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_2PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable2SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateSimilarTable2ByIdInput: {
    clientMutationId: {
      applyPlan: UpdateSimilarTable2ByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    similarTable2Patch: {
      applyPlan: UpdateSimilarTable2ByIdInput_similarTable2Patch_applyPlan
    }
  },
  SimilarTable2Patch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col3: {
      applyPlan($insert, val) {
        $insert.set("col3", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col4: {
      applyPlan($insert, val) {
        $insert.set("col4", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    col5: {
      applyPlan($insert, val) {
        $insert.set("col5", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateNullTestRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateNullTestRecordPayload_clientMutationIdPlan,
    nullTestRecord: UpdateNullTestRecordPayload_nullTestRecordPlan,
    query: UpdateNullTestRecordPayload_queryPlan,
    nullTestRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques19[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_null_test_recordPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("NullTestRecordsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateNullTestRecordByIdInput: {
    clientMutationId: {
      applyPlan: UpdateNullTestRecordByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    nullTestRecordPatch: {
      applyPlan: UpdateNullTestRecordByIdInput_nullTestRecordPatch_applyPlan
    }
  },
  NullTestRecordPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableText: {
      applyPlan($insert, val) {
        $insert.set("nullable_text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableInt: {
      applyPlan($insert, val) {
        $insert.set("nullable_int", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nonNullText: {
      applyPlan($insert, val) {
        $insert.set("non_null_text", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateLeftArmPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateLeftArmPayload_clientMutationIdPlan,
    leftArm: UpdateLeftArmPayload_leftArmPlan,
    query: UpdateLeftArmPayload_queryPlan,
    leftArmEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_left_armPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("LeftArmsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id")
      });
    }
  },
  UpdateLeftArmByIdInput: {
    clientMutationId: {
      applyPlan: UpdateLeftArmByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    leftArmPatch: {
      applyPlan: UpdateLeftArmByIdInput_leftArmPatch_applyPlan
    }
  },
  LeftArmPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    personId: {
      applyPlan($insert, val) {
        $insert.set("person_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lengthInMetres: {
      applyPlan($insert, val) {
        $insert.set("length_in_metres", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    mood: {
      applyPlan($insert, val) {
        $insert.set("mood", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateLeftArmByPersonIdInput: {
    clientMutationId: {
      applyPlan: UpdateLeftArmByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined,
    leftArmPatch: {
      applyPlan: UpdateLeftArmByPersonIdInput_leftArmPatch_applyPlan
    }
  },
  UpdateIssue756Payload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateIssue756Payload_clientMutationIdPlan,
    issue756: UpdateIssue756Payload_issue756Plan,
    query: UpdateIssue756Payload_queryPlan,
    issue756Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques23[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_issue756PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("Issue756SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateIssue756ByIdInput: {
    clientMutationId: {
      applyPlan: UpdateIssue756ByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    issue756Patch: {
      applyPlan: UpdateIssue756ByIdInput_issue756Patch_applyPlan
    }
  },
  Issue756Patch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ts: {
      applyPlan($insert, val) {
        $insert.set("ts", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePostPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdatePostPayload_clientMutationIdPlan,
    post: UpdatePostPayload_postPlan,
    query: UpdatePostPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByAuthorId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("author_id")
      });
    }
  },
  UpdatePostByIdInput: {
    clientMutationId: {
      applyPlan: UpdatePostByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    postPatch: {
      applyPlan: UpdatePostByIdInput_postPatch_applyPlan
    }
  },
  PostPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    headline: {
      applyPlan($insert, val) {
        $insert.set("headline", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    body: {
      applyPlan($insert, val) {
        $insert.set("body", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    authorId: {
      applyPlan($insert, val) {
        $insert.set("author_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enums: {
      applyPlan($insert, val) {
        $insert.set("enums", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    comptypes: {
      applyPlan($insert, val) {
        $insert.set("comptypes", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePersonPayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdatePersonPayload_clientMutationIdPlan,
    person: UpdatePersonPayload_personPlan,
    query: UpdatePersonPayload_queryPlan,
    personEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques27[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_personPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdatePersonByIdInput: {
    clientMutationId: {
      applyPlan: UpdatePersonByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    personPatch: {
      applyPlan: UpdatePersonByIdInput_personPatch_applyPlan
    }
  },
  PersonPatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("person_full_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    aliases: {
      applyPlan($insert, val) {
        $insert.set("aliases", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    about: {
      applyPlan($insert, val) {
        $insert.set("about", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($insert, val) {
        $insert.set("email", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    site: {
      applyPlan($insert, val) {
        $insert.set("site", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    config: {
      applyPlan($insert, val) {
        $insert.set("config", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromIp: {
      applyPlan($insert, val) {
        $insert.set("last_login_from_ip", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastLoginFromSubnet: {
      applyPlan($insert, val) {
        $insert.set("last_login_from_subnet", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userMac: {
      applyPlan($insert, val) {
        $insert.set("user_mac", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePersonByEmailInput: {
    clientMutationId: {
      applyPlan: UpdatePersonByEmailInput_clientMutationId_applyPlan
    },
    email: undefined,
    personPatch: {
      applyPlan: UpdatePersonByEmailInput_personPatch_applyPlan
    }
  },
  UpdateTypePayload: {
    __assertStep: ObjectStep,
    clientMutationId: UpdateTypePayload_clientMutationIdPlan,
    type: UpdateTypePayload_typePlan,
    query: UpdateTypePayload_queryPlan,
    typeEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques28[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_typesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("TypesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    postBySmallint($record) {
      return resource_postPgResource.get({
        id: $record.get("result").get("smallint")
      });
    },
    postById($record) {
      return resource_postPgResource.get({
        id: $record.get("result").get("id")
      });
    }
  },
  UpdateTypeByIdInput: {
    clientMutationId: {
      applyPlan: UpdateTypeByIdInput_clientMutationId_applyPlan
    },
    id: undefined,
    typePatch: {
      applyPlan: UpdateTypeByIdInput_typePatch_applyPlan
    }
  },
  TypePatch: {
    id: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    smallint: {
      applyPlan($insert, val) {
        $insert.set("smallint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bigint: {
      applyPlan($insert, val) {
        $insert.set("bigint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numeric: {
      applyPlan($insert, val) {
        $insert.set("numeric", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    decimal: {
      applyPlan($insert, val) {
        $insert.set("decimal", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    boolean: {
      applyPlan($insert, val) {
        $insert.set("boolean", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    varchar: {
      applyPlan($insert, val) {
        $insert.set("varchar", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enum: {
      applyPlan($insert, val) {
        $insert.set("enum", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    enumArray: {
      applyPlan($insert, val) {
        $insert.set("enum_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain: {
      applyPlan($insert, val) {
        $insert.set("domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    domain2: {
      applyPlan($insert, val) {
        $insert.set("domain2", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArray: {
      applyPlan($insert, val) {
        $insert.set("text_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    json: {
      applyPlan($insert, val) {
        $insert.set("json", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    jsonb: {
      applyPlan($insert, val) {
        $insert.set("jsonb", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableRange: {
      applyPlan($insert, val) {
        $insert.set("nullable_range", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    numrange: {
      applyPlan($insert, val) {
        $insert.set("numrange", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    daterange: {
      applyPlan($insert, val) {
        $insert.set("daterange", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    anIntRange: {
      applyPlan($insert, val) {
        $insert.set("an_int_range", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamp: {
      applyPlan($insert, val) {
        $insert.set("timestamp", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timestamptz: {
      applyPlan($insert, val) {
        $insert.set("timestamptz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    date: {
      applyPlan($insert, val) {
        $insert.set("date", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    time: {
      applyPlan($insert, val) {
        $insert.set("time", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    timetz: {
      applyPlan($insert, val) {
        $insert.set("timetz", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    interval: {
      applyPlan($insert, val) {
        $insert.set("interval", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    intervalArray: {
      applyPlan($insert, val) {
        $insert.set("interval_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    money: {
      applyPlan($insert, val) {
        $insert.set("money", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    compoundType: {
      applyPlan($insert, val) {
        $insert.set("compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nestedCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nested_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nullable_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullableNestedCompoundType: {
      applyPlan($insert, val) {
        $insert.set("nullable_nested_compound_type", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    point: {
      applyPlan($insert, val) {
        $insert.set("point", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    nullablePoint: {
      applyPlan($insert, val) {
        $insert.set("nullablePoint", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    inet: {
      applyPlan($insert, val) {
        $insert.set("inet", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    cidr: {
      applyPlan($insert, val) {
        $insert.set("cidr", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    macaddr: {
      applyPlan($insert, val) {
        $insert.set("macaddr", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regproc: {
      applyPlan($insert, val) {
        $insert.set("regproc", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regprocedure: {
      applyPlan($insert, val) {
        $insert.set("regprocedure", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoper: {
      applyPlan($insert, val) {
        $insert.set("regoper", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regoperator: {
      applyPlan($insert, val) {
        $insert.set("regoperator", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regclass: {
      applyPlan($insert, val) {
        $insert.set("regclass", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regtype: {
      applyPlan($insert, val) {
        $insert.set("regtype", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regconfig: {
      applyPlan($insert, val) {
        $insert.set("regconfig", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    regdictionary: {
      applyPlan($insert, val) {
        $insert.set("regdictionary", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    textArrayDomain: {
      applyPlan($insert, val) {
        $insert.set("text_array_domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    int8ArrayDomain: {
      applyPlan($insert, val) {
        $insert.set("int8_array_domain", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    bytea: {
      applyPlan($insert, val) {
        $insert.set("bytea", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    byteaArray: {
      applyPlan($insert, val) {
        $insert.set("bytea_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltree: {
      applyPlan($insert, val) {
        $insert.set("ltree", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    ltreeArray: {
      applyPlan($insert, val) {
        $insert.set("ltree_array", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  DeleteInputPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteInputPayload_clientMutationIdPlan,
    input: DeleteInputPayload_inputPlan,
    query: DeleteInputPayload_queryPlan,
    inputEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques2[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_inputsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("InputsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteInputByIdInput: {
    clientMutationId: {
      applyPlan: DeleteInputByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeletePatchPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeletePatchPayload_clientMutationIdPlan,
    patch: DeletePatchPayload_patchPlan,
    query: DeletePatchPayload_queryPlan,
    patchEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques3[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_patchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PatchesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeletePatchByIdInput: {
    clientMutationId: {
      applyPlan: DeletePatchByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteReservedPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteReservedPayload_clientMutationIdPlan,
    reserved: DeleteReservedPayload_reservedPlan,
    query: DeleteReservedPayload_queryPlan,
    reservedEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques4[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteReservedByIdInput: {
    clientMutationId: {
      applyPlan: DeleteReservedByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteReservedPatchRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteReservedPatchRecordPayload_clientMutationIdPlan,
    reservedPatchRecord: DeleteReservedPatchRecordPayload_reservedPatchRecordPlan,
    query: DeleteReservedPatchRecordPayload_queryPlan,
    reservedPatchRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques5[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reservedPatchsPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedPatchRecordsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteReservedPatchRecordByIdInput: {
    clientMutationId: {
      applyPlan: DeleteReservedPatchRecordByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteReservedInputRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteReservedInputRecordPayload_clientMutationIdPlan,
    reservedInputRecord: DeleteReservedInputRecordPayload_reservedInputRecordPlan,
    query: DeleteReservedInputRecordPayload_queryPlan,
    reservedInputRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques6[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_reserved_inputPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ReservedInputRecordsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteReservedInputRecordByIdInput: {
    clientMutationId: {
      applyPlan: DeleteReservedInputRecordByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteDefaultValuePayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteDefaultValuePayload_clientMutationIdPlan,
    defaultValue: DeleteDefaultValuePayload_defaultValuePlan,
    query: DeleteDefaultValuePayload_queryPlan,
    defaultValueEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques7[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_default_valuePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("DefaultValuesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteDefaultValueByIdInput: {
    clientMutationId: {
      applyPlan: DeleteDefaultValueByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteNoPrimaryKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteNoPrimaryKeyPayload_clientMutationIdPlan,
    noPrimaryKey: DeleteNoPrimaryKeyPayload_noPrimaryKeyPlan,
    query: DeleteNoPrimaryKeyPayload_queryPlan
  },
  DeleteNoPrimaryKeyByIdInput: {
    clientMutationId: {
      applyPlan: DeleteNoPrimaryKeyByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteMyTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteMyTablePayload_clientMutationIdPlan,
    myTable: DeleteMyTablePayload_myTablePlan,
    query: DeleteMyTablePayload_queryPlan,
    myTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques12[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_my_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("MyTablesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteMyTableByIdInput: {
    clientMutationId: {
      applyPlan: DeleteMyTableByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeletePersonSecretPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeletePersonSecretPayload_clientMutationIdPlan,
    personSecret: DeletePersonSecretPayload_personSecretPlan,
    query: DeletePersonSecretPayload_queryPlan,
    personSecretEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques13[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_person_secretPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PersonSecretsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id")
      });
    }
  },
  DeletePersonSecretByPersonIdInput: {
    clientMutationId: {
      applyPlan: DeletePersonSecretByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined
  },
  DeleteViewTablePayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteViewTablePayload_clientMutationIdPlan,
    viewTable: DeleteViewTablePayload_viewTablePlan,
    query: DeleteViewTablePayload_queryPlan,
    viewTableEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques14[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_view_tablePgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ViewTablesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteViewTableByIdInput: {
    clientMutationId: {
      applyPlan: DeleteViewTableByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteCompoundKeyPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteCompoundKeyPayload_clientMutationIdPlan,
    compoundKey: DeleteCompoundKeyPayload_compoundKeyPlan,
    query: DeleteCompoundKeyPayload_queryPlan,
    compoundKeyEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques15[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_compound_keyPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CompoundKeysOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId1($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id_1")
      });
    },
    personByPersonId2($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id_2")
      });
    }
  },
  DeleteCompoundKeyByPersonId1AndPersonId2Input: {
    clientMutationId: {
      applyPlan: DeleteCompoundKeyByPersonId1AndPersonId2Input_clientMutationId_applyPlan
    },
    personId1: undefined,
    personId2: undefined
  },
  DeleteSimilarTable1Payload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteSimilarTable1Payload_clientMutationIdPlan,
    similarTable1: DeleteSimilarTable1Payload_similarTable1Plan,
    query: DeleteSimilarTable1Payload_queryPlan,
    similarTable1Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques16[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_1PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable1SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteSimilarTable1ByIdInput: {
    clientMutationId: {
      applyPlan: DeleteSimilarTable1ByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteSimilarTable2Payload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteSimilarTable2Payload_clientMutationIdPlan,
    similarTable2: DeleteSimilarTable2Payload_similarTable2Plan,
    query: DeleteSimilarTable2Payload_queryPlan,
    similarTable2Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques17[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_similar_table_2PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("SimilarTable2SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteSimilarTable2ByIdInput: {
    clientMutationId: {
      applyPlan: DeleteSimilarTable2ByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteNullTestRecordPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteNullTestRecordPayload_clientMutationIdPlan,
    nullTestRecord: DeleteNullTestRecordPayload_nullTestRecordPlan,
    query: DeleteNullTestRecordPayload_queryPlan,
    nullTestRecordEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques19[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_null_test_recordPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("NullTestRecordsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteNullTestRecordByIdInput: {
    clientMutationId: {
      applyPlan: DeleteNullTestRecordByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteLeftArmPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteLeftArmPayload_clientMutationIdPlan,
    leftArm: DeleteLeftArmPayload_leftArmPlan,
    query: DeleteLeftArmPayload_queryPlan,
    leftArmEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques21[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_left_armPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("LeftArmsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByPersonId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("person_id")
      });
    }
  },
  DeleteLeftArmByIdInput: {
    clientMutationId: {
      applyPlan: DeleteLeftArmByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeleteLeftArmByPersonIdInput: {
    clientMutationId: {
      applyPlan: DeleteLeftArmByPersonIdInput_clientMutationId_applyPlan
    },
    personId: undefined
  },
  DeleteIssue756Payload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteIssue756Payload_clientMutationIdPlan,
    issue756: DeleteIssue756Payload_issue756Plan,
    query: DeleteIssue756Payload_queryPlan,
    issue756Edge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques23[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_issue756PgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("Issue756SOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteIssue756ByIdInput: {
    clientMutationId: {
      applyPlan: DeleteIssue756ByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeletePostPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeletePostPayload_clientMutationIdPlan,
    post: DeletePostPayload_postPlan,
    query: DeletePostPayload_queryPlan,
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques25[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_postPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostsOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    personByAuthorId($record) {
      return resource_personPgResource.get({
        id: $record.get("result").get("author_id")
      });
    }
  },
  DeletePostByIdInput: {
    clientMutationId: {
      applyPlan: DeletePostByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeletePersonPayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeletePersonPayload_clientMutationIdPlan,
    person: DeletePersonPayload_personPlan,
    query: DeletePersonPayload_queryPlan,
    personEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques27[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_personPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PeopleOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeletePersonByIdInput: {
    clientMutationId: {
      applyPlan: DeletePersonByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  },
  DeletePersonByEmailInput: {
    clientMutationId: {
      applyPlan: DeletePersonByEmailInput_clientMutationId_applyPlan
    },
    email: undefined
  },
  DeleteTypePayload: {
    __assertStep: ObjectStep,
    clientMutationId: DeleteTypePayload_clientMutationIdPlan,
    type: DeleteTypePayload_typePlan,
    query: DeleteTypePayload_queryPlan,
    typeEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", true);
        if (!$result) {
          return constant(null);
        }
        const $select = (() => {
          if ($result instanceof PgDeleteSingleStep) {
            return pgSelectFromRecord($result.resource, $result.record());
          } else {
            const spec = uniques28[0].attributes.reduce((memo, attributeName) => {
              memo[attributeName] = $result.get(attributeName);
              return memo;
            }, Object.create(null));
            return resource_typesPgResource.find(spec);
          }
        })();
        // Perform ordering
        const $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("TypesOrderBy"));
        const $connection = connection($select);
        // NOTE: you must not use `$single = $select.single()`
        // here because doing so will mark the row as unique, and
        // then the ordering logic (and thus cursor) will differ.
        const $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    },
    postBySmallint($record) {
      return resource_postPgResource.get({
        id: $record.get("result").get("smallint")
      });
    },
    postById($record) {
      return resource_postPgResource.get({
        id: $record.get("result").get("id")
      });
    }
  },
  DeleteTypeByIdInput: {
    clientMutationId: {
      applyPlan: DeleteTypeByIdInput_clientMutationId_applyPlan
    },
    id: undefined
  }
};
export const schema = makeGrafastSchema({
  typeDefs: typeDefs,
  plans: plans
});
