import {
  SchemaBuilder,
  Build,
  Plugin,
  Options,
  ContextGraphQLObjectTypeFieldsField,
  BuildBase,
  ScopeGraphQLEnumType,
  ScopeGraphQLObjectType,
  GraphileObjectTypeConfig,
  ContextGraphQLObjectTypeFields,
  ContextGraphQLInputObjectTypeFields,
  ScopeGraphQLUnionType,
  GraphileUnionTypeConfig,
  ScopeGraphQLObjectTypeFieldsField,
} from "graphile-build";
import { QueryBuilder, PgClass, PgEntityKind } from "graphile-build-pg";
import { GraphileEmbed } from "./gql";
import { InputObjectTypeExtensionNode } from "graphql/language/ast";

import { GraphileHelpers, makeFieldHelpers } from "./fieldHelpers";
import { DirectiveMap } from "graphile-build/node8plus/SchemaBuilder";

// TODO:v5: Remove
const recurseDataGeneratorsWorkaroundFieldByType = new Map();

export type AugmentedGraphQLFieldResolver<
  TSource,
  TContext,
  TArgs = { [argName: string]: any }
> = (
  parent: TSource,
  args: TArgs,
  context: TContext,
  info: import("graphql").GraphQLResolveInfo & {
    graphile: GraphileHelpers;
  },
  useInfoDotGraphileInstead: GraphileHelpers
) => any;

export interface ObjectFieldResolver<TSource = any, TContext = any> {
  resolve?: AugmentedGraphQLFieldResolver<TSource, TContext>;
  subscribe?: AugmentedGraphQLFieldResolver<TSource, TContext>;
  __resolveType?: import("graphql").GraphQLTypeResolver<TSource, TContext>;
  __isTypeOf?: import("graphql").GraphQLIsTypeOfFn<TSource, TContext>;
}

export interface ObjectResolver<TSource = any, TContext = any> {
  [fieldName: string]:
    | AugmentedGraphQLFieldResolver<TSource, TContext>
    | ObjectFieldResolver<TSource, TContext>;
}

export interface EnumResolver {
  [valueName: string]: string | number | Array<any> | object | symbol;
}

export type UnionResolver<TSource = any, TContext = any> = {
  __resolveType?: import("graphql").GraphQLTypeResolver<TSource, TContext>;
};

export interface Resolvers<TSource = any, TContext = any> {
  [typeName: string]:
    | ObjectResolver<TSource, TContext>
    | EnumResolver
    | UnionResolver;
}

export interface ExtensionDefinition {
  typeDefs: import("graphql").DocumentNode;
  resolvers?: Resolvers;
}

interface NewTypeDef {
  type:
    | typeof import("graphql").GraphQLDirective
    | typeof import("graphql").GraphQLScalarType
    | typeof import("graphql").GraphQLObjectType
    | typeof import("graphql").GraphQLInterfaceType
    | typeof import("graphql").GraphQLUnionType
    | typeof import("graphql").GraphQLEnumType
    | typeof import("graphql").GraphQLInputObjectType;

  definition: any;
}

interface TypeExtensions {
  GraphQLSchema: {
    directives: Array<any>;
    types: Array<any>;
  };
  GraphQLInputObjectType: { [name: string]: InputObjectTypeExtensionNode[] };
  GraphQLObjectType: {
    [name: string]: import("graphql").ObjectTypeExtensionNode[];
  };
}

export default function makeExtendSchemaPlugin(
  generator:
    | ExtensionDefinition
    | ((
        build: Partial<Build> & BuildBase,
        schemaOptions: Options
      ) => ExtensionDefinition),
  uniqueId = String(Math.random()).substr(2)
): Plugin {
  let graphql: Build["graphql"];
  return (builder: SchemaBuilder, schemaOptions: Options): void => {
    // Add stuff to the schema
    builder.hook("build", build => {
      // Extract GraphQL into the scope so that our other functions can use it.
      graphql = build.graphql;

      const { addType } = build;
      const {
        GraphQLEnumType,
        GraphQLInputObjectType,
        GraphQLObjectType,
        GraphQLScalarType,
        GraphQLDirective,
        GraphQLUnionType,
      } = graphql;
      const { typeDefs, resolvers = {} } =
        typeof generator === "function"
          ? generator(build, schemaOptions)
          : generator;
      if (!(typeDefs as any) || (typeDefs as any).kind !== "Document") {
        throw new Error(
          "The first argument to makeExtendSchemaPlugin must be generated by the `gql` helper"
        );
      }
      const typeExtensions: TypeExtensions = {
        GraphQLSchema: {
          directives: [] as Array<any>,
          types: [] as Array<any>,
        },
        GraphQLInputObjectType: {},
        GraphQLObjectType: {},
      };
      const newTypes: Array<NewTypeDef> = [];
      typeDefs.definitions.forEach(definition => {
        if (definition.kind === "EnumTypeDefinition") {
          newTypes.push({
            type: GraphQLEnumType,
            definition,
          });
        } else if (definition.kind === "ObjectTypeExtension") {
          const name = getName(definition.name);
          if (!typeExtensions.GraphQLObjectType[name]) {
            typeExtensions.GraphQLObjectType[name] = [];
          }
          typeExtensions.GraphQLObjectType[name].push(definition);
        } else if (definition.kind === "InputObjectTypeExtension") {
          const name = getName(definition.name);
          if (!typeExtensions.GraphQLInputObjectType[name]) {
            typeExtensions.GraphQLInputObjectType[name] = [];
          }
          typeExtensions.GraphQLInputObjectType[name].push(definition);
        } else if (definition.kind === "ObjectTypeDefinition") {
          newTypes.push({
            type: GraphQLObjectType,
            definition,
          });
        } else if (definition.kind === "InputObjectTypeDefinition") {
          newTypes.push({
            type: GraphQLInputObjectType,
            definition,
          });
        } else if (definition.kind === "UnionTypeDefinition") {
          newTypes.push({
            type: GraphQLUnionType,
            definition,
          });
        } else if (definition.kind === "DirectiveDefinition") {
          newTypes.push({
            type: GraphQLDirective,
            definition,
          });
        } else if (definition.kind === "ScalarTypeDefinition") {
          // TODO: add validation
          const name = getName(definition.name);
          if (resolvers[name]) {
            const gqlScalarType = resolvers[name];
            if (!(gqlScalarType instanceof GraphQLScalarType)) {
              throw new Error(
                `Type for scalar '${name}' added via makeExtendSchemaPlugin is not a GraphQLScalarType`
              );
            }
            if (gqlScalarType.name !== name) {
              throw new Error(
                `Names for scalar type do not match; schema: '${name}' vs type: '${String(
                  gqlScalarType.name
                )}'`
              );
            }
            addType(
              gqlScalarType,
              "Scalar defined with makeExtendSchemaPlugin"
            );
          } else {
            // Create a string type
            newTypes.push({
              type: GraphQLScalarType,
              definition,
            });
          }
        } else {
          if ((definition.kind as any) === "TypeExtensionDefinition") {
            throw new Error(
              `You appear to be using a GraphQL version prior to v0.12.0 which has different syntax for schema extensions (e.g. 'TypeExtensionDefinition' instead of 'ObjectTypeExtension'). Sadly makeExtendSchemaPlugin does not support versions of graphql prior to 0.12.0, please update your version of graphql.`
            );
          }
          throw new Error(
            `Unexpected '${definition.kind}' definition; we were expecting 'GraphQLEnumType', 'ObjectTypeExtension', 'InputObjectTypeExtension', 'ObjectTypeDefinition' or 'InputObjectTypeDefinition', i.e. something like 'extend type Foo { ... }'`
          );
        }
      });
      return build.extend(
        build,
        {
          [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions,
          [`ExtendSchemaPlugin_${uniqueId}_newTypes`]: newTypes,
          [`ExtendSchemaPlugin_${uniqueId}_resolvers`]: resolvers,
        },
        "Adding makeExtendSchemaPlugin build extensions"
      );
    });

    builder.hook("init", (_, build, _context) => {
      const {
        newWithHooks,
        graphql: {
          GraphQLEnumType,
          GraphQLObjectType,
          GraphQLInputObjectType,
          GraphQLUnionType,
          GraphQLScalarType,
          GraphQLDirective,
          Kind,
        },
      } = build;
      const typeExtensions: TypeExtensions =
        build[`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]; // ONLY use this for GraphQLSchema in this hook
      const newTypes: NewTypeDef[] =
        build[`ExtendSchemaPlugin_${uniqueId}_newTypes`];
      const resolvers: Resolvers<any, any> =
        build[`ExtendSchemaPlugin_${uniqueId}_resolvers`];
      newTypes.forEach(({ type, definition }: NewTypeDef) => {
        if (type === GraphQLEnumType) {
          // https://graphql.org/graphql-js/type/#graphqlenumtype
          const name = getName(definition.name);
          const description = getDescription(definition.description);
          const directives = getDirectives(definition.directives);
          const relevantResolver = resolvers[name] || {};
          const values: import("graphql").GraphQLEnumValueConfigMap = definition.values.reduce(
            (
              memo: import("graphql").GraphQLEnumValueConfigMap,
              value: import("graphql").EnumValueDefinitionNode
            ) => {
              const valueName = getName(value.name);
              const valueDescription = getDescription(value.description);
              const valueDirectives = getDirectives(value.directives);

              // Value cannot be expressed via SDL, so we grab the value from the resolvers instead.
              // resolvers = {
              //   MyEnum: {
              //     MY_ENUM_VALUE1: 'value1',
              //     MY_ENUM_VALUE2: 'value2',
              //   }
              // }
              // Ref: https://github.com/graphql/graphql-js/issues/525#issuecomment-255834625
              const valueValue =
                relevantResolver[valueName] !== undefined
                  ? relevantResolver[valueName]
                  : valueName;

              const valueDeprecationReason =
                valueDirectives.deprecated && valueDirectives.deprecated.reason;
              return {
                ...memo,
                [valueName]: {
                  value: valueValue,
                  deprecationReason: valueDeprecationReason,
                  description: valueDescription,
                  directives: valueDirectives,
                },
              };
            },
            {}
          );
          const scope: ScopeGraphQLEnumType = {
            directives,
            ...(directives.scope || {}),
          };
          newWithHooks(type, { name, values, description }, scope);
        } else if (type === GraphQLObjectType) {
          // https://graphql.org/graphql-js/type/#graphqlobjecttype
          const name = getName(definition.name);
          const description = getDescription(definition.description);
          const interfaces = getInterfaces(definition.interfaces, build);
          const directives = getDirectives(definition.directives);
          const scope: ScopeGraphQLObjectType = {
            __origin: `makeExtendSchemaPlugin`,
            directives,
            ...(directives.scope || {}),
          };
          const spec: GraphileObjectTypeConfig<any, any> = {
            name,
            interfaces,
            fields: (fieldsContext: ContextGraphQLObjectTypeFields) =>
              getFields(
                fieldsContext.Self,
                definition.fields,
                resolvers,
                fieldsContext,
                build
              ),
            ...(description
              ? {
                  description,
                }
              : null),
          };
          newWithHooks(type, spec, scope);
        } else if (type === GraphQLInputObjectType) {
          // https://graphql.org/graphql-js/type/#graphqlinputobjecttype
          const name = getName(definition.name);
          const description = getDescription(definition.description);
          const directives = getDirectives(definition.directives);
          const scope = {
            __origin: `makeExtendSchemaPlugin`,
            directives,
            ...(directives.scope || {}),
          };
          newWithHooks(
            type,
            {
              name,
              fields: ({ Self }: ContextGraphQLInputObjectTypeFields) =>
                getInputFields(Self, definition.fields, build),
              ...(description
                ? {
                    description,
                  }
                : null),
            },
            scope
          );
        } else if (type === GraphQLUnionType) {
          // https://graphql.org/graphql-js/type/#graphqluniontype
          const name = getName(definition.name);
          const description = getDescription(definition.description);
          const directives = getDirectives(definition.directives);
          const scope: ScopeGraphQLUnionType = {
            __origin: `makeExtendSchemaPlugin`,
            directives,
            ...(directives.scope || {}),
          };
          const resolver = resolvers[name] as UnionResolver | undefined;
          const resolveType = resolver && resolver.__resolveType;
          const spec: GraphileUnionTypeConfig<any, any> = {
            name,
            types: (): import("graphql").GraphQLObjectType[] => {
              if (Array.isArray(definition.types)) {
                return definition.types.map(
                  (typeAST: any): import("graphql").GraphQLObjectType => {
                    if (typeAST.kind !== "NamedType") {
                      throw new Error("Only support unions of named types");
                    }
                    const type = getType(typeAST, build);
                    if (!type || !(type instanceof GraphQLObjectType)) {
                      throw new Error(`Invalid type '${type}' for union`);
                    }
                    return type;
                  }
                );
              }
              return [];
            },
            ...(resolveType ? { resolveType } : null),
            ...(description ? { description } : null),
          };
          newWithHooks(type, spec, scope);
        } else if (type === GraphQLScalarType) {
          const name = getName(definition.name);
          const description = getDescription(definition.description);
          const directives = getDirectives(definition.directives);
          const scope = {
            __origin: `makeExtendSchemaPlugin`,
            directives,
            ...(directives.scope || {}),
          };
          newWithHooks(
            type,
            {
              name,
              description,
              serialize: (value: any) => String(value),
              parseValue: (value: any) => String(value),
              parseLiteral: (ast: any) => {
                if (ast.kind !== Kind.STRING) {
                  throw new Error("Can only parse string values");
                }
                return ast.value;
              },
            },
            scope
          );
        } else if (type === GraphQLDirective) {
          // https://github.com/graphql/graphql-js/blob/3c54315ab13c6b9d337fb7c33ad7e27b92ca4a40/src/type/directives.js#L106-L113
          const name = getName(definition.name);
          const description = getDescription(definition.description);
          const locations = definition.locations.map(getName);
          const args = getArguments(definition.arguments, build);
          // Ignoring isRepeatable and astNode for now
          const directive = new GraphQLDirective({
            name,
            locations,
            args,
            ...(description ? { description } : null),
          });
          typeExtensions.GraphQLSchema.directives.push(directive);
        } else {
          throw new Error(
            `We have no code to build an object of type '${type}'; it should not have reached this area of the code.`
          );
        }
      });
      return _;
    });

    builder.hook("GraphQLSchema", (schema, build, _context) => {
      const typeExtensions: TypeExtensions =
        build[`ExtendSchemaPlugin_${uniqueId}_typeExtensions`];
      return {
        ...schema,
        directives: [
          ...(schema.directives || build.graphql.specifiedDirectives || []),
          ...typeExtensions.GraphQLSchema.directives,
        ],
        types: [...(schema.types || []), ...typeExtensions.GraphQLSchema.types],
      };
    });

    builder.hook("GraphQLObjectType:fields", (fields, build, context: any) => {
      const { extend } = build;

      const typeExtensions: TypeExtensions =
        build[`ExtendSchemaPlugin_${uniqueId}_typeExtensions`];
      const resolvers: Resolvers<any, any> =
        build[`ExtendSchemaPlugin_${uniqueId}_resolvers`];

      const { Self } = context;
      if (typeExtensions.GraphQLObjectType[Self.name]) {
        const newFields = typeExtensions.GraphQLObjectType[Self.name].reduce(
          (
            memo: import("graphql").GraphQLFieldConfigMap<any, any>,
            extension: import("graphql").ObjectTypeExtensionNode
          ) => {
            const moreFields = getFields(
              Self,
              extension.fields,
              resolvers,
              context,
              build
            );
            return extend(
              memo,
              moreFields,
              "Building fields in makeExtendSchemaPlugin"
            );
          },
          {}
        );
        return extend(
          fields,
          newFields,
          "Adding fields from makeExtendSchemaPlugin"
        );
      } else {
        return fields;
      }
    });

    builder.hook("GraphQLInputObjectType:fields", (fields, build, context) => {
      const { extend } = build;
      const typeExtensions: TypeExtensions =
        build[`ExtendSchemaPlugin_${uniqueId}_typeExtensions`];
      const { Self } = context;
      if (typeExtensions.GraphQLInputObjectType[Self.name]) {
        const newFields = typeExtensions.GraphQLInputObjectType[
          Self.name
        ].reduce(
          (
            memo: import("graphql").GraphQLInputFieldConfigMap,
            extension: InputObjectTypeExtensionNode
          ) => {
            const moreFields = getInputFields(Self, extension.fields, build);
            return extend(
              memo,
              moreFields,
              "Making input fields in makeExtendSchemaPlugin"
            );
          },
          {}
        );
        return extend(
          fields,
          newFields,
          "Adding input fields in makeExtendSchemaPlugin"
        );
      } else {
        return fields;
      }
    });
  };

  function getName(name: import("graphql").NameNode) {
    if (name && name.kind === "Name" && name.value) {
      return name.value;
    }
    throw new Error("Could not extract name from AST");
  }

  function getDescription(desc: import("graphql").StringValueNode | void) {
    if (!desc) {
      return null;
    } else if (desc.kind === "StringValue") {
      return desc.value;
    } else {
      throw new Error(
        `AST issue, we weren't expecting a description of kind '${desc.kind}' - PRs welcome!`
      );
    }
  }

  function getType(
    type: import("graphql").TypeNode,
    build: Build
  ): import("graphql").GraphQLType {
    if (type.kind === "NamedType") {
      const Type = build.getTypeByName(getName(type.name));
      if (!Type) {
        throw new Error(`Could not find type named '${getName(type.name)}'.`);
      }
      return Type;
    } else if (type.kind === "NonNullType") {
      return new build.graphql.GraphQLNonNull(getType(type.type, build));
    } else if (type.kind === "ListType") {
      return new build.graphql.GraphQLList(getType(type.type, build));
    } else {
      throw new Error(
        `We don't support AST type definition of kind '${
          (type as any).kind
        }' yet... PRs welcome!`
      );
    }
  }

  function getInterfaces(
    interfaces: ReadonlyArray<import("graphql").NamedTypeNode>,
    _build: Build
  ) {
    if (interfaces.length) {
      throw new Error(
        `We don't support interfaces via makeExtendSchemaPlugin yet; PRs welcome!`
      );
    }
    return [];
  }

  function getValue(
    value: import("graphql").ValueNode | GraphileEmbed,
    inType?: import("graphql").GraphQLType | null
  ):
    | boolean
    | string
    | number
    | null
    | Array<boolean | string | number | null>
    | any {
    const type =
      inType && graphql.isNonNullType(inType) ? inType.ofType : inType;
    if (value.kind === "BooleanValue") {
      return !!value.value;
    } else if (value.kind === "StringValue") {
      return value.value;
    } else if (value.kind === "IntValue") {
      return parseInt(value.value, 10);
    } else if (value.kind === "FloatValue") {
      return parseFloat(value.value);
    } else if (value.kind === "EnumValue") {
      if (!type) {
        throw new Error(
          "We do not support EnumValue arguments in directives at this time"
        );
      }
      const enumValueName = value.value;
      const enumType:
        | import("graphql").GraphQLEnumType
        | null = graphql.isEnumType(type) ? type : null;
      if (!enumType) {
        throw new Error(
          `Tried to interpret an EnumValue for non-enum type ${type}`
        );
      }

      const values = enumType.getValues();
      const enumValue = values.find(v => v.name === enumValueName);
      return enumValue ? enumValue.value : undefined;
    } else if (value.kind === "NullValue") {
      return null;
    } else if (value.kind === "ListValue") {
      // This is used in directives, so we cannot assume the type is known.
      const childType:
        | import("graphql").GraphQLList<import("graphql").GraphQLType>
        | null = type && graphql.isListType(type) ? type.ofType : null;
      return value.values.map(value => getValue(value, childType));
    } else if (value.kind === "GraphileEmbed") {
      // RAW!
      return value.value;
    } else {
      throw new Error(
        `Value kind '${value.kind}' not supported yet. PRs welcome!`
      );
    }
  }

  function getDirectives(
    directives: ReadonlyArray<import("graphql").DirectiveNode> | void
  ): DirectiveMap {
    return (directives || []).reduce((directivesList, directive) => {
      if (directive.kind === "Directive") {
        const name = getName(directive.name);
        const value = (directive.arguments || []).reduce(
          (argumentValues, arg) => {
            if (arg.kind === "Argument") {
              const argName = getName(arg.name);
              const argValue = getValue(arg.value);
              if (argumentValues[name]) {
                throw new Error(
                  `Argument '${argName}' of directive '${name}' must only be used once.`
                );
              }
              argumentValues[argName] = argValue;
            } else {
              throw new Error(
                `Unexpected '${arg.kind}', we were expecting 'Argument'`
              );
            }
            return argumentValues;
          },
          {}
        );
        if (directivesList[name]) {
          throw new Error(
            `Directive '${name}' must only be used once per field.`
          );
        }
        directivesList[name] = value;
      } else {
        throw new Error(
          `Unexpected '${directive.kind}', we were expecting 'Directive'`
        );
      }
      return directivesList;
    }, {});
  }

  function getArguments(
    args: ReadonlyArray<import("graphql").InputValueDefinitionNode> | void,
    build: Build
  ): import("graphql").GraphQLFieldConfigArgumentMap {
    if (args && args.length) {
      return args.reduce(
        (memo, arg) => {
          if (arg.kind === "InputValueDefinition") {
            const name = getName(arg.name);
            const type = getType(arg.type, build);
            const description = getDescription(arg.description);
            let defaultValue;
            if (arg.defaultValue) {
              defaultValue = getValue(arg.defaultValue, type);
            }
            if (!build.graphql.isInputType(type)) {
              throw new Error(`Expected input type, but found '${type}'`);
            }
            memo[name] = {
              type,
              ...(defaultValue != null ? { defaultValue } : null),
              ...(description ? { description } : null),
            };
          } else {
            throw new Error(
              `Unexpected '${arg.kind}', we were expecting an 'InputValueDefinition'`
            );
          }
          return memo;
        },
        {} as import("graphql").GraphQLFieldConfigArgumentMap
      );
    }
    return {};
  }

  function getFields<TSource>(
    SelfGeneric: TSource,
    fields: ReadonlyArray<import("graphql").FieldDefinitionNode> | void,
    resolvers: Resolvers,
    {
      fieldWithHooks,
    }: {
      fieldWithHooks: any;
    },
    build: Build
  ) {
    const scopeByType = build.scopeByType || new Map();
    if (!build.graphql.isNamedType(SelfGeneric)) {
      throw new Error("getFields only supports named types");
    }
    const Self: import("graphql").GraphQLNamedType = SelfGeneric as any;
    const {
      pgSql: sql,
      graphql: { isScalarType, getNamedType },
    } = build;
    function augmentResolver(
      resolver: AugmentedGraphQLFieldResolver<TSource, any>,
      fieldContext: ContextGraphQLObjectTypeFieldsField,
      type: import("graphql").GraphQLOutputType
    ) {
      let got = false;
      let val: any;
      const getRecurseDataGeneratorsWorkaroundField = () => {
        if (!got) {
          got = true;
          const namedType = build.graphql.getNamedType(type);
          val = recurseDataGeneratorsWorkaroundFieldByType.get(namedType);
        }
        return val;
      };
      const newResolver: import("graphql").GraphQLFieldResolver<
        TSource,
        any
      > = async (parent, args, context, resolveInfo) => {
        const graphileHelpers: GraphileHelpers = makeFieldHelpers(
          build,
          fieldContext,
          context,
          resolveInfo
        );
        const result = await resolver(
          parent,
          args,
          context,
          {
            ...resolveInfo,
            graphile: graphileHelpers,
          },
          graphileHelpers
        );
        const recurseDataGeneratorsWorkaroundField = getRecurseDataGeneratorsWorkaroundField();
        if (
          result != null &&
          !result.data &&
          recurseDataGeneratorsWorkaroundField
        ) {
          return {
            ...result,
            data: result[recurseDataGeneratorsWorkaroundField],
          };
        }
        return result;
      };
      return newResolver;
    }
    if (fields && fields.length) {
      return fields.reduce((memo, field) => {
        if (field.kind === "FieldDefinition") {
          const description = getDescription(field.description);
          const fieldName = getName(field.name);
          const args = getArguments(field.arguments, build);
          const type = getType(field.type, build);
          const nullableType = build.graphql.getNullableType(type);
          const namedType = build.graphql.getNamedType(type);
          const typeScope = (scopeByType.get(namedType) || {}) as Partial<
            ScopeGraphQLObjectType
          >;
          const directives = getDirectives(field.directives);
          const scope: Omit<ScopeGraphQLObjectTypeFieldsField, "fieldName"> = {
            ...(typeScope.pgIntrospection &&
            typeScope.pgIntrospection.kind === "class"
              ? {
                  pgFieldIntrospection: typeScope.pgIntrospection,
                }
              : null),
            ...(typeScope.isPgRowConnectionType && typeScope.pgIntrospection
              ? {
                  isPgFieldConnection: true,
                  pgFieldIntrospection: typeScope.pgIntrospection,
                }
              : null),
            fieldDirectives: directives,
            ...(directives.scope || {}),
          };
          const deprecationReason =
            directives.deprecated && directives.deprecated.reason;
          const functionToResolveObject = <TContext>(
            functionOrResolveObject:
              | AugmentedGraphQLFieldResolver<TSource, TContext>
              | ObjectFieldResolver<TSource, TContext>
          ): ObjectFieldResolver<TSource, TContext> =>
            typeof functionOrResolveObject === "function"
              ? { resolve: functionOrResolveObject }
              : functionOrResolveObject;
          const isConnection = !!scope.isPgFieldConnection;
          const isListType =
            nullableType !== namedType &&
            nullableType.constructor === build.graphql.GraphQLList;
          const table: PgClass | null =
            scope.pgFieldIntrospection &&
            scope.pgFieldIntrospection.kind === "class"
              ? scope.pgFieldIntrospection
              : null;
          const isScalar = isScalarType(getNamedType(type));

          const generateImplicitResolverIfPossible = () => {
            if (
              directives.pgQuery &&
              ((table && directives.pgQuery.source) ||
                (isScalar && directives.pgQuery.fragment))
            ) {
              return (
                data: any,
                _args: any,
                _resolveContext: any,
                resolveInfo: any
              ) => {
                const safeAlias = build.getSafeAliasFromResolveInfo(
                  resolveInfo
                );
                const liveRecord =
                  resolveInfo.rootValue && resolveInfo.rootValue.liveRecord;
                if (isConnection) {
                  return build.pgAddStartEndCursor(data[safeAlias]);
                } else if (isListType) {
                  const records = data[safeAlias];
                  if (table && liveRecord) {
                    records.forEach(
                      (r: any) => r && liveRecord("pg", table, r.__identifiers)
                    );
                  }
                  return records;
                } else {
                  const record = data[safeAlias];
                  if (record && liveRecord && table) {
                    liveRecord("pg", table, record.__identifiers);
                  }
                  return record;
                }
              };
            }
            return null;
          };
          /*
           * We accept a resolver function directly, or an object which can
           * define 'resolve', 'subscribe' and other relevant methods.
           */
          const possibleResolver = resolvers[Self.name]
            ? resolvers[Self.name][fieldName]
            : null;
          const resolver =
            possibleResolver &&
            (typeof possibleResolver === "object" ||
              typeof possibleResolver === "function")
              ? possibleResolver
              : generateImplicitResolverIfPossible();
          const rawResolversSpec = resolver
            ? functionToResolveObject(resolver)
            : null;
          if (directives.recurseDataGenerators) {
            if (!recurseDataGeneratorsWorkaroundFieldByType.get(Self)) {
              recurseDataGeneratorsWorkaroundFieldByType.set(Self, fieldName);
            }
            // eslint-disable-next-line no-console
            console.warn(
              "DEPRECATION: `recurseDataGenerators` is misleading, please use `pgField` instead"
            );
            if (!directives.pgField) {
              directives.pgField = directives.recurseDataGenerators;
            }
          }
          const fieldSpecGenerator = (
            fieldContext: ContextGraphQLObjectTypeFieldsField
          ): {
            type: import("graphql").GraphQLOutputType;
            args?: {};
            deprecationReason?: string;
            descroption?: string;
          } => {
            const { pgIntrospection } = fieldContext.scope;
            // @requires directive: pulls down necessary columns from table.
            //
            //   e.g. `@requires(columns: ["id", "name"])`
            //
            if (
              directives.requires &&
              pgIntrospection &&
              pgIntrospection.kind === PgEntityKind.CLASS
            ) {
              const table: PgClass = pgIntrospection;
              if (Array.isArray(directives.requires.columns)) {
                const attrs = table.attributes.filter(
                  attr => directives.requires.columns.indexOf(attr.name) >= 0
                );
                const fieldNames = attrs.map(attr =>
                  build.inflection.column(attr)
                );
                const ReturnTypes = attrs.map(
                  attr =>
                    build.pgGetGqlTypeByTypeIdAndModifier(
                      attr.typeId,
                      attr.typeModifier
                    ) || build.graphql.GraphQLString
                );
                fieldContext.addDataGenerator(
                  (parsedResolveInfoFragment: any) => ({
                    pgQuery: (queryBuilder: QueryBuilder) => {
                      attrs.forEach((attr, i) => {
                        const columnFieldName = fieldNames[i];
                        const ReturnType = ReturnTypes[i];
                        queryBuilder.select(
                          build.pgGetSelectValueForFieldAndTypeAndModifier(
                            ReturnType,
                            fieldContext,
                            parsedResolveInfoFragment,
                            sql.fragment`(${queryBuilder.getTableAlias()}.${sql.identifier(
                              attr.name
                            )})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING
                            attr.type,
                            attr.typeModifier,
                            queryBuilder
                          ),
                          columnFieldName
                        );
                      });
                    },
                  })
                );
              } else {
                throw new Error(
                  `@requires(columns: ["...", ...]) directive called with invalid arguments`
                );
              }
            }
            if (directives.pgQuery) {
              if (table && directives.pgQuery.source) {
                fieldContext.addDataGenerator(
                  (parsedResolveInfoFragment: any) => {
                    return {
                      pgQuery: (queryBuilder: QueryBuilder) => {
                        const source =
                          typeof directives.pgQuery.source === "function"
                            ? directives.pgQuery.source(
                                queryBuilder,
                                parsedResolveInfoFragment.args
                              )
                            : directives.pgQuery.source;
                        queryBuilder.select(() => {
                          const resolveData = fieldContext.getDataFromParsedResolveInfoFragment(
                            parsedResolveInfoFragment,
                            namedType as import("graphql").GraphQLOutputType
                          );
                          const tableAlias = sql.identifier(Symbol());
                          const query = build.pgQueryFromResolveData(
                            source,
                            tableAlias,
                            resolveData,
                            {
                              withPagination: isConnection,
                              withPaginationAsFields: false,
                              asJsonAggregate: isListType && !isConnection,
                              asJson: !isConnection,
                              addNullCase: !isConnection,
                            },
                            (innerQueryBuilder: QueryBuilder) => {
                              innerQueryBuilder.parentQueryBuilder = queryBuilder;
                              if (
                                build.options.subscriptions &&
                                table.primaryKeyConstraint
                              ) {
                                innerQueryBuilder.selectIdentifiers(table);
                              }
                              if (
                                typeof directives.pgQuery.withQueryBuilder ===
                                "function"
                              ) {
                                directives.pgQuery.withQueryBuilder(
                                  innerQueryBuilder,
                                  parsedResolveInfoFragment.args
                                );
                              }
                            },
                            queryBuilder.context,
                            queryBuilder.rootValue
                          );
                          return sql.fragment`(${query})`;
                        }, build.getSafeAliasFromAlias(parsedResolveInfoFragment.alias));
                      },
                    };
                  }
                );
              } else if (isScalar && directives.pgQuery.fragment) {
                fieldContext.addDataGenerator(
                  (parsedResolveInfoFragment: any) => {
                    return {
                      pgQuery: (queryBuilder: QueryBuilder) => {
                        queryBuilder.select(
                          typeof directives.pgQuery.fragment === "function"
                            ? directives.pgQuery.fragment(
                                queryBuilder,
                                parsedResolveInfoFragment.args
                              )
                            : directives.pgQuery.fragment,
                          build.getSafeAliasFromAlias(
                            parsedResolveInfoFragment.alias
                          )
                        );
                      },
                    };
                  }
                );
              } else {
                throw new Error(
                  `@pgQuery(...) directive called with invalid arguments - for a table value, call it with 'source' for a scalar with 'fragment'!`
                );
              }
            }

            const resolversSpec = rawResolversSpec
              ? Object.keys(rawResolversSpec).reduce(
                  (newResolversSpec, key) => {
                    if (typeof rawResolversSpec[key] === "function") {
                      newResolversSpec[key] = augmentResolver(
                        rawResolversSpec[key],
                        fieldContext,
                        type as import("graphql").GraphQLOutputType
                      );
                    }
                    return newResolversSpec;
                  },
                  {}
                )
              : {};
            return {
              type: type as import("graphql").GraphQLOutputType,
              args,
              ...(deprecationReason
                ? {
                    deprecationReason,
                  }
                : null),
              ...(description
                ? {
                    description,
                  }
                : null),
              ...resolversSpec,
            };
          };
          if (directives.pgField) {
            return build.extend(
              memo,
              {
                [fieldName]: build.pgField(
                  build,
                  fieldWithHooks,
                  fieldName,
                  fieldSpecGenerator,
                  scope,
                  false
                ),
              },
              `Defining @pgField directive field '${fieldName}'`
            );
          } else {
            return build.extend(
              memo,
              {
                [fieldName]: fieldWithHooks(
                  fieldName,
                  fieldSpecGenerator,
                  scope
                ),
              },
              `Defining a new field '${fieldName}' in makeExtendSchemaPlugin`
            );
          }
        } else {
          throw new Error(
            `AST issue: expected 'FieldDefinition', instead received '${field.kind}'`
          );
        }
      }, {});
    }
    return {};
  }

  function getInputFields<TSource>(
    _Self: TSource,
    fields: ReadonlyArray<import("graphql").InputValueDefinitionNode> | void,
    build: Build
  ) {
    if (fields && fields.length) {
      return fields.reduce((memo, field) => {
        if (field.kind === "InputValueDefinition") {
          const description = getDescription(field.description);
          const fieldName = getName(field.name);
          const type = getType(field.type, build);
          const defaultValue = field.defaultValue
            ? getValue(field.defaultValue, type)
            : undefined;
          memo[fieldName] = {
            type,
            defaultValue,
            ...(description
              ? {
                  description,
                }
              : null),
          };
        } else {
          throw new Error(
            `AST issue: expected 'FieldDefinition', instead received '${field.kind}'`
          );
        }
        return memo;
      }, {});
    }
    return {};
  }
}
