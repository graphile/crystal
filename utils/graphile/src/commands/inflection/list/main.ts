import { readFile, stat } from "node:fs/promises";
import path from "node:path";

import chalk from "chalk";
import type { CompletionEntry } from "typescript";

import type { ResolvedDefinition } from "../../../utils/typescriptVfs.js";
import {
  accessKey,
  configVfs,
  prettyDocumentation,
  prettyQuickInfoDisplayParts,
  tightDisplayParts,
  tightDocumentation,
} from "../../../utils/typescriptVfs.js";

export async function main(options: { filename?: string; quiet?: boolean }) {
  const { filename, quiet } = options;
  const { getCompletions, getDefinitions, getQuickInfo } = configVfs({
    filename,
    initialCode: `\
const inflection: GraphileBuild.Inflection = null as any;
inflection`,
  });

  let outputText = ``;
  let last = "";
  let inCode = false;
  function out(text = ""): void {
    if (text === "" && last === "" && !inCode) {
      return;
    }
    let exitCode = false;
    if (!inCode && text.startsWith("```")) {
      inCode = true;
    } else if (text.startsWith("```")) {
      exitCode = true;
    }
    outputText += (inCode ? chalk.green(text) : text) + "\n";
    last = text;
    if (exitCode) {
      inCode = false;
    }
  }
  if (!quiet) {
    out(
      chalk.whiteBright.bold(`# Custom \`GraphileBuild.Inflection\` Reference`),
    );
    out();
    out(`\
This reference was autogenerated by \`graphile inflection list\` using your
local configuration file to determine the inflectors that are available based
on the plugins and presets you use. You should regenerate it from time to time
(for example, when you upgrade a module, or add/remove modules).`);
    out();
  }

  const completions = [...(getCompletions(".")?.entries ?? [])];
  completions.sort((a, z) => a.name.localeCompare(z.name, "en-US"));

  let later: Array<string | undefined> = [];
  function outLater(str?: string): void {
    later.push(str);
  }
  const entries: string[] = [];
  const INDENT = 2;
  async function processEntry(entry: CompletionEntry) {
    const key = entry.name;
    const withProperty = accessKey(key);
    const info = getQuickInfo(withProperty);
    const definitions = getDefinitions(withProperty);
    //entries.push(
    //  `${chalk.cyanBright(key)}${prettyQuickInfoDisplayParts(info)};`,
    //);
    const doc = tightDocumentation(info, 80 - INDENT - 7);
    entries.push(
      `${
        quiet || !doc ? "" : chalk.gray(`/** ${doc} */\n`)
      }${chalk.cyanBright(key)}${tightDisplayParts(
        info,
        80 - INDENT - key.length,
      )}`,
    );
    const defs = await Promise.all(definitions.map(formatPathWithPackage));
    return { key, entry, info, defs };
  }

  type Deets = Awaited<ReturnType<typeof processEntry>>;

  function outputEntry(deets: Deets) {
    const { key, info, defs } = deets;
    const messages: (string | undefined)[] = [];
    function outLater(message?: string) {
      messages.push(message);
    }
    outLater(chalk.whiteBright.bold(`## ${chalk.cyanBright.bold(key)}`));
    outLater();
    if (defs.length) {
      if (defs.length === 1) {
        outLater(chalk.gray(`Defined in: ${formatPackage(defs[0])}`));
      } else {
        outLater(chalk.gray(`Defined in:`));
        for (const def of defs) {
          outLater(chalk.gray(`- ${formatPackage(def)}`));
        }
      }
      outLater();
    }
    outLater(prettyDocumentation(info?.documentation));
    outLater();
    outLater("```ts");
    outLater(key + prettyQuickInfoDisplayParts(info));
    outLater("```");
    outLater();
    return messages;
  }

  const completionResults = await Promise.all(completions.map(processEntry));
  for (const deets of completionResults) {
    const messages = outputEntry(deets);
    for (const message of messages) {
      outLater(message);
    }
  }

  if (entries.length) {
    out("```ts");
    out(chalk.cyanBright(`interface GraphileBuild.Inflection`) + ` {`);
    for (const entry of entries) {
      out("  " + entry.replace(/\n/g, "\n  "));
    }
    out("}");
    out("```");
    out();
  }
  for (const line of later) {
    out(line);
  }
  later = [];
  return outputText.trim() + "\n";
}

/**
 * Given a file path, walk up directories looking for package.json.
 * If found, return "package-name:relative/path/from/package/root".
 * Otherwise return the original relative path.
 */
export async function formatPathWithPackage(definition: ResolvedDefinition) {
  const filePath = definition.fileName;
  let currentDir = path.dirname(path.resolve(process.cwd(), filePath));

  for (let depth = 0; depth < 15; depth++) {
    const pkgPath = path.join(currentDir, "package.json");
    try {
      const packageJSON = JSON.parse(await readFile(pkgPath, "utf8"));
      if (packageJSON.name) {
        return {
          packageName: packageJSON.name,
          path: path.relative(currentDir, filePath),
          definition,
        };
      }
    } catch {
      // Ignore
    }
    const parent = path.dirname(currentDir);
    if (parent === currentDir) {
      break;
    } else {
      currentDir = parent;
    }
  }
  return {
    packageName: null,
    path: path.relative(process.cwd(), filePath),
    definition,
  };
}

const DIRS: Record<string, string> = {
  "graphile-build": "graphile-build/graphile-build",
  "graphile-build-pg": "graphile-build/graphile-build-pg",
  postgraphile: "postgraphile/postgraphile",
};

interface Deets {
  packageName: string | null;
  path: string;
  definition: {
    line: number;
    column: number;
  };
}

function formatPackage(deets: Deets) {
  const {
    packageName,
    path,
    definition: { line, column },
  } = deets;
  if (packageName === null) return `${path}:${line}:${column}`;
  const subdir = DIRS[packageName];
  if (subdir) {
    return `[${packageName}:${path}:${line}:${column}](https://github.com/graphile/crystal/blob/main/${subdir}/${path}#L${line})`;
  } else {
    return `${packageName}:${path}:${line}:${column}`;
  }
}
