import { readFile } from "node:fs/promises";
import path from "node:path";

import chalk from "chalk";
import type { InflectorSource } from "graphile-build";
import { buildInflection } from "graphile-build";
import { resolvePreset } from "graphile-config";
import { loadConfig } from "graphile-config/load";
import type { CompletionEntry } from "typescript";

import type { ResolvedDefinition } from "../../../utils/typescriptVfs.js";
import {
  accessKey,
  configVfs,
  prettyDocumentation,
  prettyQuickInfoDisplayParts,
  tightDisplayParts,
  tightDocumentation,
} from "../../../utils/typescriptVfs.js";

export async function main(options: { filename?: string; quiet?: boolean }) {
  const { filename, quiet } = options;

  // Create inflection so we can determine where the inflectors came from
  const preset = await loadConfig(filename);
  const resolvedPreset = resolvePreset(preset ?? {});
  const trace = new Map<string, InflectorSource[]>();
  const inflection = buildInflection(resolvedPreset, trace);

  const { getCompletions, getDefinitions, getQuickInfo } = configVfs({
    filename,
    initialCode: `\
const inflection: GraphileBuild.Inflection = null as any;
inflection`,
  });

  let outputText = ``;
  let last = "";
  let inCode = false;
  function out(text = ""): void {
    if (text === "" && last === "" && !inCode) {
      return;
    }
    let exitCode = false;
    if (!inCode && text.startsWith("```")) {
      inCode = true;
    } else if (text.startsWith("```")) {
      exitCode = true;
    }
    outputText += (inCode ? chalk.green(text) : text) + "\n";
    last = text;
    if (exitCode) {
      inCode = false;
    }
  }
  if (!quiet) {
    out(
      chalk.whiteBright.bold(`# Custom \`GraphileBuild.Inflection\` Reference`),
    );
    out();
    out(`\
This reference was autogenerated by \`graphile inflection list\` using your
local configuration file to determine the inflectors that are available based
on the plugins and presets you use. You should regenerate it from time to time
(for example, when you upgrade a module, or add/remove modules).`);
    out();
  }

  const completions = [...(getCompletions(".")?.entries ?? [])];
  completions.sort((a, z) => a.name.localeCompare(z.name, "en-US"));

  let later: Array<string | undefined> = [];
  function outLater(str?: string): void {
    later.push(str);
  }
  const entries: string[] = [];
  const INDENT = 2;
  async function processEntry(entry: CompletionEntry) {
    const key = entry.name;
    const withProperty = accessKey(key);
    const info = getQuickInfo(withProperty);
    const definitions = getDefinitions(withProperty);
    //entries.push(
    //  `${chalk.cyanBright(key)}${prettyQuickInfoDisplayParts(info)};`,
    //);
    const doc = tightDocumentation(info, 80 - INDENT - 7);
    entries.push(
      `${
        quiet || !doc ? "" : chalk.gray(`/** ${doc} */\n`)
      }${chalk.cyanBright(key)}${tightDisplayParts(
        info,
        80 - INDENT - key.length,
      )}`,
    );
    const defs = await Promise.all(definitions.map(formatPathWithPackage));
    return { key, entry, info, defs };
  }

  const completionResults = await Promise.all(completions.map(processEntry));

  const allKeys = Object.keys(inflection);
  for (const r of completionResults) {
    if (!allKeys.includes(r.key)) {
      allKeys.push(r.key);
    }
  }

  // TODO: give option to not sort
  allKeys.sort();

  for (const key of allKeys) {
    const sources = trace.get(key);
    const deets = completionResults.find((r) => r.key === key);
    outLater(chalk.whiteBright.bold(`## ${chalk.cyanBright.bold(key)}`));
    outLater();
    if (sources) {
      for (let i = 0, l = sources.length; i < l; i++) {
        const source = sources[i];
        if (i === 0) {
          if (source.pluginName === "") {
            outLater(chalk.gray(`Builtin inflector.`));
          } else {
            outLater(chalk.gray(`Added by ${source.pluginName}.`));
          }
        } else {
          if (i === 1) {
            outLater();
            outLater(chalk.gray(`Overridden by:`));
            outLater();
          }
          outLater(chalk.gray(`- ${source.pluginName}`));
        }
      }
      outLater();
    }
    if (deets) {
      const { info, defs } = deets;
      if (defs.length === 1) {
        outLater(chalk.gray(`Declared in: ${formatPackage(defs[0])}`));
      } else {
        outLater(chalk.gray(`Declared in:`));
        for (const def of defs) {
          outLater(chalk.gray(`- ${formatPackage(def)}`));
        }
      }
      outLater();
      outLater(prettyDocumentation(info?.documentation));
      outLater();
      outLater("```ts");
      outLater(key + prettyQuickInfoDisplayParts(info));
      outLater("```");
    } else {
      outLater(
        chalk.red(`Could not find TypeScript definition of this inflector!`),
      );
    }
    outLater();
  }

  if (entries.length) {
    out("```ts");
    out(chalk.cyanBright(`interface GraphileBuild.Inflection`) + ` {`);
    for (const entry of entries) {
      out("  " + entry.replace(/\n/g, "\n  "));
    }
    out("}");
    out("```");
    out();
  }
  for (const line of later) {
    out(line);
  }
  later = [];
  return outputText.trim() + "\n";
}

/**
 * Given a file path, walk up directories looking for package.json.
 * If found, return "package-name:relative/path/from/package/root".
 * Otherwise return the original relative path.
 */
export async function formatPathWithPackage(definition: ResolvedDefinition) {
  const filePath = definition.fileName;
  let currentDir = path.dirname(path.resolve(process.cwd(), filePath));

  for (let depth = 0; depth < 15; depth++) {
    const pkgPath = path.join(currentDir, "package.json");
    try {
      const packageJSON = JSON.parse(await readFile(pkgPath, "utf8"));
      if (packageJSON.name) {
        return {
          packageName: packageJSON.name,
          path: path.relative(currentDir, filePath),
          definition,
        };
      }
    } catch {
      // Ignore
    }
    const parent = path.dirname(currentDir);
    if (parent === currentDir) {
      break;
    } else {
      currentDir = parent;
    }
  }
  return {
    packageName: null,
    path: path.relative(process.cwd(), filePath),
    definition,
  };
}

const DIRS: Record<string, string> = {
  "graphile-build": "graphile-build/graphile-build",
  "graphile-build-pg": "graphile-build/graphile-build-pg",
  postgraphile: "postgraphile/postgraphile",
};

interface Deets {
  packageName: string | null;
  path: string;
  definition: {
    line: number;
    column: number;
  };
}

function formatPackage(deets: Deets) {
  const {
    packageName,
    path,
    definition: { line, column },
  } = deets;
  if (packageName === null) return `${path}:${line}:${column}`;
  const subdir = DIRS[packageName];
  if (subdir) {
    return `[${packageName}:${path}:${line}:${column}](https://github.com/graphile/crystal/blob/main/${subdir}/${path}#L${line})`;
  } else {
    return `${packageName}:${path}:${line}:${column}`;
  }
}
