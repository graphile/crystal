import chalk from "chalk";
import type { JSDocTagInfo, QuickInfo, SymbolDisplayPart } from "typescript";

import {
  accessKey,
  configVfs,
  prettyDisplayParts,
  prettyDocumentation,
} from "../../../utils/typescriptVfs.js";

const FORBIDDEN = [
  // PostGraphile V4 workarounds
  "appendPlugins",
  "prependPlugins",
  "skipPlugins",
];

export function main(options: { filename?: string; scope?: string }) {
  const { filename, scope } = options;
  const { getCompletions, getQuickInfo } = configVfs({
    filename,
    initialCode: `const preset: GraphileConfig.Preset`,
  });

  let outputText = ``;
  let last = "";
  let inCode = false;
  function out(text = ""): void {
    if (text === "" && last === "" && !inCode) {
      return;
    }
    let exitCode = false;
    if (!inCode && text.startsWith("```")) {
      inCode = true;
    } else if (text.startsWith("```")) {
      exitCode = true;
    }
    outputText += (inCode ? chalk.green(text) : text) + "\n";
    last = text;
    if (exitCode) {
      inCode = false;
    }
  }
  if (!scope) {
    out(chalk.whiteBright.bold(`# Custom \`GraphileConfig.Preset\` Reference`));
    out();
    out(`\
This reference was autogenerated by \`graphile config options\` using
your local configuration file to determine the plugins and presets (and
hence the configuration options) available. You should regenerate it
from time to time (for example, when you upgrade a module, or add/remove
modules).\
`);
    out();
  }

  /*
  {
    const content = BASE_CONTENT;
    env.updateFile(FAKE_FILENAME, content);
    const info = env.languageService.getQuickInfoAtPosition(
      FAKE_FILENAME,
      content.length,
    );
    //out(prettyDocumentation(info?.documentation));
    //out();
  const content2 =
    BASE_CONTENT + `;\ntype Config = Digest<GraphileConfig.Preset>;`;
  env.updateFile(FAKE_FILENAME, content2);
  const info2 = env.languageService.getQuickInfoAtPosition(
    FAKE_FILENAME,
    content.length + 8,
  );

  out("```ts");
  //console.dir(info2);
  out(prettyDisplayParts(info2?.displayParts, "="));
  out("```");
  out();
  }
  */

  const keys: string[] = [];
  if (scope) {
    keys.push(scope);
  } else {
    const completions = getCompletions(" = {");
    if (completions?.entries) {
      for (const entry of completions.entries) {
        if (entry.kind === "property") {
          if (!FORBIDDEN.includes(entry.name)) {
            keys.push(entry.name);
          }
        } else {
          console.error(
            `Did not understand '${entry.kind}' entry on GraphileConfig.Preset`,
          );
        }
      }
    }
    //console.dir(completions);
    keys.sort();
    ["extends", "plugins", "disablePlugins"].reverse().forEach((key) => {
      const i = keys.indexOf(key);
      if (i >= 0) {
        keys.splice(i, 1);
      }
      keys.unshift(key);
    });
  }

  let later: Array<string | undefined> = [];
  function outLater(str?: string): void {
    later.push(str);
  }
  const entries: string[] = [];
  for (const key of keys) {
    // Always an object, unless...
    const isArray = [
      "disablePlugins",
      "plugins",
      "extends",
      "pgServices",
    ].includes(key);

    if (isArray) {
      const info = getQuickInfo(` = [];\npreset${accessKey(key)}`);
      entries.push(
        `${chalk.cyanBright(key)}?: ${prettyDisplayParts(
          info?.displayParts,
          ":",
        )
          .replace(/\| undefined$/, "")
          .trim()}`,
      );
    } else {
      const SUFFIX1 = ` = {`;
      const SUFFIX2 = `};\n`;
      const withProperty = ` = Object.create(null);\npreset${accessKey(
        key,
      )}${SUFFIX1}${SUFFIX2}`;
      const info = getQuickInfo(withProperty, SUFFIX1.length + SUFFIX2.length);
      entries.push(
        `${chalk.cyanBright(key)}?: ${prettyDisplayParts(
          info?.displayParts,
          ":",
        )};`,
      );

      const completions = getCompletions(withProperty, SUFFIX2.length);
      const relevant = completions?.entries
        .filter((e) => e.kind === "property")
        .map((r) => r.name)
        .sort();
      if (!scope) {
        outLater(chalk.whiteBright.bold(`## ${chalk.cyanBright.bold(key)}`));
        outLater();
        outLater(prettyDocumentation(info?.documentation));
      }
      outLater();

      if (relevant) {
        const subentries: string[] = [];
        const advancedSubentries: string[] = [];
        const deprecatedSubentries: string[] = [];
        let normal: Array<string | undefined> = [];
        let advanced: Array<string | undefined> = [];
        let deprecated: Array<string | undefined> = [];
        for (const subkey of relevant) {
          const withSubpropertyAccess =
            withProperty + `preset${accessKey(key)}!${accessKey(subkey)}`;
          const info = getQuickInfo(withSubpropertyAccess);

          const tags = getTags(info);
          const advancedTag = tags.get("advanced");
          const deprecatedTag = tags.get("deprecated");
          const experimentalTag = tags.get("experimental");
          const defaultValueTag = tags.get("defaultValue");

          const isDeprecated = !!deprecatedTag;
          const isAdvanced = !!advancedTag;
          const outLaterStill = (line?: string): void => {
            let target = normal;
            if (isDeprecated) {
              target = deprecated;
              if (target.length === 0) {
                target.push("### Deprecated");
                target.push("");
                target.push("These settings should no longer be used.");
              }
            } else if (isAdvanced) {
              target = advanced;
              if (target.length === 0) {
                target.push("### Advanced");
                target.push("");
                target.push(
                  "Only use these settings if you know what you are doing!",
                );
              }
            }
            target.push(line);
          };
          (isDeprecated
            ? deprecatedSubentries
            : isAdvanced
              ? advancedSubentries
              : subentries
          ).push(
            `${chalk.greenBright.bold(subkey)}?: ${prettyDisplayParts(
              info?.displayParts,
              ":",
            )
              .replace(/\| undefined$/, "")
              .trim()};`,
          );
          /*
          const def = env.languageService.getDefinitionAtPosition(
            FAKE_FILENAME,
            contentWithSubpropertyAccess.length,
          );
          const hints = env.languageService.provideInlayHints(
            FAKE_FILENAME,
            ts.createTextSpan(
              contentWithProperty.length,
              contentWithSubpropertyAccess.length - contentWithProperty.length,
            ),
            undefined,
          );
          const com = env.languageService.getDocCommentTemplateAtPosition(
            FAKE_FILENAME,
            contentWithProperty.length,
          );
          console.log(key, subkey, info, def, hints, com);
          */
          outLaterStill(
            chalk.whiteBright(
              `${isAdvanced ? "####" : "###"} ${chalk.cyanBright.bold(key)}.${chalk.greenBright.bold(
                subkey,
              )}`,
            ),
          );
          outLaterStill();
          if (deprecatedTag) {
            outLaterStill(":::warning Deprecated");
            outLaterStill();
            if (deprecatedTag.text) {
              outLaterStill(prettyDisplayParts(deprecatedTag.text));
              outLaterStill();
            }
            outLaterStill(":::");
            outLaterStill();
          }
          if (experimentalTag) {
            outLaterStill(":::danger Experimental");
            outLaterStill();
            outLaterStill(
              prettyDisplayParts(experimentalTag.text) ??
                "This feature may change or be removed in a patch release.",
            );
            outLaterStill();
            outLaterStill(":::");
            outLaterStill();
          }
          if (advancedTag) {
            outLaterStill(":::warning Advanced");
            outLaterStill();
            if (advancedTag?.text) {
              outLaterStill(prettyDisplayParts(advancedTag.text));
              outLaterStill();
            }
            outLaterStill(":::");
            outLaterStill();
          }
          const displayParts = prettyDisplayParts(info?.displayParts, ":");
          outLaterStill(
            `${chalk.greenBright.bold("Type")}: \`${
              displayParts
                ? chalk.whiteBright(displayParts)
                : chalk.gray("unknown")
            }\``,
          );
          if (defaultValueTag?.text) {
            outLaterStill(
              `${chalk.greenBright.bold("Default value")}: ${prettyDisplayParts(
                defaultValueTag.text,
                "",
              )}`,
            );
          }
          outLaterStill();
          outLaterStill(prettyDocumentation(info?.documentation));
          outLaterStill();
        }

        if (
          subentries.length ||
          advancedSubentries.length ||
          deprecatedSubentries.length
        ) {
          outLater("```ts");
          outLater(`{`);
          for (const entry of subentries) {
            outLater("  " + entry);
          }
          if (subentries.length && advancedSubentries.length) {
            outLater("");
            outLater("  // Advanced");
          }
          for (const entry of advancedSubentries) {
            outLater("  " + entry);
          }
          if (
            (subentries.length || advancedSubentries.length) &&
            deprecatedSubentries.length
          ) {
            outLater("");
            outLater("  // Deprecated");
          }
          for (const entry of deprecatedSubentries) {
            outLater("  " + entry);
          }
          outLater("}");
          outLater("```");
          outLater();
        }
        for (const line of normal) {
          outLater(line);
        }
        for (const line of advanced) {
          outLater(line);
        }
        for (const line of deprecated) {
          outLater(line);
        }
        normal = [];
        advanced = [];
        deprecated = [];
      }
    }
    /*
  if (completions?.entries) {
    for (const entry of completions.entries) {
      if (entry.kind === "property") {
        keys.push(entry.name);
      }
    }
  }
*/
  }

  if (!scope && entries.length) {
    out("```ts");
    out(`{`);
    for (const entry of entries) {
      out("  " + entry);
    }
    out("}");
    out("```");
    out();
  }
  for (const line of later) {
    out(line);
  }
  later = [];
  return outputText.trim() + "\n";
}

function getTags(info: QuickInfo | undefined) {
  const tags = new Map<string, JSDocTagInfo>();
  if (!info?.tags) return tags;
  for (const tag of info.tags) {
    const existing = tags.get(tag.name);
    if (existing != null && tag.text != null) {
      if (!existing.text) {
        // Overwrite
        tags.set(tag.name, tag);
      } else {
        // Merge
        tags.set(tag.name, {
          ...existing,
          text: [...existing.text, ...tag.text],
        });
      }
    } else {
      tags.set(tag.name, tag);
    }
  }
  return tags;
}
