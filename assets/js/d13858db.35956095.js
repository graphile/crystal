"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[6446],{36702:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(48084),i=n(2784);a.o.initialize({startOnLoad:!0,flowchart:{diagramPadding:8,nodeSpacing:20,rankSpacing:40,htmlLabels:!0}});const s=e=>{let{chart:t}=e;return(0,i.useEffect)((()=>{a.o.contentLoaded()}),[]),i.createElement("div",{className:"mermaid"},t)}},67766:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>c});var a=n(7896),i=(n(2784),n(30876)),s=n(36702);const r='%%{init: {\'themeVariables\': { \'fontSize\': \'12px\'}}}%%\nflowchart TD\n    classDef path fill:#eee,stroke:#000,color:#000\n    classDef plan fill:#fff,stroke-width:1px,color:#000\n    classDef itemplan fill:#fff,stroke-width:2px,color:#000\n    classDef unbatchedplan fill:#dff,stroke-width:1px,color:#000\n    classDef sideeffectplan fill:#fcc,stroke-width:2px,color:#000\n    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left\n\n\n    %% plan dependencies\n    Access7{{"Access[7‚àà0]<br />·ê∏3.currentUserId·ê≥"}}:::plan\n    __Value3["__Value[3‚àà0]<br />·ê∏context·ê≥"]:::plan\n    __Value3 --\x3e Access7\n    Load8[["Load[8‚àà0]<br />·ê∏userById·ê≥"]]:::plan\n    Access7 --\x3e Load8\n    Load11[["Load[11‚àà0]<br />·ê∏friendshipsByUserId·ê≥"]]:::plan\n    Access7 --\x3e Load11\n    __Value0["__Value[0‚àà0]"]:::plan\n    __Value5["__Value[5‚àà0]<br />·ê∏rootValue·ê≥"]:::plan\n    __Item15[/"__Item[15‚àà3]<br />·ê∏11·ê≥"\\]:::itemplan\n    Load11 ==> __Item15\n    Access17{{"Access[17‚àà3]<br />·ê∏15.friend_id·ê≥"}}:::plan\n    __Item15 --\x3e Access17\n    Load18[["Load[18‚àà3]<br />·ê∏userById·ê≥"]]:::plan\n    Access17 --\x3e Load18\n\n    %% define steps\n\n    classDef bucket0 stroke:#696969\n    class Bucket0,__Value0,__Value3,__Value5,Access7,Load8,Load11 bucket0\n    classDef bucket1 stroke:#00bfff\n    class Bucket1 bucket1\n    classDef bucket3 stroke:#ffa500\n    class Bucket3,__Item15,Access17,Load18 bucket3\n    classDef bucket4 stroke:#0000ff\n    class Bucket4 bucket4',o={sidebar_position:1,title:"Grafast Introduction",toc_max_heading_level:4},l="<grafast /> introduction",p={unversionedId:"index",id:"index",title:"Grafast Introduction",description:"This introduction to Grafast assumes that you have a basic understanding of",source:"@site/grafast/index.mdx",sourceDirName:".",slug:"/",permalink:"/grafast/",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/index.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Grafast Introduction",toc_max_heading_level:4},sidebar:"tutorialSidebar",next:{title:"Getting started",permalink:"/grafast/getting-started/"}},u={},c=[{value:"Plan resolvers",id:"plan-resolvers",level:2},{value:"Steps",id:"steps",level:2},{value:"Batched execution",id:"batched-execution",level:3},{value:"Unary steps",id:"unary-steps",level:4},{value:"SQL example",id:"sql-example",level:4},{value:"Step lifecycle",id:"step-lifecycle",level:3},{value:"Deduplicate",id:"deduplicate",level:3},{value:"Optimize",id:"optimize",level:3},{value:"Finalize",id:"finalize",level:3},{value:"Further optimizations",id:"further-optimizations",level:2},{value:"Convinced?",id:"convinced",level:2}],h={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"-introduction"},(0,i.kt)("grafast",null)," introduction"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This introduction to Grafast assumes that you have a basic understanding of\nGraphQL, including the concept of resolvers. We highly recommend that you read\n",(0,i.kt)("a",{parentName:"p",href:"https://graphql.org/learn/"},"Introduction to GraphQL"),", and in particular\n",(0,i.kt)("a",{parentName:"p",href:"https://graphql.org/learn/execution/"},"GraphQL Execution"),", before reading this\ndocument.")),(0,i.kt)("p",null,'The GraphQL specification describes how a GraphQL operation should be executed,\ntalking in terms of layer‚Äìby‚Äìlayer resolution of data using "resolvers." But\ncritical to note is this sentence from the beginning of the specification:'),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("em",{parentName:"p"},"Conformance requirements ","[...]"," can be fulfilled ","[...]"," in any way as long as\nthe perceived result is equivalent."),(0,i.kt)("br",{parentName:"p"}),"\n","‚îÄ ",(0,i.kt)("a",{parentName:"p",href:"https://spec.graphql.org/draft/#sec-Conforming-Algorithms"},"https://spec.graphql.org/draft/#sec-Conforming-Algorithms"))),(0,i.kt)("p",null,"Resolvers are relatively straightforward to understand, but when implemented\nnaively can very quickly result in serious performance issues. ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/graphql/dataloader"},"DataLoader"),' is\none of the approaches suggested to solve the "N+1 problem," but this is only the\nmost egregious performance issue that a naive GraphQL schema may face ‚Äî there\nare others such as server‚Äìside over‚Äìfetching and under‚Äìfetching and related\nissues that can really build up as your schemas and operations get more complex.'),(0,i.kt)("p",null,"‚Äã",(0,i.kt)("grafast",null)," was designed from the ground up to eliminate these issues and more\nwhilst maintaining pleasant APIs for developers to use. To do this, in addition\nto supporting resolvers for legacy fields, ",(0,i.kt)("grafast",null)," favors a planning\nstrategy that takes a holistic approach to understanding the incoming operation,\nand unlocks the potential for significant optimizations not previously\nachievable without a herculean effort."),(0,i.kt)("p",null,"Please note that ",(0,i.kt)("grafast",null)," is not tied to any particular storage or business\nlogic layer ‚Äî any valid GraphQL schema could be implemented with ",(0,i.kt)("grafast",null),",\nand a ",(0,i.kt)("grafast",null)," schema can query any data source, service, or business logic\nthat Node.js can query."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Currently ",(0,i.kt)("grafast",null)," is implemented in TypeScript, but we're working on a\nspecification with hopes to extend ",(0,i.kt)("grafast",null),"'s execution approach to other\nprogramming languages. If you're interested in implementing ",(0,i.kt)("grafast",null),"'s\nexecution algorithm in a language other than JavaScript, please get in touch!")),(0,i.kt)("h2",{id:"plan-resolvers"},"Plan resolvers"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"This is just an overview, for full documentation see\n",(0,i.kt)("a",{parentName:"em",href:"./plan-resolvers"},"Plan Resolvers"),".")),(0,i.kt)("p",null,"In a traditional GraphQL schema each field has a resolver. In a ",(0,i.kt)("grafast",null),"\nschema, though resolvers are still supported, you are encouraged to instead use\n",(0,i.kt)("a",{parentName:"p",href:"/grafast/plan-resolvers"},(0,i.kt)("strong",{parentName:"a"},"plan","¬†","resolvers")),". These plan resolvers are\ngenerally small functions, like regular resolvers should be, but instead of\nbeing called many times during execution and dealing with concrete runtime\nvalues, they are called only once at planning time and they build and\nmanipulate ",(0,i.kt)("strong",{parentName:"p"},"steps")," which are the building blocks of an ",(0,i.kt)("a",{parentName:"p",href:"/grafast/operation-plan#execution-plan"},(0,i.kt)("strong",{parentName:"a"},"execution\nplan"))," which details all the actions\nnecessary to satisfy the GraphQL request."),(0,i.kt)("p",null,"Imagine that we have this GraphQL schema:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  currentUser: User\n}\ntype User {\n  name: String!\n  friends: [User!]!\n}\n")),(0,i.kt)("p",null,"In ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-js"},"graphql-js"),", you might have these resolvers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const resolvers = {\n  Query: {\n    async currentUser(_, args, context) {\n      return context.userLoader.load(context.currentUserId);\n    },\n  },\n  User: {\n    name(user) {\n      return user.full_name;\n    },\n    async friends(user, args, context) {\n      const friendships = await context.friendshipsByUserIdLoader.load(user.id);\n      const friends = await Promise.all(\n        friendships.map((friendship) =>\n          context.userLoader.load(friendship.friend_id),\n        ),\n      );\n      return friends;\n    },\n  },\n};\n")),(0,i.kt)("p",null,"In ",(0,i.kt)("grafast",null),", we use ",(0,i.kt)("a",{parentName:"p",href:"/grafast/plan-resolvers"},(0,i.kt)("strong",{parentName:"a"},"plan resolvers"))," instead,\nwhich might look something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const planResolvers = {\n  Query: {\n    currentUser() {\n      return userById(context().get("currentUserId"));\n    },\n  },\n  User: {\n    name($user) {\n      return $user.get("full_name");\n    },\n    friends($user) {\n      const $friendships = friendshipsByUserId($user.get("id"));\n      const $friends = each($friendships, ($friendship) =>\n        userById($friendship.get("friend_id")),\n      );\n      return $friends;\n    },\n  },\n};\n')),(0,i.kt)("p",null,"As you can see, the shape of the logic is quite similar, but the ",(0,i.kt)("grafast",null),"\nplan resolvers are synchronous. ",(0,i.kt)("grafast",null)," operates in two phases: planning\n(synchronous) and execution (asynchronous); plan resolvers are called during\nthe planning phase."),(0,i.kt)("admonition",{title:"See the working example",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you want to explore the two code blocks above, and see them in context\nincluding their dependencies, please see the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/graphile/crystal/tree/main/grafast/website/examples/users-and-friends"},'"users and friends"\nexample'),".")),(0,i.kt)("p",null,"The job of a plan resolver is not to retrieve data, it's to detail the\n",(0,i.kt)("strong",{parentName:"p"},"steps")," necessary to retrieve it. Plan resolvers do not have access to any\nruntime data, they must describe what to do for arbitrary future data. For\nexample, the ",(0,i.kt)("inlineCode",{parentName:"p"},"User.friends")," Gra",(0,i.kt)("em",{parentName:"p"},"fast")," plan resolver cannot loop through the\nruntime data with a ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," function as in the resolver example (since there is\nnot yet any data to loop over), instead it describes the plan to do so using an\n",(0,i.kt)("a",{parentName:"p",href:"/grafast/step-library/standard-steps/each"},(0,i.kt)("inlineCode",{parentName:"a"},"each")," step"),", detailing what to do\nwith each item made available later."),(0,i.kt)("admonition",{title:"The dollar convention",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"By convention, when a variable represents a ",(0,i.kt)("grafast",null)," step, the variable will\nbe named starting with a ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," (dollar symbol).")),(0,i.kt)("h2",{id:"steps"},"Steps"),(0,i.kt)("p",null,"Steps are the basic building blocks of a ",(0,i.kt)("grafast",null)," plan; they are instances\nof a step class, constructed via the function calls in the plan resolver. Step\nclasses describe how to perform a specific action and help plan how to perform\nthe action more efficiently via the ",(0,i.kt)("strong",{parentName:"p"},"lifecycle methods"),". ",(0,i.kt)("grafast",null)," provides\noptimized built‚Äìin steps for common needs; it's common that you can get started\nusing just these, but as you go about optimizing your schema further it's\nexpected that you will build your own step classes, in the same way that you'd\nbuild DataLoaders in a resolver‚Äìbased GraphQL API."),(0,i.kt)("p",null,"If we were to make a request to the above ",(0,i.kt)("grafast",null)," schema with the following\nquery:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  currentUser {\n    name\n    friends {\n      name\n    }\n  }\n}\n")),(0,i.kt)("p",null,"‚Äã",(0,i.kt)("grafast",null)," would build an ",(0,i.kt)("a",{parentName:"p",href:"/grafast/operation-plan"},(0,i.kt)("strong",{parentName:"a"},"operation\nplan"))," for the operation. For the above query, a\n",(0,i.kt)("a",{parentName:"p",href:"/grafast/plan-diagrams"},(0,i.kt)("strong",{parentName:"a"},"plan diagram"))," representing the execution portion\nof this operation plan is:"),(0,i.kt)(s.Z,{chart:r,mdxType:"Mermaid"}),(0,i.kt)("p",null,"Each node in this diagram represents a ",(0,i.kt)("strong",{parentName:"p"},"step")," in the operation plan, and the\narrows show how the data flows between these steps."),(0,i.kt)("admonition",{title:"Plans can be reused for multiple requests",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"When the same operation is seen again its existing plan can (generally) be\nreused; this is why, to get the very best performance from ",(0,i.kt)("grafast",null),", you\nshould use static GraphQL documents and pass variables at run‚Äìtime.")),(0,i.kt)("h3",{id:"batched-execution"},"Batched execution"),(0,i.kt)("p",null,"The main concern of most steps is execution. In ",(0,i.kt)("grafast",null)," all execution is\nbatched, so each of the nodes in the operation plan will execute at most once\nduring a GraphQL query or mutation. This is one of the major differences when\ncompared to traditional GraphQL execution; with traditional resolvers\nprocessing happens in a layer‚Äìby‚Äìlayer, item‚Äìby‚Äìitem approach, requiring\nworkarounds such as ",(0,i.kt)("inlineCode",{parentName:"p"},"DataLoader")," to help reduce instances of the N+1 problem."),(0,i.kt)("p",null,"When it comes time to execute an operation plan, ",(0,i.kt)("grafast",null)," will automatically\npopulate the steps whose names begin with ",(0,i.kt)("inlineCode",{parentName:"p"},"__")," (e.g. the context and variable\nvalues) and then will begin the process of executing each step\nonce all of its dependencies are ready, continuing until all steps are\ncomplete."),(0,i.kt)("p",null,"At planning time a step can add a dependency on another step via ",(0,i.kt)("inlineCode",{parentName:"p"},"const depId =\nthis.addDependency($otherStep);"),". This ",(0,i.kt)("inlineCode",{parentName:"p"},"depId")," is the index in the ",(0,i.kt)("strong",{parentName:"p"},"values\ntuple")," that the step can use at execution time to retrieve the associated\nvalues."),(0,i.kt)("p",null,"When a step executes, its ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," method is passed the ",(0,i.kt)("strong",{parentName:"p"},"execution\ndetails")," which includes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"count")," ‚Äî the size of the batch to be executed"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"values")," ‚Äî the ",(0,i.kt)("strong",{parentName:"li"},"values tuple"),", the values for each of the dependencies the\nstep added"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"indexMap(callback)")," ‚Äî method returning an array by calling ",(0,i.kt)("inlineCode",{parentName:"li"},"callback(i)")," for\neach index ",(0,i.kt)("inlineCode",{parentName:"li"},"i")," in the batch (from ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"count-1"),")")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," method must return a list (or a promise to a list) of length\n",(0,i.kt)("inlineCode",{parentName:"p"},"count"),", where each entry in this list relates to the corresponding entries in\n",(0,i.kt)("inlineCode",{parentName:"p"},"values")," ‚Äî this should be at least a little familiar to anyone who has written\na DataLoader before."),(0,i.kt)("p",null,"When a plan starts executing it always starts with a batch size (",(0,i.kt)("inlineCode",{parentName:"p"},"count"),") of 1;\nbut many things may affect this batch size for later steps ‚Äî for example when\nprocessing the items in a list, the batch must grow to contain each item (via\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"__Item")," step). ",(0,i.kt)("grafast",null)," handles all of these complexities for you\ninternally, so you don't generally need to think about them."),(0,i.kt)("h4",{id:"unary-steps"},"Unary steps"),(0,i.kt)("p",null,'A "unary step" is a regular step which the system has determined will always\nrepresent exactly one value. The system steps which represent request‚Äìlevel\ndata (e.g. context, variable and argument values) are always unary steps, and\n',"‚Äã",(0,i.kt)("grafast",null)," will automatically determine which other steps are also unary\nsteps."),(0,i.kt)("p",null,"Sometimes you'll want to ensure that one or more of the steps your step class\ndepends on will have exactly one value at runtime; to do so, you can use\n",(0,i.kt)("inlineCode",{parentName:"p"},"this.addUnaryDependency($step)")," rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"this.addDependency($step)"),".\nThis\nensures that the given dependency will always be a unary step, and is primarily\nuseful when a parameter to a remote service request needs to be the same for\nall entries in the batch; typically this will be the case for ordering,\npagination and access control. For example if you're retrieving the first N\npets from each of your friends you might want to add ",(0,i.kt)("inlineCode",{parentName:"p"},"limit N")," to an SQL query\n‚Äî by adding the N as a unary dependency you can guarantee that there will be\nexactly one value of N for each execution, and can construct the SQL query\naccordingly (see ",(0,i.kt)("inlineCode",{parentName:"p"},"limitSQL")," in the example below)."),(0,i.kt)("h4",{id:"sql-example"},"SQL example"),(0,i.kt)("p",null,"Here's a step class which retrieves records matching a given column (i.e.\n",(0,i.kt)("inlineCode",{parentName:"p"},"WHERE columnName = $columnValue"),") from a given table in an SQL database.\nOptionally, you may request to limit to the first ",(0,i.kt)("inlineCode",{parentName:"p"},"$first")," results."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'export class RecordsByColumnStep extends ExecutableStep {\n  constructor(tableName, columnName, $columnValue) {\n    super();\n    this.tableName = tableName;\n    this.columnName = columnName;\n    this.columnValueDepIdx = this.addDependency($columnValue);\n  }\n\n  setFirst($first) {\n    this.firstDepId = this.addUnaryDependency($first);\n  }\n\n  async execute({ indexMap, values }) {\n    // Retrieve the values for the `$columnValue` dependency\n    const columnValueDep = values[this.columnValueDepIdx];\n\n    // We may or may not have added a `$first` limit:\n    const firstDep =\n      this.firstDepId !== undefined ? values[this.firstDepId] : undefined;\n\n    // firstDep, if it exists, is definitely a unary dep (!firstDep.isBatch), so\n    // we can retrieve its value directly:\n    const first = firstDep ? parseInt(firstDep.value, 10) : null;\n\n    // Create a `LIMIT` clause in our SQL if the user specified a `$first` limit:\n    const limitSQL = Number.isFinite(first) ? `limit ${first}` : ``;\n\n    // Create placeholders for each entry in our batch in the SQL:\n    const placeholders = indexMap(() => "?");\n    // The value from `$columnValue` for each index `i` in the batch\n    const columnValues = indexMap((i) => columnValueDep.at(i));\n\n    // Build the SQL query to execute:\n    const sql = `\\\n      select *\n      from ${this.tableName}\n      where ${this.columnName} in (${placeholders.join(", ")})\n      ${limitSQL}\n    `;\n\n    // Execute the SQL query once for all values in the batch:\n    const rows = await executeSQL(sql, columnValues);\n\n    // Figure out which rows relate to which batched inputs:\n    return indexMap((i) =>\n      rows.filter((row) => row[this.columnName] === columnValues[i]),\n    );\n  }\n}\n\nfunction petsByOwnerId($ownerId) {\n  return new RecordsByColumnStep("pets", "owner_id", $ownerId);\n}\n')),(0,i.kt)("p",null,"Notice that there's only a single ",(0,i.kt)("inlineCode",{parentName:"p"},"await")," call in this step's execute method,\nand we already know the step is only executed once per request; compare\nthis single asynchronous action with the number of promises that would need\nto be created were you to use ",(0,i.kt)("inlineCode",{parentName:"p"},"DataLoader")," instead."),(0,i.kt)("admonition",{title:"Not just databases!",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," method is just JavaScript; it can\ntalk to absolutely any data source that Node.js itself can talk to. Though the\nexample shows SQL you could replace the ",(0,i.kt)("inlineCode",{parentName:"p"},"executeSQL()")," call with ",(0,i.kt)("inlineCode",{parentName:"p"},"fetch()")," or\nany other arbitrary JavaScript function to achieve your goals.")),(0,i.kt)("admonition",{title:"Simplified example",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The code above was written to be a simple example; though it works (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/graphile/crystal/blob/main/grafast/website/grafast/index.example.mjs"},"see full\nsolution using\nit"),"),\nit's not nearly as good as it could be ‚Äî for example it does not track the\ncolumns accessed so that only these columns are retrieved, nor does it use\nlifecycle methods to determine more optimal ways of executing."),(0,i.kt)("p",{parentName:"admonition"},"(Another thing: it passes the ",(0,i.kt)("inlineCode",{parentName:"p"},"tableName")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"columnName")," values directly into\nSQL ‚Äî it would be safer to use an ",(0,i.kt)("inlineCode",{parentName:"p"},"escapeIdentifier()")," call around these.)")),(0,i.kt)("h3",{id:"step-lifecycle"},"Step lifecycle"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/grafast/operation-plan#execution-plan"},(0,i.kt)("strong",{parentName:"a"},"execution plan"))," diagram you\nsaw above is the final form of the plan, there were many intermediate states\nthat it will have gone through in order to reach this most optimal form, made\npossible by ",(0,i.kt)("grafast",null),"'s lifecycle methods."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"For more information about understanding plan diagrams please see\n",(0,i.kt)("a",{parentName:"p",href:"/grafast/plan-diagrams"},"Plan Diagrams"),"."),(0,i.kt)("p",{parentName:"admonition"},"For a fully working implementation of the above schema, please see the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/graphile/crystal/tree/main/grafast/website/examples/users-and-friends"},'"users and friends" example'),".")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"This is just an overview, for full documentation see ",(0,i.kt)("a",{parentName:"em",href:"./step-classes#lifecycle-methods"},"lifecycle"),".")),(0,i.kt)("p",null,"All plan lifecycle methods are optional, and due to the always‚Äìbatched nature\nof ",(0,i.kt)("grafast",null),' plans you can get good performance without using any of them\n(performance generally on a par with reliable usage of DataLoader). However, if\nyou leverage lifecycle methods your performance can go from "good" to\n‚ú®',(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"amazing")),"üöÄ."),(0,i.kt)("p",null,"One of the great things about ",(0,i.kt)("grafast",null),"'s design is that you don't need to\nbuild these optimizations from the start; you can implement them at a later\nstage, making your schema faster without requiring changes to your business\nlogic ",(0,i.kt)("em",{parentName:"p"},"or")," your plan resolvers!"),(0,i.kt)("p",null,"As a very approximate overview:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"once a field is planned we ",(0,i.kt)("strong",{parentName:"li"},"deduplicate")," each new step"),(0,i.kt)("li",{parentName:"ul"},"once the execution plan is complete, we ",(0,i.kt)("strong",{parentName:"li"},"optimize")," each step"),(0,i.kt)("li",{parentName:"ul"},"finally, we ",(0,i.kt)("strong",{parentName:"li"},"finalize")," each step")),(0,i.kt)("h3",{id:"deduplicate"},"Deduplicate"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Deduplicate")," lets a step indicate which of its peers (defined by ",(0,i.kt)("grafast",null),") are equivalent to it. One of these peers can then, if possible, replace the\nnew step, thereby reducing the number of steps in the plan (and allowing more\noptimal code paths deeper in the plan tree)."),(0,i.kt)("h3",{id:"optimize"},"Optimize"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Optimize")," serves two purposes."),(0,i.kt)("p",null,'Purpose one is that optimize lets a step "talk" to its ancestors, typically to\ntell them about data that will be needed so that they may fetch it proactively.\nThis should not change the observed behavior of the ancestor (e.g. you should\nnot use it to apply filters to an ancestor ‚Äî this may contradict the GraphQL\nspecification!) but it can be used to ask the ancestor to fetch additional\ndata.'),(0,i.kt)("p",null,'The second purpose is that optimize can be used to replace the step being\noptimized with an alternative (presumably more‚Äìoptimal) step. This may result\nin multiple steps being dropped from the plan graph due to "tree shaking." This\nmight be used when the step has told an ancestor to fetch additional data and\nthe step can then replace itself with a simple "access" step. It can also be\nused to dispose of plan‚Äìonly steps that have meaning at planning time but have\nno execution‚Äìtime behaviors.'),(0,i.kt)("p",null,'In the "friends" example above, this was used to change the DataLoader‚Äìstyle\n',(0,i.kt)("inlineCode",{parentName:"p"},"select * from ...")," query to a more optimal ",(0,i.kt)("inlineCode",{parentName:"p"},"select id, full_name from ..."),"\nquery. In more advanced plans (for example those made available through\n",(0,i.kt)("a",{parentName:"p",href:"./step-library/dataplan-pg"},"@dataplan/pg"),'), optimize can go much further, for example inlining its data\nrequirements into a parent and replacing itself with a simple "remap keys"\nfunction.'),(0,i.kt)("h3",{id:"finalize"},"Finalize"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Finalize")," is the final method called on a step, it gives the step a chance to\ndo anything that it would generally only need to do once; for example a step\nthat issues a GraphQL query to a remote server might take this opportunity to\nbuild the GraphQL query string once. A step that converts a tuple into an\nobject might build an optimized function to do so."),(0,i.kt)("h2",{id:"further-optimizations"},"Further optimizations"),(0,i.kt)("p",null,"‚Äã",(0,i.kt)("grafast",null)," doesn't just help your schema to execute fewer and more efficient\nsteps, it also optimizes how your data is output once it has been determined.\nThis means that even without making a single change to your existing GraphQL\nschema (i.e. without adopting plans), running it though ",(0,i.kt)("grafast",null)," rather than\ngraphql-js should result in a modest speedup, especially if you need to output\nyour result as a string (e.g. over a network socket/HTTP)."),(0,i.kt)("h2",{id:"convinced"},"Convinced?"),(0,i.kt)("p",null,"If you're not convinced, please do reach out via the ",(0,i.kt)("a",{parentName:"p",href:"https://discord.gg/graphile"},"Graphile Discord")," with\nyour queries, we'd love to make improvements to both this page, and ",(0,i.kt)("grafast",null),"\nitself!"),(0,i.kt)("p",null,"If you are convinced, why not continue on with the navigation button below..."))}m.isMDXComponent=!0}}]);