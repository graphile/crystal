exports[`test prints a schema with Relay 1 style ids 1`] = `
"type CompoundKey implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  personId2: Int!
  personId1: Int!
  extra: Boolean

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId1: Person

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId2: Person
}

input CompoundKeyInput {
  personId2: Int!
  personId1: Int!
  extra: Boolean
}

input CompoundKeyPatch {
  personId2: Int
  personId1: Int
  extra: Boolean
}

# A connection to a list of \`CompoundKey\` values.
type CompoundKeysConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`CompoundKey\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`CompoundKey\` and cursor to aid in pagination.
  edges: [CompoundKeysEdge]

  # A list of \`CompoundKey\` objects.
  nodes: [CompoundKey!]
}

# A \`CompoundKey\` edge in the connection.
type CompoundKeysEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`CompoundKey\` at the end of the edge.
  node: CompoundKey!
}

# Methods to use when ordering \`CompoundKey\`.
enum CompoundKeysOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  PERSON_ID_2_ASC
  PERSON_ID_2_DESC
  PERSON_ID_1_ASC
  PERSON_ID_1_DESC
  EXTRA_ASC
  EXTRA_DESC
}

input CreateCompoundKeyInput {
  clientMutationId: String
  compoundKey: CompoundKeyInput!
}

type CreateCompoundKeyPayload {
  clientMutationId: String
  compoundKey: CompoundKey
  compoundKeyEdge(
    # The method to use when ordering \`CompoundKey\`.
    orderBy: CompoundKeysOrderBy = PRIMARY_KEY_ASC
  ): CompoundKeysEdge

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId1: Person

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId2: Person
  query: Query
}

input CreatePersonInput {
  clientMutationId: String
  person: PersonInput!
}

type CreatePersonPayload {
  clientMutationId: String
  person: Person
  personEdge(
    # The method to use when ordering \`Person\`.
    orderBy: PeopleOrderBy = PRIMARY_KEY_ASC
  ): PeopleEdge
  query: Query
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

input DeleteCompoundKeyByPersonId1AndPersonId2Input {
  clientMutationId: String
  personId1: Int!
  personId2: Int!
}

input DeleteCompoundKeyInput {
  clientMutationId: String
  id: ID!
}

type DeleteCompoundKeyPayload {
  clientMutationId: String
  compoundKey: CompoundKey
  deletedCompoundKeyId: ID

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId1: Person

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId2: Person
  query: Query
}

input DeletePersonByEmailInput {
  clientMutationId: String
  email: Email!
}

input DeletePersonByRowIdInput {
  clientMutationId: String
  rowId: Int!
}

input DeletePersonInput {
  clientMutationId: String
  id: ID!
}

type DeletePersonPayload {
  clientMutationId: String
  person: Person
  deletedPersonId: ID
  query: Query
}

scalar Email

input FloatRangeBoundInput {
  value: Float!
  inclusive: Boolean!
}

# range of numerics
input FloatRangeInput {
  start: FloatRangeBoundInput
  end: FloatRangeBoundInput
}

input IntSetMutationInput {
  clientMutationId: String
  x: Int
  y: Int
  z: Int
}

type IntSetMutationPayload {
  clientMutationId: String
  integers: [Int]
  query: Query
}

# A connection to a list of \`Int\` values.
type IntSetQueryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Int\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Int\` and cursor to aid in pagination.
  edges: [IntSetQueryEdge]

  # A list of \`Int\` objects.
  nodes: [Int]
}

# A \`Int\` edge in the connection.
type IntSetQueryEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Int\` at the end of the edge.
  node: Int
}

# Methods to use when ordering \`Int\`.
enum IntSetQueryOrderBy {
  NATURAL
}

# A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar Json

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  intSetMutation(input: IntSetMutationInput!): IntSetMutationPayload
  noArgsMutation(input: NoArgsMutationInput!): NoArgsMutationPayload
  tableMutation(input: TableMutationInput!): TableMutationPayload
  tableSetMutation(input: TableSetMutationInput!): TableSetMutationPayload
  typesMutation(input: TypesMutationInput!): TypesMutationPayload
  createCompoundKey(input: CreateCompoundKeyInput!): CreateCompoundKeyPayload
  updateCompoundKey(input: UpdateCompoundKeyInput!): UpdateCompoundKeyPayload
  updateCompoundKeyByPersonId1AndPersonId2(input: UpdateCompoundKeyByPersonId1AndPersonId2Input!): UpdateCompoundKeyPayload
  deleteCompoundKey(input: DeleteCompoundKeyInput!): DeleteCompoundKeyPayload
  deleteCompoundKeyByPersonId1AndPersonId2(input: DeleteCompoundKeyByPersonId1AndPersonId2Input!): DeleteCompoundKeyPayload
  createPerson(input: CreatePersonInput!): CreatePersonPayload
  updatePerson(input: UpdatePersonInput!): UpdatePersonPayload
  updatePersonByEmail(input: UpdatePersonByEmailInput!): UpdatePersonPayload
  updatePersonByRowId(input: UpdatePersonByRowIdInput!): UpdatePersonPayload
  deletePerson(input: DeletePersonInput!): DeletePersonPayload
  deletePersonByEmail(input: DeletePersonByEmailInput!): DeletePersonPayload
  deletePersonByRowId(input: DeletePersonByRowIdInput!): DeletePersonPayload
}

input NoArgsMutationInput {
  clientMutationId: String
}

type NoArgsMutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

# An object with a globally unique \`ID\`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# A connection to a list of \`Person\` values.
type PeopleConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Person\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Person\` and cursor to aid in pagination.
  edges: [PeopleEdge]

  # A list of \`Person\` objects.
  nodes: [Person!]
}

# A \`Person\` edge in the connection.
type PeopleEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Person\` at the end of the edge.
  node: Person!
}

# Methods to use when ordering \`Person\`.
enum PeopleOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ABOUT_ASC
  ABOUT_DESC
  EMAIL_ASC
  EMAIL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

# Person test comment
type Person implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  rowId: Int!

  # The person’s name
  name: String!
  about: String
  email: Email!
  createdAt: Datetime
  firstName: String

  # Reads and enables paginatation through a set of \`Person\`.
  friends(
    # The method to use when ordering \`Person\`.
    orderBy: PersonFriendsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): PersonFriendsConnection

  # Reads and enables paginatation through a set of \`CompoundKey\`.
  compoundKeysByPersonId1(
    # The method to use when ordering \`CompoundKey\`.
    orderBy: CompoundKeysOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): CompoundKeysConnection

  # Reads and enables paginatation through a set of \`CompoundKey\`.
  compoundKeysByPersonId2(
    # The method to use when ordering \`CompoundKey\`.
    orderBy: CompoundKeysOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): CompoundKeysConnection
}

# A connection to a list of \`Person\` values.
type PersonFriendsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Person\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Person\` and cursor to aid in pagination.
  edges: [PersonFriendsEdge]

  # A list of \`Person\` objects.
  nodes: [Person]
}

# A \`Person\` edge in the connection.
type PersonFriendsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Person\` at the end of the edge.
  node: Person
}

# Methods to use when ordering \`Person\`.
enum PersonFriendsOrderBy {
  NATURAL
}

# Person test comment
input PersonInput {
  rowId: Int

  # The person’s name
  name: String!
  about: String
  email: Email!
  createdAt: Datetime
}

input PersonPatch {
  rowId: Int
  name: String
  about: String
  email: Email
  createdAt: Datetime
}

type Post {
  id: Int!
  headline: String!
  body: String
  authorId: Int
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Fetches an object given its globally unique \`ID\`.
  node(
    # The globally unique \`ID\`.
    id: ID!
  ): Node

  # Reads and enables paginatation through a set of \`Int\`.
  intSetQuery(
    # The method to use when ordering \`Int\`.
    orderBy: IntSetQueryOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    x: Int
    y: Int
    z: Int
  ): IntSetQueryConnection
  jsonIdentity(json: Json): Json
  noArgsQuery: Int
  tableQuery(id: Int): Post

  # Reads and enables paginatation through a set of \`Person\`.
  tableSetQuery(
    # The method to use when ordering \`Person\`.
    orderBy: TableSetQueryOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): TableSetQueryConnection
  typesQuery(a: Int!, b: Boolean!, c: String!, d: [Int]!, e: Json!, f: FloatRangeInput!): Boolean

  # Reads and enables paginatation through a set of \`CompoundKey\`.
  allCompoundKeys(
    # The method to use when ordering \`CompoundKey\`.
    orderBy: CompoundKeysOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    personId2: Int
    personId1: Int
    extra: Boolean
  ): CompoundKeysConnection

  # Reads a single \`CompoundKey\` using its globally unique \`ID\`.
  compoundKey(
    # The globally unique \`ID\` to be used in selecting a single \`CompoundKey\`.
    id: ID!
  ): CompoundKey
  compoundKeyByPersonId1AndPersonId2(personId1: Int!, personId2: Int!): CompoundKey

  # Reads and enables paginatation through a set of \`Person\`.
  allPeople(
    # The method to use when ordering \`Person\`.
    orderBy: PeopleOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    rowId: Int
    name: String
    about: String
    email: Email
    createdAt: Datetime
  ): PeopleConnection

  # Reads a single \`Person\` using its globally unique \`ID\`.
  person(
    # The globally unique \`ID\` to be used in selecting a single \`Person\`.
    id: ID!
  ): Person
  personByEmail(email: Email!): Person
  personByRowId(rowId: Int!): Person

  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a \`Node\` to work well with Relay 1 mutations. This just resolves to \`query\`.
  id: ID!
}

input TableMutationInput {
  clientMutationId: String
  id: Int
}

type TableMutationPayload {
  clientMutationId: String
  post: Post
  query: Query
}

input TableSetMutationInput {
  clientMutationId: String
}

type TableSetMutationPayload {
  clientMutationId: String
  people: [Person]
  query: Query
}

# A connection to a list of \`Person\` values.
type TableSetQueryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Person\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Person\` and cursor to aid in pagination.
  edges: [TableSetQueryEdge]

  # A list of \`Person\` objects.
  nodes: [Person]
}

# A \`Person\` edge in the connection.
type TableSetQueryEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Person\` at the end of the edge.
  node: Person
}

# Methods to use when ordering \`Person\`.
enum TableSetQueryOrderBy {
  NATURAL
}

input TypesMutationInput {
  clientMutationId: String
  a: Int!
  b: Boolean!
  c: String!
  d: [Int]!
  e: Json!
  f: FloatRangeInput!
}

type TypesMutationPayload {
  clientMutationId: String
  boolean: Boolean
  query: Query
}

input UpdateCompoundKeyByPersonId1AndPersonId2Input {
  clientMutationId: String
  personId1: Int!
  personId2: Int!
  compoundKeyPatch: CompoundKeyPatch!
}

input UpdateCompoundKeyInput {
  clientMutationId: String
  id: ID!
  compoundKeyPatch: CompoundKeyPatch!
}

type UpdateCompoundKeyPayload {
  clientMutationId: String
  compoundKey: CompoundKey

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId1: Person

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId2: Person
  query: Query
}

input UpdatePersonByEmailInput {
  clientMutationId: String
  email: Email!
  personPatch: PersonPatch!
}

input UpdatePersonByRowIdInput {
  clientMutationId: String
  rowId: Int!
  personPatch: PersonPatch!
}

input UpdatePersonInput {
  clientMutationId: String
  id: ID!
  personPatch: PersonPatch!
}

type UpdatePersonPayload {
  clientMutationId: String
  person: Person
  query: Query
}
"
`;

exports[`test prints a schema with a JWT generating mutation 1`] = `
"scalar AnInt

type AnIntRange {
  start: AnIntRangeBound
  end: AnIntRangeBound
}

type AnIntRangeBound {
  value: AnInt!
  inclusive: Boolean!
}

input AnIntRangeBoundInput {
  value: AnInt!
  inclusive: Boolean!
}

input AnIntRangeInput {
  start: AnIntRangeBoundInput
  end: AnIntRangeBoundInput
}

scalar AnotherInt

input AuthenticateInput {
  clientMutationId: String
  a: Int
  b: Int
  c: Int
}

type AuthenticatePayload {
  clientMutationId: String
  token: Jwt
  query: Query
}

enum Color {
  RED
  GREEN
  BLUE
}

# Awesome feature!
type CompoundType {
  a: Int
  b: String
  c: Color
  d: Uuid
  fooBar: Int
}

# Awesome feature!
input CompoundTypeInput {
  a: Int
  b: String
  c: Color
  d: Uuid
  fooBar: Int
}

input CompoundTypeMutationInput {
  clientMutationId: String
  object: CompoundTypeInput
}

type CompoundTypeMutationPayload {
  clientMutationId: String
  compoundType: CompoundType
  query: Query
}

input CreateTypeInput {
  clientMutationId: String
  type: TypeInput!
}

type CreateTypePayload {
  clientMutationId: String
  type: Type
  typeEdge(
    # The method to use when ordering \`Type\`.
    orderBy: TypesOrderBy = PRIMARY_KEY_ASC
  ): TypesEdge
  query: Query
}

input CreateUpdatableViewInput {
  clientMutationId: String
  updatableView: UpdatableViewInput!
}

type CreateUpdatableViewPayload {
  clientMutationId: String
  updatableView: UpdatableView
  updatableViewEdge(
    # The method to use when ordering \`UpdatableView\`.
    orderBy: UpdatableViewsOrderBy = NATURAL
  ): UpdatableViewsEdge
  query: Query
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# The day, does not include a time.
scalar Date

# range of dates
type DateRange {
  start: DateRangeBound
  end: DateRangeBound
}

type DateRangeBound {
  value: Date!
  inclusive: Boolean!
}

input DateRangeBoundInput {
  value: Date!
  inclusive: Boolean!
}

# range of dates
input DateRangeInput {
  start: DateRangeBoundInput
  end: DateRangeBoundInput
}

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

input DeleteTypeByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteTypeInput {
  clientMutationId: String
  __id: ID!
}

type DeleteTypePayload {
  clientMutationId: String
  type: Type
  deletedTypeId: ID
  query: Query
}

# range of numerics
type FloatRange {
  start: FloatRangeBound
  end: FloatRangeBound
}

type FloatRangeBound {
  value: Float!
  inclusive: Boolean!
}

input FloatRangeBoundInput {
  value: Float!
  inclusive: Boolean!
}

# range of numerics
input FloatRangeInput {
  start: FloatRangeBoundInput
  end: FloatRangeBoundInput
}

# An interval of time that has passed.
type Interval {
  seconds: Float
  minutes: Int
  hours: Int
  days: Int
  months: Int
  years: Int
}

# An interval of time that has passed.
input IntervalInput {
  seconds: Float
  minutes: Int
  hours: Int
  days: Int
  months: Int
  years: Int
}

# A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar Json

# A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
# which securely represents claims between two parties.
scalar Jwt

input Mult1Input {
  clientMutationId: String
  arg0: Int
  arg1: Int
}

type Mult1Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Mult2Input {
  clientMutationId: String
  arg0: Int
  arg1: Int
}

type Mult2Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Mult3Input {
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

type Mult3Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Mult4Input {
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

type Mult4Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  authenticate(input: AuthenticateInput!): AuthenticatePayload
  compoundTypeMutation(input: CompoundTypeMutationInput!): CompoundTypeMutationPayload
  mult1(input: Mult1Input!): Mult1Payload
  mult2(input: Mult2Input!): Mult2Payload
  mult3(input: Mult3Input!): Mult3Payload
  mult4(input: Mult4Input!): Mult4Payload
  createType(input: CreateTypeInput!): CreateTypePayload
  updateType(input: UpdateTypeInput!): UpdateTypePayload
  updateTypeById(input: UpdateTypeByIdInput!): UpdateTypePayload
  deleteType(input: DeleteTypeInput!): DeleteTypePayload
  deleteTypeById(input: DeleteTypeByIdInput!): DeleteTypePayload
  createUpdatableView(input: CreateUpdatableViewInput!): CreateUpdatableViewPayload
}

type NestedCompoundType {
  a: CompoundType
  b: CompoundType
  bazBuz: Int
}

input NestedCompoundTypeInput {
  a: CompoundTypeInput
  b: CompoundTypeInput
  bazBuz: Int
}

# An object with a globally unique \`ID\`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  __id: ID!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Fetches an object given its globally unique \`ID\`.
  node(
    # The globally unique \`ID\`.
    __id: ID!
  ): Node
  compoundTypeQuery(object: CompoundTypeInput): CompoundType

  # Reads and enables paginatation through a set of \`Type\`.
  allTypes(
    # The method to use when ordering \`Type\`.
    orderBy: TypesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    id: Int
    smallint: Int
    bigint: Int
    boolean: Boolean
    varchar: String
    enum: Color
    domain: AnInt
    domain2: AnotherInt
    textArray: [String]
    json: Json
    jsonb: Json
    numrange: FloatRangeInput
    daterange: DateRangeInput
    anIntRange: AnIntRangeInput
    timestamp: Datetime
    timestamptz: Datetime
    date: Date
    time: Time
    timetz: Time
    interval: IntervalInput
    money: Float
    compoundType: CompoundTypeInput
    nestedCompoundType: NestedCompoundTypeInput
  ): TypesConnection

  # Reads a single \`Type\` using its globally unique \`ID\`.
  type(
    # The globally unique \`ID\` to be used in selecting a single \`Type\`.
    __id: ID!
  ): Type
  typeById(id: Int!): Type

  # Reads and enables paginatation through a set of \`UpdatableView\`.
  allUpdatableViews(
    # The method to use when ordering \`UpdatableView\`.
    orderBy: UpdatableViewsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    x: Int
    name: String
    description: String
    constant: Int
  ): UpdatableViewsConnection

  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a \`Node\` to work well with Relay 1 mutations. This just resolves to \`query\`.
  __id: ID!
}

# The exact time of day, does not include the date. May or may not have a timezone offset.
scalar Time

type Type implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  __id: ID!
  id: Int!
  smallint: Int!
  bigint: Int!
  boolean: Boolean!
  varchar: String!
  enum: Color!
  domain: AnInt!
  domain2: AnotherInt!
  textArray: [String]!
  json: Json!
  jsonb: Json!
  numrange: FloatRange!
  daterange: DateRange!
  anIntRange: AnIntRange!
  timestamp: Datetime!
  timestamptz: Datetime!
  date: Date!
  time: Time!
  timetz: Time!
  interval: Interval!
  money: Float!
  compoundType: CompoundType!
  nestedCompoundType: NestedCompoundType!
}

input TypeInput {
  id: Int
  smallint: Int!
  bigint: Int!
  boolean: Boolean!
  varchar: String!
  enum: Color!
  domain: AnInt!
  domain2: AnotherInt!
  textArray: [String]!
  json: Json!
  jsonb: Json!
  numrange: FloatRangeInput!
  daterange: DateRangeInput!
  anIntRange: AnIntRangeInput!
  timestamp: Datetime!
  timestamptz: Datetime!
  date: Date!
  time: Time!
  timetz: Time!
  interval: IntervalInput!
  money: Float!
  compoundType: CompoundTypeInput!
  nestedCompoundType: NestedCompoundTypeInput!
}

input TypePatch {
  id: Int
  smallint: Int
  bigint: Int
  boolean: Boolean
  varchar: String
  enum: Color
  domain: AnInt
  domain2: AnotherInt
  textArray: [String]
  json: Json
  jsonb: Json
  numrange: FloatRangeInput
  daterange: DateRangeInput
  anIntRange: AnIntRangeInput
  timestamp: Datetime
  timestamptz: Datetime
  date: Date
  time: Time
  timetz: Time
  interval: IntervalInput
  money: Float
  compoundType: CompoundTypeInput
  nestedCompoundType: NestedCompoundTypeInput
}

# A connection to a list of \`Type\` values.
type TypesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Type\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Type\` and cursor to aid in pagination.
  edges: [TypesEdge]

  # A list of \`Type\` objects.
  nodes: [Type!]
}

# A \`Type\` edge in the connection.
type TypesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Type\` at the end of the edge.
  node: Type!
}

# Methods to use when ordering \`Type\`.
enum TypesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SMALLINT_ASC
  SMALLINT_DESC
  BIGINT_ASC
  BIGINT_DESC
  BOOLEAN_ASC
  BOOLEAN_DESC
  VARCHAR_ASC
  VARCHAR_DESC
  ENUM_ASC
  ENUM_DESC
  DOMAIN_ASC
  DOMAIN_DESC
  DOMAIN2_ASC
  DOMAIN2_DESC
  TEXT_ARRAY_ASC
  TEXT_ARRAY_DESC
  JSON_ASC
  JSON_DESC
  JSONB_ASC
  JSONB_DESC
  NUMRANGE_ASC
  NUMRANGE_DESC
  DATERANGE_ASC
  DATERANGE_DESC
  AN_INT_RANGE_ASC
  AN_INT_RANGE_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  TIMESTAMPTZ_ASC
  TIMESTAMPTZ_DESC
  DATE_ASC
  DATE_DESC
  TIME_ASC
  TIME_DESC
  TIMETZ_ASC
  TIMETZ_DESC
  INTERVAL_ASC
  INTERVAL_DESC
  MONEY_ASC
  MONEY_DESC
  COMPOUND_TYPE_ASC
  COMPOUND_TYPE_DESC
  NESTED_COMPOUND_TYPE_ASC
  NESTED_COMPOUND_TYPE_DESC
}

# YOYOYO!!
type UpdatableView {
  x: Int
  name: String
  description: String

  # This is constantly 2
  constant: Int
}

# YOYOYO!!
input UpdatableViewInput {
  x: Int
  name: String
  description: String

  # This is constantly 2
  constant: Int
}

# A connection to a list of \`UpdatableView\` values.
type UpdatableViewsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`UpdatableView\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`UpdatableView\` and cursor to aid in pagination.
  edges: [UpdatableViewsEdge]

  # A list of \`UpdatableView\` objects.
  nodes: [UpdatableView!]
}

# A \`UpdatableView\` edge in the connection.
type UpdatableViewsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`UpdatableView\` at the end of the edge.
  node: UpdatableView!
}

# Methods to use when ordering \`UpdatableView\`.
enum UpdatableViewsOrderBy {
  NATURAL
  X_ASC
  X_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CONSTANT_ASC
  CONSTANT_DESC
}

input UpdateTypeByIdInput {
  clientMutationId: String
  id: Int!
  typePatch: TypePatch!
}

input UpdateTypeInput {
  clientMutationId: String
  __id: ID!
  typePatch: TypePatch!
}

type UpdateTypePayload {
  clientMutationId: String
  type: Type
  query: Query
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar Uuid
"
`;

exports[`test prints a schema with the default options 1`] = `
"input Add1MutationInput {
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

type Add1MutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Add2MutationInput {
  clientMutationId: String
  a: Int!
  b: Int!
}

type Add2MutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Add3MutationInput {
  clientMutationId: String
  a: Int
  arg1: Int
}

type Add3MutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Add4MutationInput {
  clientMutationId: String
  arg0: Int
  b: Int
}

type Add4MutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

scalar AnInt

type AnIntRange {
  start: AnIntRangeBound
  end: AnIntRangeBound
}

type AnIntRangeBound {
  value: AnInt!
  inclusive: Boolean!
}

input AnIntRangeBoundInput {
  value: AnInt!
  inclusive: Boolean!
}

input AnIntRangeInput {
  start: AnIntRangeBoundInput
  end: AnIntRangeBoundInput
}

scalar AnotherInt

input AuthenticateInput {
  clientMutationId: String
  a: Int
  b: Int
  c: Int
}

type AuthenticatePayload {
  clientMutationId: String
  jwtToken: JwtToken
  query: Query
}

enum Color {
  RED
  GREEN
  BLUE
}

type CompoundKey implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  __id: ID!
  personId2: Int!
  personId1: Int!
  extra: Boolean

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId1: Person

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId2: Person

  # Reads and enables paginatation through a set of \`ForeignKey\`.
  foreignKeysByCompoundKey1AndCompoundKey2(
    # The method to use when ordering \`ForeignKey\`.
    orderBy: ForeignKeysOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): ForeignKeysConnection
}

input CompoundKeyInput {
  personId2: Int!
  personId1: Int!
  extra: Boolean
}

input CompoundKeyPatch {
  personId2: Int
  personId1: Int
  extra: Boolean
}

# A connection to a list of \`CompoundKey\` values.
type CompoundKeysConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`CompoundKey\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`CompoundKey\` and cursor to aid in pagination.
  edges: [CompoundKeysEdge]

  # A list of \`CompoundKey\` objects.
  nodes: [CompoundKey!]
}

# A \`CompoundKey\` edge in the connection.
type CompoundKeysEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`CompoundKey\` at the end of the edge.
  node: CompoundKey!
}

# Methods to use when ordering \`CompoundKey\`.
enum CompoundKeysOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  PERSON_ID_2_ASC
  PERSON_ID_2_DESC
  PERSON_ID_1_ASC
  PERSON_ID_1_DESC
  EXTRA_ASC
  EXTRA_DESC
}

# Awesome feature!
type CompoundType {
  a: Int
  b: String
  c: Color
  d: Uuid
  fooBar: Int
  computedField: Int
}

# Awesome feature!
input CompoundTypeInput {
  a: Int
  b: String
  c: Color
  d: Uuid
  fooBar: Int
}

input CompoundTypeMutationInput {
  clientMutationId: String
  object: CompoundTypeInput
}

type CompoundTypeMutationPayload {
  clientMutationId: String
  compoundType: CompoundType
  query: Query
}

input CreateCompoundKeyInput {
  clientMutationId: String
  compoundKey: CompoundKeyInput!
}

type CreateCompoundKeyPayload {
  clientMutationId: String
  compoundKey: CompoundKey
  compoundKeyEdge(
    # The method to use when ordering \`CompoundKey\`.
    orderBy: CompoundKeysOrderBy = PRIMARY_KEY_ASC
  ): CompoundKeysEdge

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId1: Person

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId2: Person
  query: Query
}

input CreateForeignKeyInput {
  clientMutationId: String
  foreignKey: ForeignKeyInput!
}

type CreateForeignKeyPayload {
  clientMutationId: String
  foreignKey: ForeignKey
  foreignKeyEdge(
    # The method to use when ordering \`ForeignKey\`.
    orderBy: ForeignKeysOrderBy = NATURAL
  ): ForeignKeysEdge

  # Reads a single \`CompoundKey\` that is related to this \`ForeignKey\`.
  compoundKeyByCompoundKey1AndCompoundKey2: CompoundKey

  # Reads a single \`Person\` that is related to this \`ForeignKey\`.
  personByPersonId: Person
  query: Query
}

input CreatePersonInput {
  clientMutationId: String
  person: PersonInput!
}

type CreatePersonPayload {
  clientMutationId: String
  person: Person
  personEdge(
    # The method to use when ordering \`Person\`.
    orderBy: PeopleOrderBy = PRIMARY_KEY_ASC
  ): PeopleEdge
  query: Query
}

input CreatePostInput {
  clientMutationId: String
  post: PostInput!
}

type CreatePostPayload {
  clientMutationId: String
  post: Post
  postEdge(
    # The method to use when ordering \`Post\`.
    orderBy: PostsOrderBy = PRIMARY_KEY_ASC
  ): PostsEdge

  # Reads a single \`Person\` that is related to this \`Post\`.
  personByAuthorId: Person
  query: Query
}

input CreateTypeInput {
  clientMutationId: String
  type: TypeInput!
}

type CreateTypePayload {
  clientMutationId: String
  type: Type
  typeEdge(
    # The method to use when ordering \`Type\`.
    orderBy: TypesOrderBy = PRIMARY_KEY_ASC
  ): TypesEdge
  query: Query
}

input CreateUpdatableViewInput {
  clientMutationId: String
  updatableView: UpdatableViewInput!
}

type CreateUpdatableViewPayload {
  clientMutationId: String
  updatableView: UpdatableView
  updatableViewEdge(
    # The method to use when ordering \`UpdatableView\`.
    orderBy: UpdatableViewsOrderBy = NATURAL
  ): UpdatableViewsEdge
  query: Query
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# The day, does not include a time.
scalar Date

# range of dates
type DateRange {
  start: DateRangeBound
  end: DateRangeBound
}

type DateRangeBound {
  value: Date!
  inclusive: Boolean!
}

input DateRangeBoundInput {
  value: Date!
  inclusive: Boolean!
}

# range of dates
input DateRangeInput {
  start: DateRangeBoundInput
  end: DateRangeBoundInput
}

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

input DeleteCompoundKeyByPersonId1AndPersonId2Input {
  clientMutationId: String
  personId1: Int!
  personId2: Int!
}

input DeleteCompoundKeyInput {
  clientMutationId: String
  __id: ID!
}

type DeleteCompoundKeyPayload {
  clientMutationId: String
  compoundKey: CompoundKey
  deletedCompoundKeyId: ID

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId1: Person

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId2: Person
  query: Query
}

input DeletePersonByEmailInput {
  clientMutationId: String
  email: Email!
}

input DeletePersonByIdInput {
  clientMutationId: String
  id: Int!
}

input DeletePersonInput {
  clientMutationId: String
  __id: ID!
}

type DeletePersonPayload {
  clientMutationId: String
  person: Person
  deletedPersonId: ID
  query: Query
}

input DeletePostByIdInput {
  clientMutationId: String
  id: Int!
}

input DeletePostInput {
  clientMutationId: String
  __id: ID!
}

type DeletePostPayload {
  clientMutationId: String
  post: Post
  deletedPostId: ID

  # Reads a single \`Person\` that is related to this \`Post\`.
  personByAuthorId: Person
  query: Query
}

input DeleteTypeByIdInput {
  clientMutationId: String
  id: Int!
}

input DeleteTypeInput {
  clientMutationId: String
  __id: ID!
}

type DeleteTypePayload {
  clientMutationId: String
  type: Type
  deletedTypeId: ID
  query: Query
}

scalar Email

# range of numerics
type FloatRange {
  start: FloatRangeBound
  end: FloatRangeBound
}

type FloatRangeBound {
  value: Float!
  inclusive: Boolean!
}

input FloatRangeBoundInput {
  value: Float!
  inclusive: Boolean!
}

# range of numerics
input FloatRangeInput {
  start: FloatRangeBoundInput
  end: FloatRangeBoundInput
}

type ForeignKey {
  personId: Int
  compoundKey1: Int
  compoundKey2: Int

  # Reads a single \`CompoundKey\` that is related to this \`ForeignKey\`.
  compoundKeyByCompoundKey1AndCompoundKey2: CompoundKey

  # Reads a single \`Person\` that is related to this \`ForeignKey\`.
  personByPersonId: Person
}

input ForeignKeyInput {
  personId: Int
  compoundKey1: Int
  compoundKey2: Int
}

# A connection to a list of \`ForeignKey\` values.
type ForeignKeysConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`ForeignKey\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`ForeignKey\` and cursor to aid in pagination.
  edges: [ForeignKeysEdge]

  # A list of \`ForeignKey\` objects.
  nodes: [ForeignKey!]
}

# A \`ForeignKey\` edge in the connection.
type ForeignKeysEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`ForeignKey\` at the end of the edge.
  node: ForeignKey!
}

# Methods to use when ordering \`ForeignKey\`.
enum ForeignKeysOrderBy {
  NATURAL
  PERSON_ID_ASC
  PERSON_ID_DESC
  COMPOUND_KEY_1_ASC
  COMPOUND_KEY_1_DESC
  COMPOUND_KEY_2_ASC
  COMPOUND_KEY_2_DESC
}

# An interval of time that has passed.
type Interval {
  seconds: Float
  minutes: Int
  hours: Int
  days: Int
  months: Int
  years: Int
}

# An interval of time that has passed.
input IntervalInput {
  seconds: Float
  minutes: Int
  hours: Int
  days: Int
  months: Int
  years: Int
}

input IntSetMutationInput {
  clientMutationId: String
  x: Int
  y: Int
  z: Int
}

type IntSetMutationPayload {
  clientMutationId: String
  integers: [Int]
  query: Query
}

# A connection to a list of \`Int\` values.
type IntSetQueryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Int\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Int\` and cursor to aid in pagination.
  edges: [IntSetQueryEdge]

  # A list of \`Int\` objects.
  nodes: [Int]
}

# A \`Int\` edge in the connection.
type IntSetQueryEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Int\` at the end of the edge.
  node: Int
}

# Methods to use when ordering \`Int\`.
enum IntSetQueryOrderBy {
  NATURAL
}

# A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar Json

type JwtToken {
  role: String
  exp: Int
  a: Int
  b: Int
  c: Int
}

input Mult1Input {
  clientMutationId: String
  arg0: Int
  arg1: Int
}

type Mult1Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Mult2Input {
  clientMutationId: String
  arg0: Int
  arg1: Int
}

type Mult2Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Mult3Input {
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

type Mult3Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

input Mult4Input {
  clientMutationId: String
  arg0: Int!
  arg1: Int!
}

type Mult4Payload {
  clientMutationId: String
  integer: Int
  query: Query
}

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  # lol, add some stuff 1 mutation
  add1Mutation(input: Add1MutationInput!): Add1MutationPayload

  # lol, add some stuff 2 mutation
  add2Mutation(input: Add2MutationInput!): Add2MutationPayload

  # lol, add some stuff 3 mutation
  add3Mutation(input: Add3MutationInput!): Add3MutationPayload

  # lol, add some stuff 4 mutation
  add4Mutation(input: Add4MutationInput!): Add4MutationPayload
  authenticate(input: AuthenticateInput!): AuthenticatePayload
  compoundTypeMutation(input: CompoundTypeMutationInput!): CompoundTypeMutationPayload
  mult1(input: Mult1Input!): Mult1Payload
  mult2(input: Mult2Input!): Mult2Payload
  mult3(input: Mult3Input!): Mult3Payload
  mult4(input: Mult4Input!): Mult4Payload
  intSetMutation(input: IntSetMutationInput!): IntSetMutationPayload
  noArgsMutation(input: NoArgsMutationInput!): NoArgsMutationPayload
  tableMutation(input: TableMutationInput!): TableMutationPayload
  tableSetMutation(input: TableSetMutationInput!): TableSetMutationPayload
  typesMutation(input: TypesMutationInput!): TypesMutationPayload
  createForeignKey(input: CreateForeignKeyInput!): CreateForeignKeyPayload
  createPost(input: CreatePostInput!): CreatePostPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  updatePostById(input: UpdatePostByIdInput!): UpdatePostPayload
  deletePost(input: DeletePostInput!): DeletePostPayload
  deletePostById(input: DeletePostByIdInput!): DeletePostPayload
  createType(input: CreateTypeInput!): CreateTypePayload
  updateType(input: UpdateTypeInput!): UpdateTypePayload
  updateTypeById(input: UpdateTypeByIdInput!): UpdateTypePayload
  deleteType(input: DeleteTypeInput!): DeleteTypePayload
  deleteTypeById(input: DeleteTypeByIdInput!): DeleteTypePayload
  createUpdatableView(input: CreateUpdatableViewInput!): CreateUpdatableViewPayload
  createCompoundKey(input: CreateCompoundKeyInput!): CreateCompoundKeyPayload
  updateCompoundKey(input: UpdateCompoundKeyInput!): UpdateCompoundKeyPayload
  updateCompoundKeyByPersonId1AndPersonId2(input: UpdateCompoundKeyByPersonId1AndPersonId2Input!): UpdateCompoundKeyPayload
  deleteCompoundKey(input: DeleteCompoundKeyInput!): DeleteCompoundKeyPayload
  deleteCompoundKeyByPersonId1AndPersonId2(input: DeleteCompoundKeyByPersonId1AndPersonId2Input!): DeleteCompoundKeyPayload
  createPerson(input: CreatePersonInput!): CreatePersonPayload
  updatePerson(input: UpdatePersonInput!): UpdatePersonPayload
  updatePersonByEmail(input: UpdatePersonByEmailInput!): UpdatePersonPayload
  updatePersonById(input: UpdatePersonByIdInput!): UpdatePersonPayload
  deletePerson(input: DeletePersonInput!): DeletePersonPayload
  deletePersonByEmail(input: DeletePersonByEmailInput!): DeletePersonPayload
  deletePersonById(input: DeletePersonByIdInput!): DeletePersonPayload
}

type NestedCompoundType {
  a: CompoundType
  b: CompoundType
  bazBuz: Int
}

input NestedCompoundTypeInput {
  a: CompoundTypeInput
  b: CompoundTypeInput
  bazBuz: Int
}

input NoArgsMutationInput {
  clientMutationId: String
}

type NoArgsMutationPayload {
  clientMutationId: String
  integer: Int
  query: Query
}

# An object with a globally unique \`ID\`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  __id: ID!
}

type NonUpdatableView {
  column: Int
}

# A connection to a list of \`NonUpdatableView\` values.
type NonUpdatableViewsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`NonUpdatableView\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`NonUpdatableView\` and cursor to aid in pagination.
  edges: [NonUpdatableViewsEdge]

  # A list of \`NonUpdatableView\` objects.
  nodes: [NonUpdatableView!]
}

# A \`NonUpdatableView\` edge in the connection.
type NonUpdatableViewsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`NonUpdatableView\` at the end of the edge.
  node: NonUpdatableView!
}

# Methods to use when ordering \`NonUpdatableView\`.
enum NonUpdatableViewsOrderBy {
  NATURAL
  COLUMN_ASC
  COLUMN_DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# A connection to a list of \`Person\` values.
type PeopleConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Person\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Person\` and cursor to aid in pagination.
  edges: [PeopleEdge]

  # A list of \`Person\` objects.
  nodes: [Person!]
}

# A \`Person\` edge in the connection.
type PeopleEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Person\` at the end of the edge.
  node: Person!
}

# Methods to use when ordering \`Person\`.
enum PeopleOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ABOUT_ASC
  ABOUT_DESC
  EMAIL_ASC
  EMAIL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

# Person test comment
type Person implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  __id: ID!
  id: Int!

  # The person’s name
  name: String!
  about: String
  email: Email!
  createdAt: Datetime
  firstName: String

  # Reads and enables paginatation through a set of \`Person\`.
  friends(
    # The method to use when ordering \`Person\`.
    orderBy: PersonFriendsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): PersonFriendsConnection

  # Reads and enables paginatation through a set of \`Post\`.
  postsByAuthorId(
    # The method to use when ordering \`Post\`.
    orderBy: PostsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): PostsConnection

  # Reads and enables paginatation through a set of \`CompoundKey\`.
  compoundKeysByPersonId1(
    # The method to use when ordering \`CompoundKey\`.
    orderBy: CompoundKeysOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): CompoundKeysConnection

  # Reads and enables paginatation through a set of \`CompoundKey\`.
  compoundKeysByPersonId2(
    # The method to use when ordering \`CompoundKey\`.
    orderBy: CompoundKeysOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): CompoundKeysConnection

  # Reads and enables paginatation through a set of \`ForeignKey\`.
  foreignKeysByPersonId(
    # The method to use when ordering \`ForeignKey\`.
    orderBy: ForeignKeysOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): ForeignKeysConnection
}

# A connection to a list of \`Person\` values.
type PersonFriendsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Person\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Person\` and cursor to aid in pagination.
  edges: [PersonFriendsEdge]

  # A list of \`Person\` objects.
  nodes: [Person]
}

# A \`Person\` edge in the connection.
type PersonFriendsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Person\` at the end of the edge.
  node: Person
}

# Methods to use when ordering \`Person\`.
enum PersonFriendsOrderBy {
  NATURAL
}

# Person test comment
input PersonInput {
  id: Int

  # The person’s name
  name: String!
  about: String
  email: Email!
  createdAt: Datetime
}

input PersonPatch {
  id: Int
  name: String
  about: String
  email: Email
  createdAt: Datetime
}

type Post implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  __id: ID!
  id: Int!
  headline: String!
  body: String
  authorId: Int
  headlineTrimmed(length: Int, omission: String): String

  # Reads a single \`Person\` that is related to this \`Post\`.
  personByAuthorId: Person
}

input PostInput {
  id: Int
  headline: String!
  body: String
  authorId: Int
}

input PostPatch {
  id: Int
  headline: String
  body: String
  authorId: Int
}

# A connection to a list of \`Post\` values.
type PostsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Post\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Post\` and cursor to aid in pagination.
  edges: [PostsEdge]

  # A list of \`Post\` objects.
  nodes: [Post!]
}

# A \`Post\` edge in the connection.
type PostsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Post\` at the end of the edge.
  node: Post!
}

# Methods to use when ordering \`Post\`.
enum PostsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  HEADLINE_ASC
  HEADLINE_DESC
  BODY_ASC
  BODY_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Fetches an object given its globally unique \`ID\`.
  node(
    # The globally unique \`ID\`.
    __id: ID!
  ): Node

  # lol, add some stuff 1 query
  add1Query(arg0: Int!, arg1: Int!): Int

  # lol, add some stuff 2 query
  add2Query(a: Int!, b: Int!): Int

  # lol, add some stuff 3 query
  add3Query(a: Int, arg1: Int): Int

  # lol, add some stuff 4 query
  add4Query(arg0: Int, b: Int): Int
  compoundTypeQuery(object: CompoundTypeInput): CompoundType

  # Reads and enables paginatation through a set of \`Int\`.
  intSetQuery(
    # The method to use when ordering \`Int\`.
    orderBy: IntSetQueryOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    x: Int
    y: Int
    z: Int
  ): IntSetQueryConnection
  jsonIdentity(json: Json): Json
  noArgsQuery: Int
  tableQuery(id: Int): Post

  # Reads and enables paginatation through a set of \`Person\`.
  tableSetQuery(
    # The method to use when ordering \`Person\`.
    orderBy: TableSetQueryOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
  ): TableSetQueryConnection
  typesQuery(a: Int!, b: Boolean!, c: String!, d: [Int]!, e: Json!, f: FloatRangeInput!): Boolean

  # Reads and enables paginatation through a set of \`ForeignKey\`.
  allForeignKeys(
    # The method to use when ordering \`ForeignKey\`.
    orderBy: ForeignKeysOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    personId: Int
    compoundKey1: Int
    compoundKey2: Int
  ): ForeignKeysConnection

  # Reads and enables paginatation through a set of \`NonUpdatableView\`.
  allNonUpdatableViews(
    # The method to use when ordering \`NonUpdatableView\`.
    orderBy: NonUpdatableViewsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    column: Int
  ): NonUpdatableViewsConnection

  # Reads and enables paginatation through a set of \`Post\`.
  allPosts(
    # The method to use when ordering \`Post\`.
    orderBy: PostsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    id: Int
    headline: String
    body: String
    authorId: Int
  ): PostsConnection

  # Reads a single \`Post\` using its globally unique \`ID\`.
  post(
    # The globally unique \`ID\` to be used in selecting a single \`Post\`.
    __id: ID!
  ): Post
  postById(id: Int!): Post

  # Reads and enables paginatation through a set of \`Type\`.
  allTypes(
    # The method to use when ordering \`Type\`.
    orderBy: TypesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    id: Int
    smallint: Int
    bigint: Int
    boolean: Boolean
    varchar: String
    enum: Color
    domain: AnInt
    domain2: AnotherInt
    textArray: [String]
    json: Json
    jsonb: Json
    numrange: FloatRangeInput
    daterange: DateRangeInput
    anIntRange: AnIntRangeInput
    timestamp: Datetime
    timestamptz: Datetime
    date: Date
    time: Time
    timetz: Time
    interval: IntervalInput
    money: Float
    compoundType: CompoundTypeInput
    nestedCompoundType: NestedCompoundTypeInput
  ): TypesConnection

  # Reads a single \`Type\` using its globally unique \`ID\`.
  type(
    # The globally unique \`ID\` to be used in selecting a single \`Type\`.
    __id: ID!
  ): Type
  typeById(id: Int!): Type

  # Reads and enables paginatation through a set of \`UpdatableView\`.
  allUpdatableViews(
    # The method to use when ordering \`UpdatableView\`.
    orderBy: UpdatableViewsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    x: Int
    name: String
    description: String
    constant: Int
  ): UpdatableViewsConnection

  # Reads and enables paginatation through a set of \`CompoundKey\`.
  allCompoundKeys(
    # The method to use when ordering \`CompoundKey\`.
    orderBy: CompoundKeysOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    personId2: Int
    personId1: Int
    extra: Boolean
  ): CompoundKeysConnection

  # Reads a single \`CompoundKey\` using its globally unique \`ID\`.
  compoundKey(
    # The globally unique \`ID\` to be used in selecting a single \`CompoundKey\`.
    __id: ID!
  ): CompoundKey
  compoundKeyByPersonId1AndPersonId2(personId1: Int!, personId2: Int!): CompoundKey

  # Reads and enables paginatation through a set of \`Person\`.
  allPeople(
    # The method to use when ordering \`Person\`.
    orderBy: PeopleOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first \`n\` values of the set.
    first: Int

    # Only read the last \`n\` values of the set.
    last: Int

    # Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    # based pagination. May not be used with \`last\`.
    offset: Int
    id: Int
    name: String
    about: String
    email: Email
    createdAt: Datetime
  ): PeopleConnection

  # Reads a single \`Person\` using its globally unique \`ID\`.
  person(
    # The globally unique \`ID\` to be used in selecting a single \`Person\`.
    __id: ID!
  ): Person
  personByEmail(email: Email!): Person
  personById(id: Int!): Person

  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a \`Node\` to work well with Relay 1 mutations. This just resolves to \`query\`.
  __id: ID!
}

input TableMutationInput {
  clientMutationId: String
  id: Int
}

type TableMutationPayload {
  clientMutationId: String
  post: Post

  # Reads a single \`Person\` that is related to this \`Post\`.
  personByAuthorId: Person
  query: Query
}

input TableSetMutationInput {
  clientMutationId: String
}

type TableSetMutationPayload {
  clientMutationId: String
  people: [Person]
  query: Query
}

# A connection to a list of \`Person\` values.
type TableSetQueryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Person\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Person\` and cursor to aid in pagination.
  edges: [TableSetQueryEdge]

  # A list of \`Person\` objects.
  nodes: [Person]
}

# A \`Person\` edge in the connection.
type TableSetQueryEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Person\` at the end of the edge.
  node: Person
}

# Methods to use when ordering \`Person\`.
enum TableSetQueryOrderBy {
  NATURAL
}

# The exact time of day, does not include the date. May or may not have a timezone offset.
scalar Time

type Type implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  __id: ID!
  id: Int!
  smallint: Int!
  bigint: Int!
  boolean: Boolean!
  varchar: String!
  enum: Color!
  domain: AnInt!
  domain2: AnotherInt!
  textArray: [String]!
  json: Json!
  jsonb: Json!
  numrange: FloatRange!
  daterange: DateRange!
  anIntRange: AnIntRange!
  timestamp: Datetime!
  timestamptz: Datetime!
  date: Date!
  time: Time!
  timetz: Time!
  interval: Interval!
  money: Float!
  compoundType: CompoundType!
  nestedCompoundType: NestedCompoundType!
}

input TypeInput {
  id: Int
  smallint: Int!
  bigint: Int!
  boolean: Boolean!
  varchar: String!
  enum: Color!
  domain: AnInt!
  domain2: AnotherInt!
  textArray: [String]!
  json: Json!
  jsonb: Json!
  numrange: FloatRangeInput!
  daterange: DateRangeInput!
  anIntRange: AnIntRangeInput!
  timestamp: Datetime!
  timestamptz: Datetime!
  date: Date!
  time: Time!
  timetz: Time!
  interval: IntervalInput!
  money: Float!
  compoundType: CompoundTypeInput!
  nestedCompoundType: NestedCompoundTypeInput!
}

input TypePatch {
  id: Int
  smallint: Int
  bigint: Int
  boolean: Boolean
  varchar: String
  enum: Color
  domain: AnInt
  domain2: AnotherInt
  textArray: [String]
  json: Json
  jsonb: Json
  numrange: FloatRangeInput
  daterange: DateRangeInput
  anIntRange: AnIntRangeInput
  timestamp: Datetime
  timestamptz: Datetime
  date: Date
  time: Time
  timetz: Time
  interval: IntervalInput
  money: Float
  compoundType: CompoundTypeInput
  nestedCompoundType: NestedCompoundTypeInput
}

# A connection to a list of \`Type\` values.
type TypesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`Type\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`Type\` and cursor to aid in pagination.
  edges: [TypesEdge]

  # A list of \`Type\` objects.
  nodes: [Type!]
}

# A \`Type\` edge in the connection.
type TypesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`Type\` at the end of the edge.
  node: Type!
}

input TypesMutationInput {
  clientMutationId: String
  a: Int!
  b: Boolean!
  c: String!
  d: [Int]!
  e: Json!
  f: FloatRangeInput!
}

type TypesMutationPayload {
  clientMutationId: String
  boolean: Boolean
  query: Query
}

# Methods to use when ordering \`Type\`.
enum TypesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SMALLINT_ASC
  SMALLINT_DESC
  BIGINT_ASC
  BIGINT_DESC
  BOOLEAN_ASC
  BOOLEAN_DESC
  VARCHAR_ASC
  VARCHAR_DESC
  ENUM_ASC
  ENUM_DESC
  DOMAIN_ASC
  DOMAIN_DESC
  DOMAIN2_ASC
  DOMAIN2_DESC
  TEXT_ARRAY_ASC
  TEXT_ARRAY_DESC
  JSON_ASC
  JSON_DESC
  JSONB_ASC
  JSONB_DESC
  NUMRANGE_ASC
  NUMRANGE_DESC
  DATERANGE_ASC
  DATERANGE_DESC
  AN_INT_RANGE_ASC
  AN_INT_RANGE_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  TIMESTAMPTZ_ASC
  TIMESTAMPTZ_DESC
  DATE_ASC
  DATE_DESC
  TIME_ASC
  TIME_DESC
  TIMETZ_ASC
  TIMETZ_DESC
  INTERVAL_ASC
  INTERVAL_DESC
  MONEY_ASC
  MONEY_DESC
  COMPOUND_TYPE_ASC
  COMPOUND_TYPE_DESC
  NESTED_COMPOUND_TYPE_ASC
  NESTED_COMPOUND_TYPE_DESC
}

# YOYOYO!!
type UpdatableView {
  x: Int
  name: String
  description: String

  # This is constantly 2
  constant: Int
}

# YOYOYO!!
input UpdatableViewInput {
  x: Int
  name: String
  description: String

  # This is constantly 2
  constant: Int
}

# A connection to a list of \`UpdatableView\` values.
type UpdatableViewsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* \`UpdatableView\` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the \`UpdatableView\` and cursor to aid in pagination.
  edges: [UpdatableViewsEdge]

  # A list of \`UpdatableView\` objects.
  nodes: [UpdatableView!]
}

# A \`UpdatableView\` edge in the connection.
type UpdatableViewsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The \`UpdatableView\` at the end of the edge.
  node: UpdatableView!
}

# Methods to use when ordering \`UpdatableView\`.
enum UpdatableViewsOrderBy {
  NATURAL
  X_ASC
  X_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CONSTANT_ASC
  CONSTANT_DESC
}

input UpdateCompoundKeyByPersonId1AndPersonId2Input {
  clientMutationId: String
  personId1: Int!
  personId2: Int!
  compoundKeyPatch: CompoundKeyPatch!
}

input UpdateCompoundKeyInput {
  clientMutationId: String
  __id: ID!
  compoundKeyPatch: CompoundKeyPatch!
}

type UpdateCompoundKeyPayload {
  clientMutationId: String
  compoundKey: CompoundKey

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId1: Person

  # Reads a single \`Person\` that is related to this \`CompoundKey\`.
  personByPersonId2: Person
  query: Query
}

input UpdatePersonByEmailInput {
  clientMutationId: String
  email: Email!
  personPatch: PersonPatch!
}

input UpdatePersonByIdInput {
  clientMutationId: String
  id: Int!
  personPatch: PersonPatch!
}

input UpdatePersonInput {
  clientMutationId: String
  __id: ID!
  personPatch: PersonPatch!
}

type UpdatePersonPayload {
  clientMutationId: String
  person: Person
  query: Query
}

input UpdatePostByIdInput {
  clientMutationId: String
  id: Int!
  postPatch: PostPatch!
}

input UpdatePostInput {
  clientMutationId: String
  __id: ID!
  postPatch: PostPatch!
}

type UpdatePostPayload {
  clientMutationId: String
  post: Post

  # Reads a single \`Person\` that is related to this \`Post\`.
  personByAuthorId: Person
  query: Query
}

input UpdateTypeByIdInput {
  clientMutationId: String
  id: Int!
  typePatch: TypePatch!
}

input UpdateTypeInput {
  clientMutationId: String
  __id: ID!
  typePatch: TypePatch!
}

type UpdateTypePayload {
  clientMutationId: String
  type: Type
  query: Query
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar Uuid
"
`;
