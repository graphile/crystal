"use strict";
/* eslint-disable no-restricted-syntax */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*
 * This file demonstrates a schema that's autogenerated by a user-supplied
 * registry (hence the "no data gathering" - we skip the gather phase).
 */
const promises_1 = require("node:fs/promises");
const node_url_1 = require("node:url");
const node_util_1 = require("node:util");
const pg_1 = require("@dataplan/pg");
const pg_2 = require("@dataplan/pg/adaptors/pg");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const grafast_1 = require("grafast");
const graphql_1 = require("grafast/graphql");
const graphile_build_1 = require("graphile-build");
const graphile_config_1 = require("graphile-config");
const graphile_export_1 = require("graphile-export");
const pg_3 = require("pg");
const pg_sql2_1 = tslib_1.__importDefault(require("pg-sql2"));
const index_js_1 = require("../index.js");
const pool = new pg_3.Pool({
    connectionString: "graphilecrystaltest",
});
const withPgClient = (0, pg_2.makePgAdaptorWithPgClient)(pool);
async function main() {
    // Create our GraphQL schema by applying all the plugins
    const executor = (0, graphile_export_1.EXPORTABLE)((PgExecutor, context, object) => new PgExecutor({
        name: "main",
        context: () => object({
            pgSettings: context().get("pgSettings"),
            withPgClient: context().get("withPgClient"),
        }),
    }), [pg_1.PgExecutor, grafast_1.context, grafast_1.object]);
    // TODO: extract this to be usable in general and not specific to this
    // example file.
    const UseRelationNamesPlugin = {
        name: "UseRelationNamesPlugin",
        version: "0.0.0",
        inflection: {
            replace: {
                singleRelation(previous, options, details) {
                    return this.camelCase(details.relationName);
                },
                singleRelationBackwards(previous, options, details) {
                    return this.camelCase(details.relationName);
                },
                manyRelationConnection(previous, options, details) {
                    return this.connectionField(this.camelCase(details.relationName));
                },
                manyRelationList(previous, options, details) {
                    return this.listField(this.camelCase(details.relationName));
                },
            },
        },
    };
    const config = (0, graphile_config_1.resolvePreset)({
        extends: [graphile_build_1.defaultPreset, index_js_1.defaultPreset],
        plugins: [graphile_build_1.QueryQueryPlugin, UseRelationNamesPlugin],
    });
    const pgRegistry = (0, graphile_export_1.EXPORTABLE)((TYPES, executor, makePgResourceOptions, makeRegistryBuilder, recordCodec, sql, sqlFromArgDigests) => {
        const usersCodec = recordCodec({
            executor,
            name: `app_public.users`,
            identifier: sql `app_public.users`,
            attributes: {
                id: {
                    codec: TYPES.uuid,
                    notNull: true,
                    extensions: {
                        tags: {
                            hasDefault: true,
                        },
                    },
                },
                username: {
                    codec: TYPES.text,
                    notNull: true,
                },
                gravatar_url: {
                    codec: TYPES.text,
                    notNull: false,
                },
                created_at: {
                    codec: TYPES.timestamptz,
                    notNull: true,
                },
            },
            extensions: {
                tags: {
                    name: "users",
                },
            },
        });
        const forumsCodec = recordCodec({
            executor,
            name: `app_public.forums`,
            identifier: sql `app_public.forums`,
            attributes: {
                id: {
                    codec: TYPES.uuid,
                    notNull: true,
                    extensions: {
                        tags: {
                            hasDefault: true,
                        },
                    },
                },
                name: {
                    codec: TYPES.text,
                    notNull: true,
                },
                archived_at: {
                    codec: TYPES.timestamptz,
                    notNull: false,
                },
            },
            extensions: {
                tags: {
                    name: "forums",
                },
            },
        });
        const messagesCodec = recordCodec({
            executor,
            name: `app_public.messages`,
            identifier: sql `app_public.messages`,
            attributes: {
                id: {
                    codec: TYPES.uuid,
                    notNull: true,
                    extensions: {
                        tags: {
                            hasDefault: true,
                        },
                    },
                },
                forum_id: {
                    codec: TYPES.uuid,
                    notNull: true,
                },
                author_id: {
                    codec: TYPES.uuid,
                    notNull: true,
                },
                body: {
                    codec: TYPES.text,
                    notNull: true,
                },
                featured: {
                    codec: TYPES.boolean,
                    notNull: true,
                },
                created_at: {
                    codec: TYPES.timestamptz,
                    notNull: true,
                },
                archived_at: {
                    codec: TYPES.timestamptz,
                    notNull: false,
                },
            },
            extensions: {
                tags: {
                    name: "messages",
                },
            },
        });
        const usersResourceOptions = makePgResourceOptions({
            name: "users",
            executor,
            from: usersCodec.sqlType,
            codec: usersCodec,
            uniques: [{ attributes: ["id"], isPrimary: true }],
        });
        const forumsResourceOptions = makePgResourceOptions({
            //name: "main.app_public.forums",
            name: "forums",
            executor,
            from: forumsCodec.sqlType,
            codec: forumsCodec,
            uniques: [{ attributes: ["id"], isPrimary: true }],
        });
        const messagesResourceOptions = makePgResourceOptions({
            name: "messages",
            executor,
            from: messagesCodec.sqlType,
            codec: messagesCodec,
            uniques: [{ attributes: ["id"], isPrimary: true }],
        });
        const uniqueAuthorCountResourceOptions = makePgResourceOptions({
            executor,
            codec: TYPES.int,
            from: (...args) => sql `app_public.unique_author_count(${sqlFromArgDigests(args)})`,
            name: "unique_author_count",
            parameters: [
                {
                    name: "featured",
                    required: false,
                    codec: TYPES.boolean,
                },
            ],
            extensions: {
                tags: {
                    behavior: "queryField",
                },
            },
        });
        const forumsUniqueAuthorCountResourceOptions = makePgResourceOptions({
            executor,
            codec: TYPES.int,
            isUnique: true,
            from: (...args) => sql `app_public.forums_unique_author_count(${sqlFromArgDigests(args)})`,
            name: "forums_unique_author_count",
            parameters: [
                {
                    name: "forum",
                    codec: forumsCodec,
                    required: true,
                    notNull: true,
                },
                {
                    name: "featured",
                    codec: TYPES.boolean,
                    required: false,
                    notNull: false,
                },
            ],
            extensions: {
                tags: {
                    // behavior: ["typeField"],
                    name: "unique_author_count",
                },
            },
        });
        const forumsRandomUserResourceOptions = makePgResourceOptions({
            executor,
            codec: usersCodec,
            isUnique: true,
            from: (...args) => sql `app_public.forums_random_user(${sqlFromArgDigests(args)})`,
            name: "forums_random_user",
            parameters: [
                {
                    name: "forum",
                    codec: forumsCodec,
                    required: true,
                    notNull: true,
                },
            ],
            extensions: {
                tags: {
                    // behavior: ["typeField"],
                    name: "random_user",
                },
            },
        });
        const forumsFeaturedMessagesResourceOptions = makePgResourceOptions({
            executor,
            codec: messagesCodec,
            isUnique: false,
            from: (...args) => sql `app_public.forums_featured_messages(${sqlFromArgDigests(args)})`,
            name: "forums_featured_messages",
            parameters: [
                {
                    name: "forum",
                    codec: forumsCodec,
                    required: true,
                    notNull: true,
                },
            ],
            extensions: {
                tags: {
                    behavior: "typeField connection list",
                    name: "featured_messages",
                },
            },
        });
        return makeRegistryBuilder()
            .addResource(usersResourceOptions)
            .addResource(forumsResourceOptions)
            .addResource(messagesResourceOptions)
            .addResource(uniqueAuthorCountResourceOptions)
            .addResource(forumsUniqueAuthorCountResourceOptions)
            .addResource(forumsRandomUserResourceOptions)
            .addResource(forumsFeaturedMessagesResourceOptions)
            .addRelation(usersResourceOptions.codec, "messages", messagesResourceOptions, {
            isUnique: false,
            localAttributes: ["id"],
            remoteAttributes: ["author_id"],
        })
            .addRelation(forumsResourceOptions.codec, "messages", messagesResourceOptions, {
            isUnique: false,
            localAttributes: ["id"],
            remoteAttributes: ["forum_id"],
            extensions: {
                tags: {
                    behavior: "connection list",
                },
            },
        })
            .addRelation(messagesResourceOptions.codec, "author", usersResourceOptions, {
            isUnique: true,
            localAttributes: ["author_id"],
            remoteAttributes: ["id"],
        })
            .addRelation(messagesResourceOptions.codec, "forum", forumsResourceOptions, {
            isUnique: true,
            localAttributes: ["forum_id"],
            remoteAttributes: ["id"],
        })
            .build();
    }, [
        pg_1.TYPES,
        executor,
        pg_1.makePgResourceOptions,
        pg_1.makeRegistryBuilder,
        pg_1.recordCodec,
        pg_sql2_1.default,
        pg_1.sqlFromArgDigests,
    ]);
    // We're crafting our own input
    const input = {
        pgRegistry: pgRegistry,
    };
    const schema = (0, graphile_build_1.buildSchema)(config, input);
    // Output our schema
    console.log(chalk_1.default.blue((0, graphql_1.printSchema)(schema)));
    console.log();
    console.log();
    console.log();
    // Common GraphQL arguments
    const source = /* GraphQL */ `
    query {
      allForumsList {
        id
        name
        archivedAt
      }
      allForums {
        nodes {
          id
          name
          archivedAt
          messagesList {
            id
            body
            forumId
            authorId
          }
        }
        edges {
          cursor
          node {
            id
            name
            archivedAt
            messages {
              nodes {
                id
                body
                forumId
                authorId
              }
            }
          }
        }
        pageInfo {
          hasNextPage
          hasPreviousPage
          startCursor
          endCursor
        }
        totalCount
      }
      allUsersList {
        id
        username
        gravatarUrl
        createdAt
        messages {
          totalCount
        }
      }
      allMessagesList {
        id
        forumId
        authorId
        body
        featured
        createdAt
        archivedAt
        forum {
          name
          uniqueAuthorCount
          uniqueAuthorCountFeatured: uniqueAuthorCount(featured: true)
          randomUser {
            id
            username
          }
          featuredMessages {
            nodes {
              id
              body
              featured
            }
          }
          featuredMessagesList {
            id
            body
            featured
          }
        }
        author {
          username
        }
      }
    }
  `;
    const rootValue = null;
    const contextValue = {
        withPgClient,
    };
    const variableValues = Object.create(null);
    // Run our query
    const result = await (0, graphql_1.graphql)({
        schema,
        source,
        rootValue,
        variableValues,
        contextValue,
    });
    console.log((0, node_util_1.inspect)(result, { depth: Infinity, colors: true }));
    if ("errors" in result && result.errors) {
        process.exit(1);
    }
    // Export schema
    // const exportFileLocation = new URL("../../temp.js", import.meta.url);
    const exportFileLocation = `${__dirname}/../../temp.mjs`;
    await (0, graphile_export_1.exportSchema)(schema, exportFileLocation);
    // output code
    console.log(chalk_1.default.green(await (0, promises_1.readFile)(exportFileLocation, "utf8")));
    // run code
    const { schema: schema2 } = await import((0, node_url_1.pathToFileURL)(exportFileLocation).href);
    const result2 = await (0, graphql_1.graphql)({
        schema: schema2,
        source,
        rootValue,
        variableValues,
        contextValue,
    });
    console.log((0, node_util_1.inspect)(result2, { depth: Infinity, colors: true }));
}
main()
    .then(() => pool.end())
    .catch((e) => {
    console.error(e);
    process.exit(1);
});
//# sourceMappingURL=NO_DATA_GATHERING.js.map