---
sidebar_position: 11
---

# Config

<!-- START:OPTIONS:grafast -->

```ts
{
  context?: Partial<Grafast.Context> | ((ctx: Partial<Grafast.RequestContext>, args: Grafast.ExecutionArgs) => PromiseOrValue<Partial<Grafast.Context>>);
  distributorPauseDuration?: number;
  distributorTargetBufferSize?: number;
  distributorTargetBufferSizeIncrement?: number;
  explain?: boolean | string[];
  maxPlanningDepth?: number;
  timeouts?: GrafastTimeouts;
}
```

### grafast.context

Type: `Partial<Grafast.Context> | ((ctx: Partial<Grafast.RequestContext>, args: Grafast.ExecutionArgs) => PromiseOrValue<Partial<Grafast.Context>>) | undefined`

An object to merge into the GraphQL context. Alternatively, pass an
(optionally asynchronous) function that returns an object to merge into
the GraphQL context.

### grafast.distributorPauseDuration

Type: `number | undefined`

Duration (in milliseconds) for the distributor to pause whilst waiting
for the slowest consumer to advance once the
`distributorTargetBufferSize` has been reached.

Must be at least 0.

### grafast.distributorTargetBufferSize

Type: `number | undefined`

This supports the `$step.cloneStreams = true` option, allowing
multiple consumers to consume the same underlying stream, but tries to
avoid any one consumer getting more than `distributorTargetBufferSize`
items ahead of any other. When a fast consumer gets this far ahead of
the slowest consumer, it will be paused for `distributorPauseDuration`
milliseconds to allow the slowest consumer to advance. Should the
slowest consumer not advance in time, the fast consumer will be
allowed to continue and all intermediary results will be cached - so
beware of memory exhaustion and be sure to place sensible limits on
your queries (and construct them wisely).

This must be set higher than the largest `@stream(initialCount:)`
argument you want to support.

### grafast.distributorTargetBufferSizeIncrement

Type: `number | undefined`

When the `distributorTargetBufferSize` is exceeded, every time we get
`distributorTargetBufferSizeIncrement` items further ahead, we'll
pause again.

Must be at least 1. Recommend you set this fairly large.

### grafast.explain

Type: `boolean | string[] | undefined`

A list of 'explain' types that should be included in `extensions.explain`.

- `plan` will cause the plan JSON to be included
- other values are dependent on the plugins in play

If set to `true` then all possible explain types will be exposed.

### grafast.maxPlanningDepth

Type: `number | undefined`

How many planning layers deep do we allow? Should be handled by validation.

A planning layer can happen due to:

- A nested selection set
- Planning a field return type
- A list position
- A polymorphic type
- A deferred/streamed response

These reasons may each cause 1, 2 or 3 planning layers to be added, so this
limit should be set quite high - e.g. 6x the selection set depth.

### grafast.timeouts

Type: `GrafastTimeouts | undefined`

<!-- END:OPTIONS:grafast -->

