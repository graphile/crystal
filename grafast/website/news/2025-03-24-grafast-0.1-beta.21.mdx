---
title: "Major Grafast beta released: Three down, one to go!"
description:
  "This release contains more than 3 months of work, and is a major step towards
  release readiness."
slug: 2025-03-24-grafast-0.1-beta.21
authors:
  - name: Benjie
    title: Inventor of Grafast
    url: https://github.com/Benjie
    image_url: https://github.com/Benjie.png
tags: [0.1]
hide_table_of_contents: true
---

import styles from "@site/src/css/common.module.css";

<p className={styles.intro}>

In the first Gra<em>fast</em> Working Group, we outlined 4 <em>major</em> issues in Gra<em>fast</em>
that needed to be addressed before we could think about general release. With
this release, 3 of these are now complete!

- ‚úÖ‚§µÔ∏è Global dependencies - solved via "unary" steps
- ‚úÖ‚§µÔ∏è Early exit - solved via "flags"
- ‚úÖüéâ **Eradicating eval - this release!**
- ü§îüîú Polymorphism

After 3 months of gruelling work, we're proud to announce that the third of
these, eradicating eval, is now addressed with the launch of
`grafast@0.1.1-beta.21` (used as the core execution engine in
`postgraphile@5.0.0-beta.39`).

</p>

## Input evaluation moved to runtime

Since the beginning, Gra*fast* has had the ability to add plan resolvers not
just to fields, not just to arguments, but also to input object fields
(including those within lists). This made Gra*fast*'s planning really ergonomic
for things like nested filters, which was great for PostGraphile! But it turns
out it's really problematic for certain shapes of input ‚Äî planning would put
constraints on the variables compatible with the plan, requiring potentially
unlimited numbers of operation plans needing to be built for the same GraphQL
document. Worse: for large input trees involving lists, the number of steps
generated could be overwhelming, resulting in the deduplication phase taking
excessive time.

One particular user example that could cause 4 minutes of planning time from
just a 100kB input made it clear that we had overreached with using plan
resolvers too deep into inputs; so we've scaled it back so that you can only add
plan resolvers to fields and arguments, you can no longer attach `applyPlan` or
`inputPlan` to input object fields. This was something that we used a lot
internally (hence the huge time investment migrating away!), but very few people
(no-one?) used externally so it was ripe for removal.

That problematic query that took 4 minutes to plan before? It now takes 1.1ms to
plan, yielding a 200,000x speedup!

<!-- truncate-->

### What does this mean for my codebase?

Hopefully good things! Please update to the latest `@beta` of all the
PostGraphile and/or Gra*fast* related modules you're using (including plugins)
and for most users everything should work as before, only better.

I've outlined some of the most common changes you may need to make below, but if
you are impacted by any other changes, please ask for help in the chat ‚Äî AFAIK
most of the other things that have had significant changes are used by almost
no-one except me, so it doesn't make sense for me to invest time documenting it
here. If you're curious, many items are documented in both the changelogs and
the pull requests where the changes occurred.

#### Change `fieldArgs.get` to `fieldArgs.getRaw`

Because we've removed `inputPlan`, the `fieldArgs.get(key)` method is no more;
instead use `fieldArgs.getRaw(key)` which is equivalent unless the inputs had
plans (which they cannot any more).

#### Converting `applyPlan` and `inputPlan`

If your input object fields did have plan resolvers then instead of having
Grafast automatically call them on each and every input field recursively at
plan-time, we now have the `applyInput` and `bakedInput` steps that represent
runtime application or transform of these inputs recursively via a single step
in our plan diagram.

We've managed to make this new runtime system very similar in shape to the old
plan-time system, so PostGraphile plugins don't need to change much ‚Äî this was
largely enabled by how closely we managed to get the Grafast plan syntax to the
syntax of code you would normally write at runtime. The first change is to
rename `applyPlan` to `apply`, and `inputPlan` to `baked`. From there, your code
might just work straight away, or it might need some more small tweaks (e.g.
`fieldArgs` is no longer present, it's been replaced with simply the runtime
value of the current field).

#### No more `$step.eval*()`

The eval methods are now marked as internal so you will get TypeScript errors if
you try and use them. They will likely be removed at some point after release,
so you should be sure to migrate away from using them at your earliest
opportunity. But you weren't using them anyway‚Ä¶ right?

#### ExecutableStep renamed to Step

This one is more cosmetic‚Ä¶

Since we no longer have plan resolvers deep in inputs, we no longer have the
`ModifierStep` system that was used for managing them (it's been replaced with
`Modifier` which happens at runtime). Since we no longer have ModifierStep, we
no longer need `BaseStep` to be separate from and inherited by `ExecutableStep`,
so we've merged them. Since this is the base class for _all_ steps now, we've
renamed it to simply `Step`.

_We have kept an <code>ExecutableStep</code> export for backwards
compatibility._
