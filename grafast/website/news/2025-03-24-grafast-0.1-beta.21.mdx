---
title: "Major Grafast beta released: Three down, one to go!"
description:
  "This release contains more than 3 months of work, and is a major step towards
  release readiness."
slug: 2025-03-24-grafast-0.1-beta.21
authors:
  - name: Benjie
    title: Inventor of Grafast
    url: https://github.com/Benjie
    image_url: https://github.com/Benjie.png
tags: [0.1]
hide_table_of_contents: true
---

import styles from "@site/src/css/common.module.css";

<p className={styles.intro}>

In the first Gra<em>fast</em> Working Group, we outlined 4 <em>major</em> issues in Gra<em>fast</em>
that needed to be addressed before we could think about general release. With
this release, 3 of these are now complete!

- ‚úÖ‚§µÔ∏è Global dependencies - solved via "unary" steps
- ‚úÖ‚§µÔ∏è Early exit - solved via "flags"
- ‚úÖüéâ **Eradicating eval - this release!**
- ü§îüîú Polymorphism

We‚Äôre proud to announce that the third of these, eradicating eval, is now
addressed with the launch of `grafast@0.1.1-beta.21`, and the approach has been
fully adopted and tested via incorporation into `postgraphile@5.0.0-beta.40`.

</p>

## Input evaluation moved to runtime

Since the beginning, Gra*fast* has had the ability to add plan resolvers not
just to fields, not just to arguments, but also to input object fields
(including those within lists). This made Gra*fast*‚Äôs planning really ergonomic
for things like nested filters. But it turns
out it‚Äôs really problematic for certain shapes of input ‚Äî planning would put
constraints on the variables compatible with the plan, requiring potentially
unlimited numbers of operation plans needing to be built for the same GraphQL
document. Worse: for large input trees involving lists, the number of steps
generated could be overwhelming, resulting in the deduplication phase taking
excessive time.

One particular user example that could cause 4 minutes of planning time from
just a 100kB input made it clear that we had overreached with using plan
resolvers too deep into inputs; so we‚Äôve scaled it back so that you can only
add plan resolvers to fields and arguments, you can no longer attach
`applyPlan` or `inputPlan` to input object fields. This was something that we
used a lot in PostGraphile and its various plugins, but very few people
(no-one?) used externally so it was ripe for removal.

That problematic query that took 4 minutes to plan before? It now takes 1.1ms to
plan, yielding a 200,000x speedup!

<!-- truncate-->

### What does this mean for my codebase?

Hopefully good things! Please update to the latest `grafast@beta` and for most
users everything should work as before, only better.

I‚Äôve outlined some of the most common changes you may need to make below, but
if you are impacted by any other changes, please ask for help [in the
chat](https://discord.gg/graphile) ‚Äî AFAIK most of the other things that have
had significant changes are used by almost no-one except me, so it doesn‚Äôt make
sense for me to invest time documenting it here since the software is still in
beta. If you‚Äôre curious, many items are documented in both the changelogs and
the pull requests where the changes occurred.

#### Change `fieldArgs.get` to `fieldArgs.getRaw`

Because we‚Äôve removed `inputPlan`, the `fieldArgs.get(key)` method is no more;
instead use `fieldArgs.getRaw(key)` which is equivalent unless the inputs had
plans (which they cannot any more). You'd know if you had plans on your inputs,
it's very unlikely you did if you were writing your own Gra*fast* schema.

#### Converting `applyPlan` and `inputPlan`

If your input object fields did have plan resolvers then instead of having
Gra*fast* automatically call them on each and every input field recursively at
plan-time, we now have the `applyInput` and `bakedInput` steps that represent
runtime application or transform of these inputs recursively via a single step
in our plan diagram.

We‚Äôve managed to make this new runtime system very similar in shape to the old
plan-time system (largely enabled by how closely we managed to get the
Gra*fast* plan syntax to the syntax of code you would normally write at
runtime), so if you do need to transform any it shouldn't take much effort. The
first change is to rename `applyPlan` to `apply`, and `inputPlan` to `baked`.
From there, your code might just work straight away, or it might need some more
small tweaks (e.g. `fieldArgs` is no longer present, it‚Äôs been replaced with
simply the runtime value of the current field).

#### No more `$step.eval*()`

The eval methods are now marked as internal so you will get TypeScript errors if
you try and use them. They will likely be removed at some point after release,
so you should be sure to migrate away from using them at your earliest
opportunity. But you weren‚Äôt using them anyway‚Ä¶ right?

If you were, a new `.apply()` pattern has been added to various steps to enable
you to specify runtime tweaks the step can apply as its executing, for example
changing the `ORDER BY` clause in an SQL query based on a variable argument.
You may want to adopt a similar pattern in your own step classes.

#### ExecutableStep renamed to Step

This one is more cosmetic‚Ä¶

Since we no longer have plan resolvers deep in inputs, we no longer have the
`ModifierStep` system that was used for managing them (it‚Äôs been replaced with
`Modifier` which happens at runtime). Since we no longer have ModifierStep, we
no longer need `BaseStep` to be separate from and inherited by `ExecutableStep`,
so we‚Äôve merged them. Since this is the base class for _all_ steps now, we‚Äôve
renamed it to simply `Step`.

_We have kept an <code>ExecutableStep</code> export for backwards
compatibility._
