/*
 * This file contains all our utilities for dealing with Mermaid-js
 */

import type {
  GrafastPlanBucketJSONv1,
  GrafastPlanJSON,
  GrafastPlanJSONv1,
  GrafastPlanStepJSONv1,
} from "./interfaces";
import { stripAnsi } from "./stripAnsi.js";

/**
 * An array of hex colour codes that we use for colouring the buckets/steps in
 * the mermaid-js plan diagram.
 *
 * Generated by mokole.com/palette.html; re-ordered by Jem
 */
export const COLORS = [
  "#696969",
  "#00bfff",
  "#7f007f",
  "#ffa500",
  "#0000ff",
  "#7fff00",
  "#ff1493",
  "#808000",
  "#dda0dd",
  "#ff0000",
  "#ffff00",
  "#00ffff",
  "#4169e1",
  "#3cb371",
  "#a52a2a",
  "#ff00ff",
  "#f5deb3",
];

/**
 * Given a string, escapes the string so that it can be embedded as the description of a node in a mermaid chart.
 *
 * 1. If it's already safe, returns it verbatim
 * 2. If it contains disallowed characters, escape them by replacing them with similar-looking characters,
 * 3. Wrap the string in quote marks.
 *
 * @remarks
 *
 * NOTE: rather than doing literal escapes, we replace with lookalike characters because:
 *
 * 1. Mermaid has a bug when calculating the width of the node that doesn't respect escapes,
 * 2. It's easier to read the raw mermaid markup with substitutes rather than messy escapes.
 *
 * @internal
 */
export const mermaidEscape = (str: string): string => {
  if (str.match(/^[a-z0-9 ]+$/i)) {
    return str;
  }
  // Technically we should replace with escapes like this:
  //.replace(/[#"]/g, (l) => ({ "#": "#35;", '"': "#quot;" }[l as any]))
  // However there's a bug in Mermaid's rendering that causes the node to use
  // the escaped string as the width for the node rather than the unescaped
  // string. Thus we replace with similar looking characters.
  return `"${stripAnsi(str.trim())
    .replace(
      /[#"<>]/g,
      (l) =>
        ({ "#": "ꖛ", '"': "”", "<": "ᐸ", ">": "ᐳ" })[
          l as "#" | '"' | "<" | ">"
        ],
    )
    .replace(/\r?\n/g, "<br />")}"`;
};

export interface PrintPlanGraphOptions {
  printPathRelations?: boolean;
  includePaths?: boolean;
  concise?: boolean;
  skipBuckets?: boolean;
}

function isGrafastPlanJSONv1(json: GrafastPlanJSON): json is GrafastPlanJSONv1 {
  return json.version === "v1";
}

function shouldHideStep(step: GrafastPlanStepJSONv1) {
  return (step.extra?.constant as any)?.type === "undefined";
}

export function planToMermaid(
  planJSON: GrafastPlanJSON,
  {
    // printPathRelations = false,
    concise = false,
    skipBuckets = (global as any).grafastExplainMermaidSkipBuckets ?? false,
  }: PrintPlanGraphOptions = {},
): string {
  if (!isGrafastPlanJSONv1(planJSON)) {
    throw new Error("planToMermaid only supports v1 plan JSON");
  }

  const stepById: { [stepId: number | string]: GrafastPlanStepJSONv1 } =
    Object.create(null);
  const layerPlanById: {
    [layerPlanId: number | string]: GrafastPlanBucketJSONv1;
  } = Object.create(null);
  const dependentsByStepId: {
    [stepId: string | number]: GrafastPlanStepJSONv1[] | undefined;
  } = Object.create(null);
  const sortedSteps: GrafastPlanStepJSONv1[] = [];
  const extractSteps = (bucket: GrafastPlanBucketJSONv1): void => {
    if (layerPlanById[bucket.id]) {
      // Already processed. Likely either a combo or descendant of a combo
      return;
    }
    layerPlanById[bucket.id] = bucket;
    // Shallowest bucket first, then most dependencies
    const sorted = [...bucket.steps].sort(
      (a, z) => z.dependencyIds.length - a.dependencyIds.length,
    );
    for (const step of sorted) {
      if (stepById[step.id]) {
        throw new Error(
          `Step ${step.id} (${step.stepClass}/${step.metaString}) duplicated in plan?!`,
        );
      }
      stepById[step.id] = step;
      sortedSteps.push(step);
      for (const depId of step.dependencyIds) {
        if (!dependentsByStepId[depId]) {
          dependentsByStepId[depId] = [step];
        } else {
          dependentsByStepId[depId]!.push(step);
        }
      }
    }
    for (const child of bucket.children) {
      extractSteps(child);
    }
  };
  extractSteps(planJSON.rootBucket);

  const color = (i: number) => {
    return COLORS[i % COLORS.length];
  };

  const planStyle = `fill:#fff,stroke-width:1px,color:#000`;
  const itemplanStyle = `fill:#fff,stroke-width:2px,color:#000`;
  const unbatchedplanStyle = `fill:#dff,stroke-width:1px,color:#000`;
  const sideeffectplanStyle = `fill:#fcc,stroke-width:2px,color:#000`;
  const graph = [
    `%%{init: {'themeVariables': { 'fontSize': '12px'}}}%%`,
    `${concise ? "flowchart" : "graph"} TD`,
    `    classDef path fill:#eee,stroke:#000,color:#000`,
    `    classDef plan ${planStyle}`,
    `    classDef itemplan ${itemplanStyle}`,
    `    classDef unbatchedplan ${unbatchedplanStyle}`,
    `    classDef sideeffectplan ${sideeffectplanStyle}`,
    `    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left`,
    ``,
  ];

  const squish = (str: string, start = 8, end = 8): string => {
    if (str.length > start + end + 4) {
      return `${str.slice(0, start)}...${str.slice(str.length - end)}`;
    }
    return str;
  };

  const stepToString = (step: GrafastPlanStepJSONv1): string => {
    return `${step.stepClass.replace(/Step$/, "")}${
      step.bucketId === 0 ? "" : `{${step.bucketId}}`
    }${step.metaString ? `<${step.metaString}>` : ""}[${step.id}]`;
  };

  const layerPlans = Object.values(layerPlanById);

  if (!skipBuckets) {
    if (!concise) graph.push("    subgraph Buckets");
    for (let i = 0, l = layerPlans.length; i < l; i++) {
      const layerPlan = layerPlans[i];
      const raisonDEtre =
        ` (${layerPlan.reason.type})` +
        (layerPlan.reason.type === "polymorphic"
          ? `\n${layerPlan.reason.typeNames}`
          : ``);
      graph.push(
        `    Bucket${layerPlan.id}(${mermaidEscape(
          `Bucket ${layerPlan.id}${raisonDEtre}${
            layerPlan.parentSideEffectStepId != null
              ? `\nParent side effect step: ${
                  stepById[layerPlan.parentSideEffectStepId].id
                }`
              : ""
          }${
            layerPlan.copyStepIds.length > 0
              ? `\nDeps: ${layerPlan.copyStepIds
                  .map((pId) => stepById[pId]!.id)
                  .join(", ")}`
              : ""
          }${
            layerPlan.reason.type === "polymorphic"
              ? "\n" + pp(layerPlan.reason.polymorphicPaths)
              : ""
          }\n${
            layerPlan.rootStepId != null && layerPlan.reason.type !== "root"
              ? `\nROOT ${stepToString(stepById[layerPlan.rootStepId])}`
              : ""
          }${startSteps(layerPlan)}`,
        )}):::bucket`,
      );
    }
    if (!concise) graph.push("    end");
  }

  if (!skipBuckets) {
    for (let i = 0, l = layerPlans.length; i < l; i++) {
      const layerPlan = layerPlans[i];
      const childNodes = layerPlan.children.map((c) => `Bucket${c.id}`);
      if (childNodes.length > 0) {
        graph.push(`    Bucket${layerPlan.id} --> ${childNodes.join(" & ")}`);
      }
    }
  }

  const planIdMap = Object.create(null);
  const planId = (plan: GrafastPlanStepJSONv1): string => {
    if (!planIdMap[plan.id]) {
      if (shouldHideStep(plan)) {
        console.warn(
          `Was expecting to hide step ${plan.id}, but we're rendering it anyway?`,
        );
      }
      const planName = plan.stepClass.replace(/Step$/, "");
      const planNode = `${planName}${plan.id}`;
      planIdMap[plan.id] = planNode;
      const rawMeta = plan.metaString;
      const strippedMeta = rawMeta != null ? stripAnsi(rawMeta) : null;
      const meta =
        concise && strippedMeta ? squish(strippedMeta) : strippedMeta;
      const isUnbatched = plan.supportsUnbatched;

      const polyPaths = pp(plan.polymorphicPaths);
      const depIdsInSameBucket = plan.dependencyIds.filter(
        (id) => stepById[id].bucketId === plan.bucketId,
      );
      const polyPathsAreSame =
        depIdsInSameBucket.length >= 1 &&
        depIdsInSameBucket.every(
          (id) => pp(stepById[id].polymorphicPaths) === polyPaths,
        );
      const polyPathsIfDifferent = polyPathsAreSame ? "" : `\n${polyPaths}`;

      const planString = `${planName}[${plan.id}${`∈${plan.bucketId}`}${
        plan.stream ? "@s" : ""
      }]${plan.isUnary ? " ➊" : ""}${polyPathsAreSame && polyPaths !== "" ? "^" : ""}${
        meta ? `\n<${meta}>` : ""
      }${polyPathsIfDifferent}`;
      const [lBrace, rBrace] =
        plan.stepClass === "__ItemStep"
          ? ["[/", "\\]"]
          : plan.isSyncAndSafe
            ? isUnbatched
              ? ["{{", "}}"]
              : ["[", "]"]
            : ["[[", "]]"];
      const planClass = plan.hasSideEffects
        ? "sideeffectplan"
        : plan.stepClass === "__ItemStep"
          ? "itemplan"
          : isUnbatched && !plan.isSyncAndSafe
            ? "unbatchedplan"
            : "plan";
      graph.push(
        `    ${planNode}${lBrace}${mermaidEscape(
          planString,
        )}${rBrace}:::${planClass}`,
      );
    }
    return planIdMap[plan.id];
  };

  graph.push("");
  graph.push("    %% plan dependencies");
  const chainByDep: { [depNode: string]: string } = Object.create(null);

  const depDeets = (step: GrafastPlanStepJSONv1, idx: number) => {
    const forbiddenFlags = step.dependencyForbiddenFlags[idx];
    const onReject = step.dependencyOnReject[idx];
    const info: string[] = [];
    if (forbiddenFlags) {
      if ((forbiddenFlags & 2) === 2) {
        info.push("rejectNull");
      }
      if ((forbiddenFlags & 1) === 0) {
        info.push("trapError");
      }
      if ((forbiddenFlags & 4) === 0) {
        info.push("trapInhibited");
      }
      if (onReject) {
        info.push(`onReject=${trim(stripAnsi(onReject))}`);
      }
    }
    const str = info.join(";");

    if (str) {
      return `|${mermaidEscape(str)}|`;
    } else {
      return "";
    }
  };

  sortedSteps.forEach(
    // This comment is here purely to maintain the previous formatting to reduce a git diff.
    (plan) => {
      if (shouldHideStep(plan)) return;
      const planNode = planId(plan);
      const depNodes = plan.dependencyIds
        .map((depId) => {
          const step = stepById[depId];
          if (shouldHideStep(step)) {
            return null;
          } else {
            return planId(step);
          }
        })
        .filter((n): n is string => n !== null);
      const transformItemPlanNode = null;
      /*
      plan.stepClass === '__ListTransformStep'
        ? planId(
            steps[operationPlan.transformDependencyPlanIdByTransformStepId[plan.id]],
          )
        : null;
        */
      if (depNodes.length > 0) {
        if (plan.stepClass === "__ItemStep") {
          const [firstDep, ...rest] = depNodes;
          const arrow = plan.extra?.transformStepId == null ? "==>" : "-.->";
          graph.push(
            `    ${firstDep} ${arrow}${depDeets(plan, 0)} ${planNode}`,
          );
          if (rest.length > 0) {
            const normal: string[] = [];
            for (let i = 0; i < rest.length; i++) {
              const r = rest[i];
              const deets = depDeets(plan, i + 1);
              if (deets) {
                graph.push(`    ${r} -->${deets} ${planNode}`);
              } else {
                normal.push(r);
              }
            }
            outputGroupedNormalLinks(graph, planNode, normal);
          }
        } else {
          if (
            concise &&
            !dependentsByStepId[plan.id] &&
            depNodes.length === 1
          ) {
            // Try alternating the nodes so they render closer together
            const depNode = depNodes[0];
            if (chainByDep[depNode] === undefined) {
              graph.push(`    ${depNode} -->${depDeets(plan, 0)} ${planNode}`);
            } else {
              graph.push(
                `    ${chainByDep[depNode]} o--o${depDeets(
                  plan,
                  0,
                )} ${planNode}`,
              );
            }
            chainByDep[depNode] = planNode;
          } else {
            const normal: string[] = [];
            for (let i = 0; i < depNodes.length; i++) {
              const r = depNodes[i];
              const deets = depDeets(plan, i + 1);
              if (deets) {
                graph.push(`    ${r} -->${deets} ${planNode}`);
              } else {
                normal.push(r);
              }
            }
            outputGroupedNormalLinks(graph, planNode, normal);
          }
        }
      }
      if (transformItemPlanNode) {
        graph.push(`    ${transformItemPlanNode} -.-> ${planNode}`);
      }
      return plan;
    },
  );

  graph.push("");
  graph.push("    %% define steps");
  sortedSteps.forEach((step) => {
    if (!shouldHideStep(step)) {
      planId(step);
    }
  });

  for (let i = 0, l = layerPlans.length; i < l; i++) {
    const layerPlan = layerPlans[i];
    const steps = layerPlan.steps;
    graph.push(
      `    classDef bucket${layerPlan.id} stroke:${color(layerPlan.id)}`,
    );
    graph.push(
      `    class ${[
        `Bucket${layerPlan.id}`,
        ...steps.filter((s) => !shouldHideStep(s)).map(planId),
      ].join(",")} bucket${layerPlan.id}`,
    );
  }

  let firstSideEffect = true;
  sortedSteps.forEach((step) => {
    if (step.implicitSideEffectStepId) {
      if (firstSideEffect) {
        graph.push("");
        graph.push("    %% implicit side effects");
        firstSideEffect = false;
      }
      const sideEffectStep = stepById[step.implicitSideEffectStepId];
      graph.push(`    ${planId(sideEffectStep)} -.-o ${planId(step)}`);
    }
  });

  graph.push("");

  // Handle concat for any "combination" layer plans
  for (let i = 0, l = layerPlans.length; i < l; i++) {
    const layerPlan = layerPlans[i];
    if (layerPlan.reason.type === "combined") {
      for (const { targetStepId, sources } of layerPlan.reason.combinations) {
        const targetStep = stepById[targetStepId];
        const nodule = `Nodule_${targetStepId}`;
        graph.push(
          `    ${nodule}:::plan@{shape: dbl-circ} -.-> ${planId(targetStep)}`,
        );
        graph.push(`    class ${nodule} bucket${layerPlan.id}`);
        for (const { stepId } of sources) {
          const step = stepById[stepId];
          graph.push(`    ${planId(step)} -.-> ${nodule}`);
        }
      }
    }
  }

  const graphString = graph.join("\n");
  return graphString;
  function startSteps(layerPlan: GrafastPlanBucketJSONv1) {
    function shortStep(step: GrafastPlanStepJSONv1) {
      return `${step.stepClass.replace(/Step$/, "") ?? ""}[${step.id}]`;
    }
    function shortSteps(
      steps: ReadonlyArray<GrafastPlanStepJSONv1> | undefined,
    ) {
      if (!steps) {
        return "";
      }
      const str = steps.map(shortStep).join(", ");
      if (str.length < 40) {
        return str;
      } else {
        return steps.map((s) => s.id).join(", ");
      }
    }
    return layerPlan.phases.length === 1
      ? ``
      : `\n${layerPlan.phases
          .map(
            (phase, i) =>
              `${i + 1}: ${shortSteps(
                phase.normalStepIds?.map((id) => stepById[id]),
              )}${
                phase.unbatchedStepIds
                  ? `\n>: ${shortSteps(
                      phase.unbatchedStepIds.map((id) => stepById[id]),
                    )}`
                  : ""
              }`,
          )
          .join("\n")}`;
  }
}

function pp(polymorphicPaths: ReadonlyArray<string> | null | undefined) {
  if (!polymorphicPaths) {
    return "";
  }
  return polymorphicPaths.map((p) => `${p}`).join("\n");
}

export * from "./planJSONInterfaces.js";

function trim(string: string, length = 15): string {
  if (string.length > length) {
    return string.substring(0, length - 2) + "…";
  } else {
    return string;
  }
}

function outputGroupedNormalLinks(
  graph: string[],
  planNode: string,
  normal: string[],
) {
  if (normal.length) {
    const counts: Record<string, number> = Object.create(null);
    for (const n of normal) {
      if (counts[n]) {
        counts[n]++;
      } else {
        counts[n] = 1;
      }
    }
    const oners = Object.keys(counts).filter((n) => counts[n] === 1);
    if (oners.length >= 1) {
      graph.push(`    ${oners.join(" & ")} --> ${planNode}`);
    }
    for (const [n, c] of Object.entries(counts)) {
      if (c !== 1) {
        graph.push(`    ${n} -- ${c} --> ${planNode}`);
      }
    }
  }
}
